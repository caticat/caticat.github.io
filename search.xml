<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言-内存管理-结构体</title>
    <url>/2018/04/26/c-memory-struct/</url>
    <content><![CDATA[<p>首先，结构在C语言中也是一种数据类型，叫做聚组类型（还包括数组）。他和其他的数据类型是一样的，在定义一个结构体的时候，系统并不会为他真正的分配内存空间(定义的结构体变量要在编译的阶段才分配空间，而结构体指针要显示的使用malloca来分配空间)，也就是说，在定义结构体这种数据类型的时候是不会分配内存空间的，只有在定义变量的时候，才会分配。</p>
<p>下面是摘自百度百科 对结构题存储的三点：</p>
<ol>
<li>结构体变量的首地址能够被其最宽基本类型成员的大小所整除</li>
<li>结构体每个成员相对于结构体首地址的偏移量都是成员大小的整数倍，如有需要编译器会  在成员之间加上填充字节</li>
<li>结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节<a id="more"></a>

</li>
</ol>
<p>结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s1</span>&#123;</span></span><br><span class="line">　　<span class="keyword">char</span> a;</span><br><span class="line">　　<span class="keyword">int</span> b;</span><br><span class="line">　　<span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>内存分配为:1+3+4+1+3=12<br>其中两个char后面的+3为填充字符</p>
<p>结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s1</span>&#123;</span></span><br><span class="line">　　<span class="keyword">int</span> b;</span><br><span class="line">　　<span class="keyword">char</span> a;</span><br><span class="line">　　<span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>内存分配为:4+1+1+2=8<br>其中两个char后面的+2为填充字符</p>
<p>相比之下,后面的顺序提高了存储空间的利用率</p>
<ul>
<li>编译器在给结构体开辟空间时，首先找到结构体中最宽的基本数据类型，然后寻找内存地址能是该基本数据类型的整倍的位置，作为结构体的首地址。</li>
<li>为结构体的一个成员开辟空间之前，编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是本成员的整数倍，若是，则存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。</li>
<li>结构体的总大小为结构体中最宽基本数据成员的整数倍。如有需要，编译器将会在结构体的添加填充字符。</li>
<li>在组织数据结构的数据成员的时候，可以将相同类型的成员放在一起，这样就减少了编译器为了对齐而添加的填充字符。</li>
</ul>
]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存问题和解决方案-缓存穿透/缓存击穿/缓存雪崩</title>
    <url>/2020/11/13/cache-problem/</url>
    <content><![CDATA[<p>摘抄自(<a href="https://blog.csdn.net/kongtiao5/article/details/82771694">https://blog.csdn.net/kongtiao5/article/details/82771694</a>)</p>
<h2 id="缓存处理流程"><a href="#缓存处理流程" class="headerlink" title="缓存处理流程"></a>缓存处理流程</h2><p>前台请求，后台先从缓存中取数据，取到直接返回结果，取不到时从数据库中取，数据库取到更新缓存，并返回结果，数据库也没取到，那直接返回空结果。</p>
<img src="/2020/11/13/cache-problem/cache_1.png" class="" title="cache flow">

<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><a id="more"></a>

<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截</li>
<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</li>
</ul>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力</p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li>设置热点数据永远不过期</li>
<li>加互斥锁<ul>
<li>说明<ul>
<li>缓存中有数据，直接走上述代码13行后就返回结果了</li>
<li>缓存中没有数据，第1个进入的线程，获取锁并从数据库去取数据，没释放锁之前，其他并行进入的线程会等待100ms，再重新去缓存取数据。这样就防止都去数据库重复取数据，重复往缓存中更新数据情况出现</li>
<li>当然这是简化处理，理论上如果能根据key值加锁就更好了，就是线程A从数据库取key1的数据并不妨碍线程B取key2的数据，上面代码明显做不到这点</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，        缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库</p>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生</li>
<li>如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中</li>
<li>设置热点数据永远不过期</li>
</ul>
]]></content>
      <categories>
        <category>cache</category>
      </categories>
      <tags>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title>Git版本回退</title>
    <url>/2018/10/09/git-revert/</url>
    <content><![CDATA[<h2 id="回退未暂存版本代码"><a href="#回退未暂存版本代码" class="headerlink" title="回退未暂存版本代码"></a>回退未暂存版本代码</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li>回退未使用<code>git add</code>命令添加的代码</li>
<li>本地修改消失</li>
<li>新文件不会丢失</li>
</ul>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul>
<li><code>git checkout -- 文件名</code>,回退指定文件</li>
<li><code>git checkout .</code>,回退所有未暂存的文件</li>
</ul>
<h2 id="回退暂存代码"><a href="#回退暂存代码" class="headerlink" title="回退暂存代码"></a>回退暂存代码</h2><a id="more"></a>

<h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><ul>
<li>已经使用<code>git add</code>命令添加的文件</li>
<li>就是撤销<code>git add</code>命令,修改的内容不会丢失</li>
</ul>
<h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><ul>
<li><code>git reset HEAD 文件名</code>,撤销暂存指定文件</li>
<li><code>git reset HEAD .</code>,撤销所有暂存文件</li>
</ul>
<h2 id="回退已经提交的代码"><a href="#回退已经提交的代码" class="headerlink" title="回退已经提交的代码"></a>回退已经提交的代码</h2><h3 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h3><ul>
<li>就是版本回滚</li>
<li>回退后可以使用<code>git reflog</code>来再次回退到未来的版本,只要没有清除缓存并且保存有提交的id</li>
</ul>
<h3 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h3><ul>
<li><code>git reset --hard HEAD^</code>,回退到上个版本(可以扩展为<code>^回退步数</code>,<code>~回退步数</code>,这里^是分支,<del>是本分支提交(^和</del>的概念我没有弄清楚))</li>
<li><code>git reset --hard 提交id</code>,回退到指定版本</li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2018/03/26/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>hexo usage</title>
    <url>/2018/03/27/hexo-usage/</url>
    <content><![CDATA[<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>用<code>makrdown</code>文件为源,生成<code>html</code>文件的框架</p>
<h2 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h2><h3 id="添加tag支持"><a href="#添加tag支持" class="headerlink" title="添加tag支持"></a>添加<code>tag</code>支持</h3><ol>
<li><code>hexo new page &quot;tags&quot;</code></li>
<li>编辑页面:<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Tagcloud</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018-03-27 16:59:00</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;tags&quot;</span></span><br><span class="line"><span class="comment"># commentts: false # 如果有评论功能需要禁止评论</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></li>
<li>主题的配置文件增加<code>tags</code>处理,在<code>menu</code>中添加:<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">Home:</span> <span class="string">/</span></span><br><span class="line">  <span class="attr">Archives:</span> <span class="string">/archives</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags</span></span><br></pre></td></tr></table></figure></li>
<li>重新清理编译生成即可</li>
</ol>
<a id="more"></a>

<h3 id="添加Categories支持"><a href="#添加Categories支持" class="headerlink" title="添加Categories支持"></a>添加<code>Categories</code>支持</h3><h2 id="快速入门-使用github-gitpage搭建自动更新博客"><a href="#快速入门-使用github-gitpage搭建自动更新博客" class="headerlink" title="快速入门(使用github,gitpage搭建自动更新博客)"></a>快速入门(使用<code>github</code>,<code>gitpage</code>搭建自动更新博客)</h2><ol>
<li><code>github</code>上创建<code>gitpage</code>的仓库,格式:<code>用户名.github.io</code></li>
<li><code>github</code>上创建分支<code>source</code></li>
<li>将远程库更新到本地 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/用户名.github.io 用户名.github.io <span class="comment"># 复制</span></span><br><span class="line">git checkout <span class="built_in">source</span> <span class="comment"># 切换到分支</span></span><br></pre></td></tr></table></figure></li>
<li>本机安装<code>hexo</code>相关软件(记得勾选环境变量)<ol>
<li><code>git</code>,安装包安装</li>
<li><code>node-js</code>,安装包安装</li>
</ol>
</li>
<li>本地创建页面 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mkdir 用户名.github.io # 名字随意,为了方便,统一用库名</span></span><br><span class="line"><span class="comment"># cd 用户名.github.io</span></span><br><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
 会产生初始文件<ul>
<li><code>_config.yml</code>,网站配置文件(改下名字啊什么的)</li>
<li><code>package.json</code>,<code>npm</code>的环境配置文件(调用<code>npm install</code>时会调用这个文件来配置环境)</li>
<li><code>scaffolds</code>模版</li>
<li><code>source</code>源文件目录(就是<code>.md</code>文件的位置)</li>
<li><code>themes</code>主题目录,下载后在<code>_config.yml</code>中修改为对应的文件夹名即可使用相关主题(更换主题后建议使用<code>hexo clean</code>清除旧数据)</li>
</ul>
</li>
<li>本地测试 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g <span class="comment"># 生成`html`静态页面</span></span><br><span class="line">hexo s <span class="comment"># 本地预览测试</span></span><br></pre></td></tr></table></figure></li>
<li>编写<code>.travis.yml</code>文件(简单配置,分支<code>source</code>上传才处理,自动安装hexo,自动强制推送到<code>master</code>分支,<code>GH_TOKEN</code>是在travis上的项目中定义,使用的是github上专门创建的<code>personal access token</code>)<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span> <span class="string">stable</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo</span> <span class="string">--save</span></span><br><span class="line">  <span class="comment">#- npm install -g hexo-cli</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">g</span></span><br><span class="line"></span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">./public</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">init</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;# Pan&#x27;s Blog&quot;</span> <span class="string">&gt;&gt;</span> <span class="string">README.md</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;![travis](https://travis-ci.org/a/a.github.io.svg?branch=source)&quot;</span> <span class="string">&gt;&gt;</span> <span class="string">README.md</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.name</span> <span class="string">&quot;a&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.email</span> <span class="string">&quot;a@b.com&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">add</span> <span class="string">.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">commit</span> <span class="string">-m</span> <span class="string">&quot;Update docs&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">push</span> <span class="string">--force</span> <span class="string">--quiet</span> <span class="string">&quot;https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;&quot;</span> <span class="string">master:master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">source</span></span><br><span class="line"></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">GH_REF:</span> <span class="string">github.com/a/a.github.io.git</span></span><br></pre></td></tr></table></figure></li>
<li>推送到<code>github</code>上:<code>git push</code></li>
<li>等<code>travis</code>运行结束,即可访问<code>https://用户名.github.io</code>来看网页了</li>
<li>后续更新<ul>
<li><code>hexo new 文件名</code>生成<code>.md</code>文件</li>
<li>编辑对应的<code>.md</code>文件</li>
<li>上传到<code>github</code>:<code>git commit -am &quot;xxx&quot; &amp;&amp; git push</code></li>
<li>等待<code>travis</code>完成操作</li>
<li>刷新网页看效果</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>leveldb源码阅读-c11相关知识整理</title>
    <url>/2019/02/12/leveldb-source-c11/</url>
    <content><![CDATA[<p>因为leveldb源码中大量的运用了c11的知识点,不懂的话是要仔细看看的<br>这里做了一下总结的功能和记录<br>会根据我看到的内容慢慢扩展</p>
<h2 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h2><p>标记在函数的<code>()</code>后面,表示希望函数无异常抛出,如果函数抛出任何异常,则会报错crash</p>
<ul>
<li>这里说的是修饰符版本,不是操作符版本</li>
<li>操作符版本会根据函数是否有<code>noexcept</code>修饰过来返回bool类型值表示是否期望无异常抛出</li>
</ul>
<h2 id="临时变量的简单说明"><a href="#临时变量的简单说明" class="headerlink" title="临时变量的简单说明"></a>临时变量的简单说明</h2><p>简单的说,我们能够看到的命名变量都不是临时变量</p>
<h2 id="amp-amp-参数的右值引用"><a href="#amp-amp-参数的右值引用" class="headerlink" title="&amp;&amp;参数的右值引用"></a>&amp;&amp;参数的右值引用</h2><p>在拷贝构造函数与赋值函数中会大量使用右值引用的优化<br>使用右值引用可以有效减少构造函数的调用<br>右值引用的本质是将临时参数对象的值交换给实际上有效的对象<br>而不是复制一份新的给对象<br>系统会自动判断,如果参数是临时变量,<br>则会优先调用右值引用优化处理的函数,<br>如果找不到,则会自动调用普通的函数处理.<br>非临时变量全部是调用普通的函数处理.</p>
<p>普通的声明</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Status(<span class="keyword">const</span> Status&amp; rhs);</span><br><span class="line">Status&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Status&amp; rhs);</span><br></pre></td></tr></table></figure>

<p>使用右值引用的声明</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Status(Status&amp;&amp; rhs) <span class="keyword">noexcept</span> : state_(rhs.state_) &#123; rhs.state = <span class="literal">nullptr</span>; &#125;</span><br><span class="line">Status&amp; <span class="keyword">operator</span>=(Status&amp;&amp; rhs) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="keyword">inline</span> Status&amp; Status::<span class="keyword">operator</span>=(Status&amp;&amp; rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="built_in">std</span>::swap(state_, rhs.state_); <span class="comment">// 注意:这里是交换,没有复制</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意:</p>
<ul>
<li>右值引用优化需要和普通的老版本标准函数结合使用,最好不要单独使用,否则会出现无法复制非临时变量的对象</li>
<li>右值引用的函数参数不是<code>const</code>,这里要注意,因为交换时实际是修改了参数的内容的</li>
</ul>
<a id="more"></a>

<h2 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h2><p>有些声明了对象名,<br>但实际是临时对象的参数,<br>想要使用右值引用做优化时,<br>可以使用这个函数将对象强制转化为右值参数,<br>从而调用右值引用的优化函数.</p>
<p><strong>注:不要使用已经被右值优化函数处理过的原始对象,因为他的内容很可能已经不对了</strong></p>
<h2 id="default"><a href="#default" class="headerlink" title="= default"></a>= default</h2><p>用于修饰一些可以提供默认函数体的函数(构造函数,复制构造函数,赋值函数等)<br>显示的表明使用默认提供的函数</p>
<h2 id="delete"><a href="#delete" class="headerlink" title="= delete"></a>= delete</h2><p>类似<code>= default</code>,是禁用函数的意思.<br>区别是可以对非默认函数使用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">float</span> a)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    Test data1;</span><br><span class="line">    data1.test(<span class="number">1</span>); <span class="comment">// OK</span></span><br><span class="line">    data1.test(<span class="number">0.5</span>); <span class="comment">// error: call to member function &#x27;test&#x27; is ambiguous</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leveldb</category>
      </categories>
      <tags>
        <tag>leveldb</tag>
        <tag>source</tag>
        <tag>database</tag>
        <tag>c11</tag>
      </tags>
  </entry>
  <entry>
    <title>leveldb源码阅读-db</title>
    <url>/2019/02/15/leveldb-source-db/</url>
    <content><![CDATA[<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>定义了统一使用的数据库接口<br>规定了该类型的数据结构存储了有序键值对集合<br>同时内部保证了线程安全,外部无需关心线程安全问题<br><strong>接口类,内部实现没有看到,所以有很多TODO待后续阅读到相关代码补全</strong></p>
<h2 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h2><p><code>db.h</code></p>
<h2 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h2><h3 id="SnapShort"><a href="#SnapShort" class="headerlink" title="SnapShort"></a>SnapShort</h3><p>抽象类<br>记录特定状态的DB</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">Snapshot</span> &#123;</span></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~Snapshot();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><p>表示一个范围的key<br>包括开始和结束<br>TODO:目前不确定它的边界是否包含</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A range of keys</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">Range</span> &#123;</span></span><br><span class="line">  Slice start;          <span class="comment">// Included in the range</span></span><br><span class="line">  Slice limit;          <span class="comment">// Not included in the range</span></span><br><span class="line"></span><br><span class="line">  Range() &#123; &#125;</span><br><span class="line">  Range(<span class="keyword">const</span> Slice&amp; s, <span class="keyword">const</span> Slice&amp; l) : start(s), limit(l) &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="DB"><a href="#DB" class="headerlink" title="DB"></a>DB</h3><p>数据库接口类<br>内部没有属性<br>只提供方法调用</p>
<ul>
<li><code>Open</code>,打开数据库<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Status <span class="title">Open</span><span class="params">(<span class="keyword">const</span> Options&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">                     DB** dbptr)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><code>DB() = default;</code>,提供默认构造函数</li>
<li><code>DB(const DB&amp;) = delete;</code>,禁用拷贝构造函数</li>
<li><code>DB&amp; operator=(const DB&amp;) = delete;</code>,禁用赋值构造函数</li>
<li><code>virtual ~DB();</code>,析构函数</li>
<li>接口<ul>
<li><code>Put</code>,需要实现的设置键值对的接口<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">Put</span><span class="params">(<span class="keyword">const</span> WriteOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">const</span> Slice&amp; value)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li><code>virtual Status Delete(const WriteOptions&amp; options, const Slice&amp; key) = 0;</code>,待实现的删除key的接口(删除不存在的key规定不会报错,为正常操作)</li>
<li><code>virtual Status Write(const WriteOptions&amp; options, WriteBatch* updates) = 0;</code>,批量修改数据库数据(TODO:应该是批量插入(包含修改)和删除,不确定)</li>
<li><code>Get</code>,获取指定key的值,可能会返回各种错误<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">Get</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">const</span> Slice&amp; key, <span class="built_in">std</span>::<span class="built_in">string</span>* value)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li><code>virtual Iterator* NewIterator(const ReadOptions&amp; options) = 0;</code>,新建一个该数据库的迭代器,有几点需要注意的<ul>
<li>新返回的迭代器在使用前必须手动调用对应的<code>Seek</code>函数来初始化</li>
<li>必须在DB被删除前手动删除迭代器</li>
</ul>
</li>
<li><code>virtual const Snapshot* GetSnapshot() = 0;</code>,获取一个当前db的snapshot<ul>
<li>TODO:上面的迭代器应该都是通过这个snapshot来创建出来的(这个不确定)</li>
<li>必须手动调用<code>ReleaseSnapshot</code>来释放快照</li>
</ul>
</li>
<li><code>virtual void ReleaseSnapshot(const Snapshot* snapshot) = 0;</code>,释放指定的快照,释放后不能使用被释放的快照内容了</li>
<li><code>virtual bool GetProperty(const Slice&amp; property, std::string* value) = 0;</code>,可以获得数据库的一些基本属性信息</li>
<li><code>GetApproximateSizes</code>,获取[0,n-1]层等指定范围的key数据所占用的硬盘空间的大概(不是精确值)空间尺寸,这里获得的是硬盘占用尺寸,而不是数据实际大小,压缩数据会影响这个值<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GetApproximateSizes</span><span class="params">(<span class="keyword">const</span> Range* range, <span class="keyword">int</span> n,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">uint64_t</span>* sizes)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li><code>virtual void CompactRange(const Slice* begin, const Slice* end) = 0;</code>,加锁指定范围的key数据,优化空间,删除无效或者重复key数据,接口应该只被底层实现者调用,范围参数如果为nullptr则表示最开始或者最终点,都是nullptr则表示整个数据库</li>
</ul>
</li>
</ul>
<h2 id="全局函数"><a href="#全局函数" class="headerlink" title="全局函数"></a>全局函数</h2><ul>
<li><code>DestroyDB</code>,删库(TODO:估计是硬盘数据),危险函数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LEVELDB_EXPORT Status <span class="title">DestroyDB</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> Options&amp; options)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><code>RepairDB</code>,如果数据库无法正常打开,可以使用这个接口修复尽可能多的数据(部分数据会丢失),所以对重要数据库使用前需要谨慎处理<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LEVELDB_EXPORT Status <span class="title">RepairDB</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">const</span> Options&amp; options)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>leveldb</category>
      </categories>
      <tags>
        <tag>leveldb</tag>
        <tag>source</tag>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title>leveldb源码阅读-options</title>
    <url>/2019/02/15/leveldb-source-options/</url>
    <content><![CDATA[<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>配置文件统一的文件<br>配置文件因为比较常用,紧接着会补齐配置文件中的TODO内容,<br>把各个参数的作用都理解和写清楚</p>
<h2 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h2><p><code>options.h</code><br><code>util/options.cc</code></p>
<h2 id="CompressionType"><a href="#CompressionType" class="headerlink" title="CompressionType"></a>CompressionType</h2><p>db包含了一组set的block<br>block是用于存储连续键值对的<br>block是从硬盘读取到内存的单个最小单位<br>block最终会存储在file文件中<br>block在存储在file中前,<br>可能会使用某种方法进行压缩处理,<br>这个枚举是用于表示block采取了那种压缩方法的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompressionType</span> &#123;</span></span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> do not change the values of existing entries, as these are</span></span><br><span class="line">  <span class="comment">// part of the persistent format on disk.</span></span><br><span class="line">  kNoCompression     = <span class="number">0x0</span>,</span><br><span class="line">  kSnappyCompression = <span class="number">0x1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h2><p>统一的参数配置存储结构类<br>用于<code>DB::Open</code>函数<br>没有什么接口<br>只有一个构造函数<br>和一套配置属性</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>所有属性的初始值可以从构造函数中得出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Options::Options()</span><br><span class="line">    : comparator(BytewiseComparator()),</span><br><span class="line">      create_if_missing(<span class="literal">false</span>),</span><br><span class="line">      error_if_exists(<span class="literal">false</span>),</span><br><span class="line">      paranoid_checks(<span class="literal">false</span>),</span><br><span class="line">      env(Env::Default()),</span><br><span class="line">      info_log(<span class="literal">nullptr</span>),</span><br><span class="line">      write_buffer_size(<span class="number">4</span>&lt;&lt;<span class="number">20</span>),</span><br><span class="line">      max_open_files(<span class="number">1000</span>),</span><br><span class="line">      block_cache(<span class="literal">nullptr</span>),</span><br><span class="line">      block_size(<span class="number">4096</span>),</span><br><span class="line">      block_restart_interval(<span class="number">16</span>),</span><br><span class="line">      max_file_size(<span class="number">2</span>&lt;&lt;<span class="number">20</span>),</span><br><span class="line">      compression(kSnappyCompression),</span><br><span class="line">      reuse_logs(<span class="literal">false</span>),</span><br><span class="line">      filter_policy(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li>行为属性<ul>
<li><code>const Comparator* comparator;</code>,比较器,用于key排序用,必须保证这个排序和上次数据库存储时用的排序器是一致的,否则会出现取数据取不到等等各种问题.默认是按照字典规则排序的</li>
<li><code>bool create_if_missing;</code>,当数据库不存在时,是否创建数据库</li>
<li>详细说明:<ul>
<li>在<code>DB::Open</code>-&gt;<code>DBImpl::Recover</code>中使用<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!env_-&gt;FileExists(CurrentFileName(dbname_))) &#123;</span><br><span class="line">  <span class="keyword">if</span> (options_.create_if_missing) &#123;</span><br><span class="line">    s = NewDB();</span><br><span class="line">    <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::InvalidArgument(</span><br><span class="line">        dbname_, <span class="string">&quot;does not exist (create_if_missing is false)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (options_.error_if_exists) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::InvalidArgument(</span><br><span class="line">        dbname_, <span class="string">&quot;exists (error_if_exists is true)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>bool error_if_exists;</code>,设置为真时,当数据库已经存在则报错</li>
<li>调用位置和<code>create_if_missing</code>一致,上面有代码</li>
<li><code>bool paranoid_checks;</code>,是否开启完整检查(TODO:不是很清晰检查的内容),只要发现一点错误,整个数据库都不可读取</li>
<li>相关代码<ul>
<li><code>ReadBlock</code>函数中<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* data = contents.data();    <span class="comment">// Pointer to where Read put the data</span></span><br><span class="line"><span class="keyword">if</span> (options.verify_checksums) &#123; <span class="comment">// 这里的verify_checksums就是通过paranoid_checks的值获得的</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> crc = crc32c::Unmask(DecodeFixed32(data + n + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> actual = crc32c::Value(data, n + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (actual != crc) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] buf;</span><br><span class="line">    s = Status::Corruption(<span class="string">&quot;block checksum mismatch&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>Env* env;</code>,环境(TODO:不理解作用)</li>
<li><code>Logger* info_log;</code>,日志系统,如果为空,则记录在数据库文件同目录下,否则记录在提供的日志系统中</li>
</ul>
</li>
<li>性能属性<ul>
<li><code>size_t write_buffer_size;</code>,变成有序列表存储于磁盘前,在内存中的数据块大小(同时会同步在磁盘上的未排序日志上记录),同时最多会有2个这样的缓冲区</li>
<li><code>int max_open_files;</code>,数据库最大可以同时打开的文件数量,假定每个文件大小为2MB(TODO:不确定超出这个数量会怎么样)</li>
<li><code>Cache* block_cache;</code>,用于存储内存中的block的集合结构,默认会自动创建一个8MB的缓存结构</li>
<li><code>size_t block_size;</code>,近似的block大小(这里是未压缩的数据的尺寸,压缩后存储在硬盘上的数据应该会更小)</li>
<li><code>int block_restart_interval;</code>,记录key的变化数量,同时和这个值比较,当超过这个值时,开启压缩(TODO:这个功能不是很理解,待深入查看)</li>
<li><code>size_t max_file_size;</code>,硬盘单文件存储最大尺寸,当文件尺寸小于这个值时,不会使用新文件存储数据</li>
<li><code>CompressionType compression;</code>,存储block的压缩算法类型</li>
<li><code>bool reuse_logs;</code>,开启数据库时,是否使用以前的<code>MANIFEST</code>和log文件进行载入优化</li>
<li><code>const FilterPolicy* filter_policy;</code>,是否开启过滤器功能</li>
</ul>
</li>
</ul>
<h2 id="ReadOptions"><a href="#ReadOptions" class="headerlink" title="ReadOptions"></a>ReadOptions</h2><p>读取数据时使用的option</p>
<h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ReadOptions()</span><br><span class="line">    : verify_checksums(<span class="literal">false</span>),</span><br><span class="line">      fill_cache(<span class="literal">true</span>),</span><br><span class="line">      snapshot(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><ul>
<li><code>bool verify_checksums;</code>,是否所有数据读取都要校验checksum</li>
<li><code>bool fill_cache;</code>,是否将读到的数据放在cashe中(遍历数据时一般应该设置为false)</li>
<li><code>const Snapshot* snapshot;</code>,如果为空,则自动创建一个,否则使用参数提供的(必须是可用的snapshot)</li>
</ul>
<h2 id="WriteOptions"><a href="#WriteOptions" class="headerlink" title="WriteOptions"></a>WriteOptions</h2><p>写数据时使用的option</p>
<h3 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">WriteOptions()</span><br><span class="line">    : sync(<span class="literal">false</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h3><ul>
<li><code>bool sync;</code>,是否立刻将数据写入到硬盘文件中(不立刻写入的话,在机器重启的时候会丢数据(但是当进程宕机的话,是不会丢数据的,就是有没有立刻调用<code>fsync</code>函数的区别))</li>
</ul>
]]></content>
      <categories>
        <category>leveldb</category>
      </categories>
      <tags>
        <tag>leveldb</tag>
        <tag>source</tag>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title>leveldb源码阅读-简述</title>
    <url>/2019/02/12/leveldb-source-sketch/</url>
    <content><![CDATA[<p>一直都觉得leveldb的源码不是很好读,<br>一直都在拖延,<br>现在抽出时间,<br>根据自己的阅读,<br>做下笔记记录,<br>希望能够理解学习到其中的内容.</p>
<h2 id="一些补充说明"><a href="#一些补充说明" class="headerlink" title="一些补充说明"></a>一些补充说明</h2><ul>
<li>关于源码版本,以前下载导入到工程的一个版本,具体的不知道,后面看到了补上来吧.不确定新旧.</li>
<li>源码中大量运用了c11的知识点,不懂的话是要仔细看看的</li>
</ul>
]]></content>
      <categories>
        <category>leveldb</category>
      </categories>
      <tags>
        <tag>leveldb</tag>
        <tag>source</tag>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title>leveldb源码-slice</title>
    <url>/2019/02/14/leveldb-source-slice/</url>
    <content><![CDATA[<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>常用的参数,<br>本质就是指针+长度组成的字符串数组<br>但是内部不会申请内存,<br>只是引用外部的指针地址内容<br>二进制安全的字符串</p>
<h2 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h2><p><code>slice.h</code></p>
<a id="more"></a>

<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul>
<li>private<ul>
<li><code>const char* data_</code>,首字符指针</li>
<li><code>size_t size_</code>,字符串长度</li>
</ul>
</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="公共"><a href="#公共" class="headerlink" title="公共"></a>公共</h3><ul>
<li><code>data</code>,返回<code>data_</code>指针</li>
<li><code>size</code>,返回<code>size_</code>值</li>
<li><code>empty</code>,字符串是否为空</li>
<li><code>operator[]</code>获取数组指定索引的char</li>
<li><code>clear</code>,将字符串设置为空””</li>
<li><code>remove_prefix</code>,删除前X个字符</li>
<li><code>ToString</code>,转化为<code>std::string</code></li>
<li><code>compare</code>,比较Slice<ul>
<li>比参数小则返回值&lt;0</li>
<li>相等则返回值=0</li>
<li>比参数大则返回值&gt;0</li>
</ul>
</li>
<li><code>starts_with</code>,判断该结构的前几个字符是否是已参数的字符开始的</li>
</ul>
<h3 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h3><ul>
<li><code>operator==</code>,判断两个Slice是否相同</li>
<li><code>operator!=</code>,判断两个Slice是否不同</li>
</ul>
]]></content>
      <categories>
        <category>leveldb</category>
      </categories>
      <tags>
        <tag>leveldb</tag>
        <tag>source</tag>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title>leveldb源码-Status</title>
    <url>/2019/02/12/leveldb-source-status/</url>
    <content><![CDATA[<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li>用于操作结果的返回</li>
<li>标记操作状态的成功与失败</li>
<li>失败时有相应的描述信息</li>
</ul>
<h2 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h2><p><code>leveldb/status.h</code><br><code>leveldb/util/status.cc</code></p>
<h2 id="内部枚举定义"><a href="#内部枚举定义" class="headerlink" title="内部枚举定义"></a>内部枚举定义</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Code</span> &#123;</span></span><br><span class="line">	kOk = <span class="number">0</span>,</span><br><span class="line">	kNotFound = <span class="number">1</span>,</span><br><span class="line">	kCorruption = <span class="number">2</span>,</span><br><span class="line">	kNotSupported = <span class="number">3</span>,</span><br><span class="line">	kInvalidArgument = <span class="number">4</span>,</span><br><span class="line">	kIOError = <span class="number">5</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul>
<li>private<ul>
<li><code>const char* state_</code>,用于记录错误具体信息<ul>
<li>默认为<code>nullptr</code></li>
<li>如果为<code>nullptr</code>,则表示状态为<code>kOk</code>正常</li>
<li>格式:<ul>
<li>[:3]:后续错误信息字符串的整体长度(不包含长度记录和错误号字节)</li>
<li>[4]:错误号(<code>Code</code>的枚举)</li>
<li>[5:]:错误文字信息<ul>
<li>最多由两段错误信息拼接而成</li>
<li>两段文字中间使用连个字节<code>: </code>分割</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>主要是用于创建Status的方法</p>
<ul>
<li><code>OK</code>,返回正常的Status结构</li>
<li><code>NotFound</code>,返回<code>kNotFound</code>的Status结构</li>
<li><code>Corruption</code>,返回<code>kCorruption</code>的Status结构</li>
<li><code>NotSupported</code>,返回<code>kNotSupported</code>的Status结构</li>
<li><code>InvalidArgument</code>,返回<code>kInvalidArgument</code>的Status结构</li>
<li><code>IOError</code>,返回<code>kIOError</code>的Status结构</li>
<li><code>CopyState</code>,将参数的<code>state</code>字符串完整复制到自身的<code>state</code>中</li>
</ul>
<h3 id="构造复制函数"><a href="#构造复制函数" class="headerlink" title="构造复制函数"></a>构造复制函数</h3><p>分别包含了标准和右值引用优化对应的函数</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="公共"><a href="#公共" class="headerlink" title="公共"></a>公共</h4><ul>
<li><code>ok</code>,返回<code>State</code>是否正常</li>
<li><code>IsNotFound</code>,返回<code>State</code>是否为<code>kNotFound</code></li>
<li><code>IsCorruption</code>,返回<code>State</code>是否为<code>kCorruption</code></li>
<li><code>IsIOError</code>,返回<code>State</code>是否为<code>kIOError</code></li>
<li><code>IsNotSupportedError</code>,返回<code>State</code>是否为<code>kNotSupported</code></li>
<li><code>IsInvalidArgument</code>,返回<code>State</code>是否为<code>kInvalidArgument</code></li>
<li><code>ToString</code>,如果状态正常,则返回”OK”,否则返回对应的错误信息描述</li>
</ul>
<h4 id="私有"><a href="#私有" class="headerlink" title="私有"></a>私有</h4><ul>
<li><code>code</code>,将<code>state_</code>中记录的<code>Code</code>提取出来</li>
</ul>
]]></content>
      <categories>
        <category>leveldb</category>
      </categories>
      <tags>
        <tag>leveldb</tag>
        <tag>source</tag>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的makefile示例(不使用shell系统命令的版本)</title>
    <url>/2018/11/23/makefile-simple-2rd/</url>
    <content><![CDATA[<p>简单的makefile示例<br>没有使用系统命令<br>所以平台通用<br>但是需要手动调整添加新增的目录</p>
<a id="more"></a>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">TARGET = mk</span><br><span class="line">DIR = a b .</span><br><span class="line">OBJS = <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(DIR)</span>, $(<span class="built_in">patsubst</span> %.cpp,%.o,$(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*.cpp)</span>))</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span> : <span class="variable">$(OBJS)</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(OBJS)</span> : %.o : %.cpp</span><br><span class="line">	<span class="variable">$(CXX)</span> -o <span class="variable">$@</span> -c <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	-<span class="variable">$(RM)</span> <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的makefile示例</title>
    <url>/2018/06/08/makefile-simple/</url>
    <content><![CDATA[<p>简单的makefile示例<br>使用了命令查找所有的cpp源文件</p>
<a id="more"></a>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">NAME=test</span><br><span class="line">LINK=g++</span><br><span class="line">CC=gcc</span><br><span class="line">LINKOPTS+= -pthread</span><br><span class="line">CCOPTS+= -std=c++11</span><br><span class="line">CCOPTS+= -g</span><br><span class="line">CCOPTS+= -Wall</span><br><span class="line"></span><br><span class="line">SRCS=<span class="variable">$(<span class="built_in">shell</span> find . -iname &quot;*.cpp&quot;)</span></span><br><span class="line">OBJS=<span class="variable">$(<span class="built_in">patsubst</span> %.cpp, %.o, <span class="variable">$(SRCS)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(NAME)</span> : <span class="variable">$(OBJS)</span></span><br><span class="line">	<span class="variable">$(LINK)</span> -o <span class="variable">$(NAME)</span> <span class="variable">$(OBJS)</span> <span class="variable">$(LINKOPTS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">.cpp.o:</span></span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> <span class="variable">$(CCOPTS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f <span class="variable">$(OBJS)</span> <span class="variable">$(NAME)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJS读写ProtoBuf的例子</title>
    <url>/2018/08/29/nodejs-protobuf/</url>
    <content><![CDATA[<p>NodeJS读写ProtoBuf的例子</p>
<p>包含功能</p>
<ul>
<li>生成proto的脚本</li>
<li>js创建proto对象</li>
<li>js序列化/反序列化proto对象</li>
<li>js写redis数据库</li>
<li>js写文件</li>
<li>go读redis数据库</li>
<li>go反序列化js生成的proto数据</li>
</ul>
<h2 id="protobuff"><a href="#protobuff" class="headerlink" title="protobuff"></a>protobuff</h2><p>实际测试的proto文件<br>使用proto2的语法(只是为了我这边方便)</p>
<p>test123.proto</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> test123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Info</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">optional</span> <span class="built_in">string</span> info = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">message</span> <span class="title">Equip</span></span></span><br><span class="line"><span class="class">	</span>&#123;</span><br><span class="line">		<span class="keyword">optional</span> <span class="built_in">uint32</span> id = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">optional</span> <span class="built_in">string</span> name = <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">optional</span> <span class="built_in">uint32</span> id = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">optional</span> <span class="built_in">string</span> name = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">optional</span> <span class="built_in">bool</span> flag = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">repeated</span> Equip equips = <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">optional</span> Info info = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>导出代码文件方法:</p>
<ul>
<li>js<br>  <code>/D/pan/lib/protoc-3.5.0-win32/bin/protoc3 -I/D/pan/test_javascript/test/proto/src --js_out=import_style=commonjs,binary:D:/pan/test_javascript/test/proto/tar /D/pan/test_javascript/test/proto/src/test123.proto</code></li>
<li>go<br>  <code>/D/pan/lib/protoc-3.5.0-win32/bin/protoc3 -I/D/pan/test_javascript/test/proto/src --go_out=D:/pan/test_go/readjsproto/proto /D/pan/test_javascript/test/proto/src/test123.proto</code></li>
</ul>
<h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><p>测试用js代码,<br>包含了创建protomsg,<br>序列化写文件,<br>写redis数据库</p>
<p>相关的库</p>
<ul>
<li>redis    写数据库</li>
<li>google-protobuf 解析protobuf</li>
</ul>
<p>test.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// protobuf的用法</span></span><br><span class="line"><span class="comment">// 导出.proto文件</span></span><br><span class="line"><span class="comment">// /D/pan/lib/protoc-3.5.0-win32/bin/protoc3 -I/D/pan/test_javascript/test/proto/src --js_out=import_style=commonjs,binary:D:/pan/test_javascript/test/proto/tar /D/pan/test_javascript/test/proto/src/test123.proto</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;./proto/tar/test123_pb&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> msg = <span class="keyword">new</span> proto.test123.Data();</span><br><span class="line">msg.setId(<span class="number">1</span>);</span><br><span class="line">msg.setName(<span class="string">&quot;a啊哈b1&quot;</span>);</span><br><span class="line">msg.setFlag(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">var</span> equips = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> equip = <span class="keyword">new</span> proto.test123.Data.Equip();</span><br><span class="line">    equip.setId(i);</span><br><span class="line">    equip.setName(<span class="string">&quot;aaa&quot;</span>+i);</span><br><span class="line">    equips.push(equip);</span><br><span class="line">&#125;</span><br><span class="line">msg.setEquipsList(equips);</span><br><span class="line"><span class="keyword">var</span> info = <span class="keyword">new</span> proto.test123.Info();</span><br><span class="line">info.setInfo(<span class="string">&quot;阿斯蒂芬&quot;</span>);</span><br><span class="line">msg.setInfo(info);</span><br><span class="line"><span class="keyword">var</span> bytes = msg.serializeBinary();</span><br><span class="line"><span class="comment">// console.log(bytes);</span></span><br><span class="line"><span class="keyword">var</span> msg2 = proto.test123.Data.deserializeBinary(bytes);</span><br><span class="line"><span class="comment">// console.log(msg2);</span></span><br><span class="line">info = msg2.getInfo();</span><br><span class="line"><span class="built_in">console</span>.log(info.getInfo());</span><br><span class="line">equips = msg2.getEquipsList();</span><br><span class="line"><span class="keyword">for</span> (idx <span class="keyword">in</span> equips)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> equip = equips[idx];</span><br><span class="line">    <span class="built_in">console</span>.log(equip.getId(), equip.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写文件</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line">fs.writeFileSync(<span class="string">&quot;./data.txt&quot;</span>, bytes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// redis的用法</span></span><br><span class="line"><span class="keyword">var</span> redis = <span class="built_in">require</span>(<span class="string">&quot;redis&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> client = redis.createClient(<span class="string">&quot;9999&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">client.auth(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">client.on(<span class="string">&quot;error&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.select(<span class="number">0</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;err:&quot;</span>, error);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer(bytes);</span><br><span class="line">        client.set(<span class="string">&quot;proto:data&quot;</span>, buf, <span class="function"><span class="keyword">function</span>(<span class="params">error, res</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;err:&quot;</span>, error);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&quot;res:&quot;</span>, res);</span><br><span class="line">            &#125;</span><br><span class="line">            client.end(<span class="literal">true</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="go"><a href="#go" class="headerlink" title="go"></a>go</h2><p>使用go脚本读取js写的序列化proto数据,<br>包含反序列化redis数据<br>反序列化文件数据</p>
<p>包含的库</p>
<ul>
<li>ivanabc/radix/redis    redis客户端</li>
<li>golang/protobuf/proto    protobuf解析</li>
</ul>
<p>readjsproto.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/ivanabc/radix/redis&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;proto&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/golang/protobuf/proto&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取js写的proto文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// /D/pan/lib/protoc-3.5.0-win32/bin/protoc3 -I/D/pan/test_javascript/test/proto/src --go_out=D:/pan/test_go/readjsproto/proto /D/pan/test_javascript/test/proto/src/test123.proto</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r, err := redis.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:9999&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rep := r.Cmd(<span class="string">&quot;AUTH&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br><span class="line">	<span class="comment">//fmt.Println(rep)</span></span><br><span class="line"></span><br><span class="line">	rep = r.Cmd(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;proto:data&quot;</span>)</span><br><span class="line">	<span class="comment">//fmt.Println(rep)</span></span><br><span class="line"></span><br><span class="line">	data, err := rep.Bytes()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;1错误:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	msg := &amp;test123.Data&#123;&#125;</span><br><span class="line">	proto.Unmarshal(data, msg)</span><br><span class="line">	fmt.Println(<span class="string">&quot;1&quot;</span>, msg.GetId(), msg.GetName(), msg.GetInfo().GetInfo(), msg)</span><br><span class="line"></span><br><span class="line">	data, err = ioutil.ReadFile(<span class="string">&quot;D:/pan/test_javascript/test/data.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;2错误:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	proto.Unmarshal(data, msg)</span><br><span class="line">	fmt.Println(<span class="string">&quot;2&quot;</span>, msg.GetId(), msg.GetName(), msg.GetInfo().GetInfo(), msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>nodejs</tag>
        <tag>protobuf</tag>
      </tags>
  </entry>
  <entry>
    <title>数字编码</title>
    <url>/2019/03/18/number-code/</url>
    <content><![CDATA[<h2 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h2><ul>
<li>这是本人出于兴趣完善的背诵数字编码的小工具.</li>
<li>仅供学习使用</li>
<li>编码内容没有上传到任何公共平台保存</li>
<li>只限在学习群内使用</li>
<li>本人强迫症,后续可能会有更新,但是应该不会再发出来了,更新会提交到<a href="https://github.com/caticat/remember/tree/master/number_code">数字编码</a>这里,有需求可以自取(欢迎提bug,或者推送更新过来)</li>
<li>代码随便改</li>
<li>写完这个工具的我大概编码已经比较熟练了o(╯□╰)o</li>
</ul>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ul>
<li><p>使用平台</p>
<blockquote>
<p>因为是网页,所以本质是全平台的,但是这边主要为手机做的优化显示,因为电脑上看起来也很正常.</p>
</blockquote>
</li>
<li><p>卡顿</p>
<blockquote>
<p>集成图片后,页面可能比较大,没有好办法,建议机器跑不动使用以前没有图片的版本</p>
</blockquote>
</li>
<li><p>界面显示错乱</p>
<blockquote>
<p>已修正,原因是加载外部链接js脚本没有加载成功导致的.</p>
</blockquote>
</li>
<li><p>乱码</p>
<blockquote>
<p>页面使用UTF-8编码,应该是最通用的编码,如果看起来文字不正常,请尝试切换浏览器查看(如果理解原理,可以自行修改文件编码修复乱码)(理论上目前应该没有乱码了)</p>
</blockquote>
</li>
<li><p>哪里可以获取到更新那?</p>
<blockquote>
<p>github地址:<a href="https://github.com/caticat/remember/tree/master/number_code">数字编码</a>,当然,这里是没有数字编码图片信息的,我根本就没有上传</p>
</blockquote>
</li>
<li><p>iphone可以使用吗?</p>
<blockquote>
<p>我就是用iphone打开的,使用百度app或者直接使用内置的备忘录都可以直接打开</p>
</blockquote>
</li>
<li><p>安卓可以用吗?</p>
<blockquote>
<p>看群里的反应应该是可以用的~一个页面而已,理论上应该很通用的.(据说qq浏览器可看)</p>
</blockquote>
</li>
</ul>
<h2 id="版本信息"><a href="#版本信息" class="headerlink" title="版本信息"></a>版本信息</h2><h3 id="V0-0-7"><a href="#V0-0-7" class="headerlink" title="V0.0.7"></a>V0.0.7</h3><ul>
<li>增加自动播放功能</li>
</ul>
<h3 id="V0-0-6"><a href="#V0-0-6" class="headerlink" title="V0.0.6"></a>V0.0.6</h3><ul>
<li>调整界面显示</li>
<li>增加”反微信”弹窗功能(就是答题的时候挡住了看不到题目)</li>
</ul>
<h3 id="V0-0-5"><a href="#V0-0-5" class="headerlink" title="V0.0.5"></a>V0.0.5</h3><ul>
<li>图片显示功能添加,base64编码显示图片(就直接放在最后面了,能用就行了)</li>
<li>界面调整</li>
<li>随机/顺序/倒序功能开放</li>
<li>添加说明页面(README.md还是没有)<a id="more"></a>

</li>
</ul>
<h3 id="V0-0-4"><a href="#V0-0-4" class="headerlink" title="V0.0.4"></a>V0.0.4</h3><ul>
<li>美化界面,使用AmazeUI</li>
</ul>
<h3 id="V0-0-3"><a href="#V0-0-3" class="headerlink" title="V0.0.3"></a>V0.0.3</h3><ul>
<li>细化时间统计</li>
<li>增加编码耗时记录</li>
<li>增加查看答案编码记录</li>
</ul>
<h3 id="V0-0-2"><a href="#V0-0-2" class="headerlink" title="V0.0.2"></a>V0.0.2</h3><ul>
<li>文件编码设置,解决乱码问题</li>
<li>增加总共用时统计</li>
<li>随机/顺序/倒序功能添加(已隐藏)</li>
</ul>
<h3 id="V0-0-1"><a href="#V0-0-1" class="headerlink" title="V0.0.1"></a>V0.0.1</h3><ul>
<li>基本可用</li>
<li>编码随机出题</li>
</ul>
]]></content>
      <categories>
        <category>remember</category>
      </categories>
      <tags>
        <tag>remember</tag>
        <tag>number</tag>
      </tags>
  </entry>
  <entry>
    <title>php安装zookeeper扩展</title>
    <url>/2018/04/03/php-zookeeper-install/</url>
    <content><![CDATA[<p>下面的<code>.so</code>是生成的,生成方法后面有些,这里就不上传附件了.</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol>
<li>将<code>zookeeper.so</code>复制到php扩展目录里面,如:<code>/usr/lib64/php/modules/zookeeper.so</code></li>
<li>在<code>/etc/php.ini</code>结尾追加内容:<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[zookeeper]</span></span><br><span class="line"><span class="attr">extension</span>=zookeeper.so</span><br></pre></td></tr></table></figure></li>
<li>重启php服务</li>
</ol>
<a id="more"></a>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><code>zookeeper.so</code>库是根据<code>zookeeper-3.4.10</code>和php扩展<code>zookeeper-0.4.0</code>编译生成</p>
<h2 id="追加自主编译流程说明"><a href="#追加自主编译流程说明" class="headerlink" title="追加自主编译流程说明"></a>追加自主编译流程说明</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编译zookeeper生成so文件</span></span><br><span class="line">tar -xzf zookeeper-3.4.9.tar.gz</span><br><span class="line">cd zookeeper-3.4.9/src/c</span><br><span class="line">./configure –prefix=/usr/local/zookeeper-lib/</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译php-zookeeper生成so文件</span></span><br><span class="line">tar xzf zookeeper-0.3.1.tgz</span><br><span class="line">cd zookeeper-0.3.1</span><br><span class="line">phpize</span><br><span class="line">./configure -with-php-config=/usr/local/php7/bin/php-config -with-libzookeeper-dir=/usr/local/zookeeper-lib/</span><br><span class="line">make </span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>pprof简述</title>
    <url>/2019/03/04/pprof-sketch/</url>
    <content><![CDATA[<p>pprof是google的测试c++代码性能的工具<br>(valgrind,callgrind同样可以分析)</p>
<h2 id="输出内容"><a href="#输出内容" class="headerlink" title="输出内容"></a>输出内容</h2><ul>
<li>函数cpu耗时百分比</li>
<li>函数调用次数</li>
</ul>
<h2 id="makefile需要添加库引用"><a href="#makefile需要添加库引用" class="headerlink" title="makefile需要添加库引用"></a>makefile需要添加库引用</h2><p><code>-lprofiler</code></p>
<h2 id="输出途径"><a href="#输出途径" class="headerlink" title="输出途径"></a>输出途径</h2><ul>
<li>全程序整体分析<ul>
<li><code>env LD_PRELOAD=&quot;/path/to/libprofiler.a&quot; CPUPROFILE=gmon.out ./执行程序名</code></li>
<li>注:要生成文件必须要程序正常退出才行,如果是信号触发的退出,必须在信号处理中加入<code>ProfilerStop()</code>函数的调用才能生成分析文件</li>
</ul>
</li>
<li>指定代码段分析<ul>
<li>开始处调用函数<code>ProfilerStart(&quot;gmon.out&quot;)</code></li>
<li>结束处调用函数<code>ProfilerStop()</code></li>
</ul>
</li>
</ul>
<h2 id="将输出结果转化为pdf可是图片"><a href="#将输出结果转化为pdf可是图片" class="headerlink" title="将输出结果转化为pdf可是图片"></a>将输出结果转化为pdf可是图片</h2><p><code>pprof --pdf ./运行程序名 gmon.out &gt; XXX.pdf</code><br>查看分析生成的pdf即可</p>
]]></content>
      <categories>
        <category>cpp</category>
        <category>profiler</category>
      </categories>
      <tags>
        <tag>profiler</tag>
        <tag>cpu</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis算法 HASH</title>
    <url>/2018/05/23/redis-algorithmic-hash/</url>
    <content><![CDATA[<p>注:主要内容整理来自<a href="https://blog.csdn.net/jasper_xulei/article/details/18364313">redis中几种哈希函数的研究</a><br>哈希就是离散算法<br>将一个键值转换成我们需要的数组索引下标的方法</p>
<a id="more"></a>

<h2 id="哈希函数的准则"><a href="#哈希函数的准则" class="headerlink" title="哈希函数的准则"></a>哈希函数的准则</h2><p>Thomas Wang认为的好的hash函数的特性</p>
<ul>
<li>一个好的哈希函数应该是可逆的。即，对于哈希函数输入值x和输出值y，如果存在f(x) = y，就一定存在g(y) = x。说白了，就是哈希函数可以将某一个值x转换成一个key，也可以把这个key还原回成x。</li>
<li>一个好的哈希函数应该容易造成雪崩效应。这里的雪崩效应是从比特位的角度出发的，它指的是，输入值1bit位的变化会造成输出值1/2的bit位发生变化。</li>
</ul>
<p>具有可逆性的哈希函数可以从根本上消除哈希过程中的冲突(collisions)。<br>但是因为存储空间有限,不可能完全没有冲突的存在,所以<code>哈希函数应只负责将输入值尽量均匀的分布在某一空间，而不管实际的物理内存是否可以容纳该空间。</code><br>将这一问题留给具体的使用者。对于内存不足的情况，一般的处理方法是对哈希结果进行二次映射，将这些值存入到一个固定大小的物理内存块中。具体映射的方法有很多，最简单的是取余运算，但是取余的方法方法过于耗时，可以通过一个小技巧避免。我们可以将放置哈希结果的物理内存块的大小设置成2的n次方的形式，此时, tablesize = 2 ^n，key_addr =hash_value % tablesize = hash_value &amp; (tablesize - 1)。这里用位运算来代替取余运算，在tablesize = 2 ^ n 的情况下，两者的效果相同。</p>
<p>雪崩效应的主要目的是使得哈希结果更为离散均匀。</p>
<h2 id="可逆性"><a href="#可逆性" class="headerlink" title="可逆性"></a>可逆性</h2><p>基本的可逆算法</p>
<ul>
<li><code>x + 常数 = y；</code></li>
<li><code>x - 常数 = y；</code></li>
<li><code>x ^ 常数 = y；</code></li>
<li><code>~x = y；</code></li>
<li><code>x * 常数 =y；</code><br>在上面的式子中，我们可以通过x得到y，也可以通过y得到x，这没什么问题。</li>
</ul>
<p>进阶的可逆问题</p>
<ul>
<li><code>( x + 常数 )  + ( x &lt;&lt; n ) = y；</code>是否可逆<br>比如(x +(101111)<del>2</del>) + (x &lt;&lt; 3) = (11101100)<del>2</del><br>可以转化为x + (x &lt;&lt; 3) = (11101100)<del>2</del>- (101111)<del>2</del>= (10111101)<del>2</del><img src="/2018/05/23/redis-algorithmic-hash/hash_1.png" class="" title="hash_1">
通过转换后的式子，我们可以画出这样一个表格，x + x&lt;&lt;3的最终结果为(10111101)2，而x&lt;&lt;3的最后三位为000，此时我们可以得到x的后三位为101，继而得到x&lt;&lt;3的后三位为相同101。如下图：<img src="/2018/05/23/redis-algorithmic-hash/hash_2.png" class="" title="hash_2">
此时，我们又可以得到x的第3、4、5位分别是0、1、0。依次类推，最终我们可以得到x=(10101)2，如下图：<img src="/2018/05/23/redis-algorithmic-hash/hash_3.png" class="" title="hash_3">
所以，我们可以得知，式子1是可逆的。特别的，即使在位移过程中出现溢出截断，也不会影响结果。</li>
<li><code>( x + 常数 )  + ( x &gt;&gt; n ) = y；</code>是否可逆<br>具体论证看引用的地址吧,不是很懂<br>大概就是可逆的</li>
</ul>
<h2 id="雪崩效应"><a href="#雪崩效应" class="headerlink" title="雪崩效应"></a>雪崩效应</h2><p>雪崩效应之前也讲过，说白了，就是输入数据1bit位的变化会导致输出数据N bit位的变化，这个N是大于等于1/2输出数据长度的。我们还是从简单的运算说起。</p>
<ul>
<li>加减运算<br>加减运算很容易引起雪崩响应，这很容易理解，例如(1111)<del>2</del>+ (1)<del>2</del> = (10000)<del>2</del>以及(1000)<del>2</del> - (1)<del>2</del> = (111)<del>2</del>这两个式子。</li>
<li>位移运算<br>取反运算也很容易产生雪崩效应，例如(00001111)<del>2</del> &lt;&lt; 2 = (00111100)<del>2</del>。</li>
<li>乘除运算<br>乘除运算的本质就是位移与加减法的组合，所以也是可以一起雪崩效应的。</li>
<li>取反、异或运算<br>取反和异或运算也很容易产生雪崩效应，如<del>(1111)</del>2~ =(0000)<del>2</del>以及(1101)<del>2</del>^ (1010)<del>2</del>=(0111)<del>2</del>。</li>
</ul>
<h2 id="Redis中的哈希算法的使用"><a href="#Redis中的哈希算法的使用" class="headerlink" title="Redis中的哈希算法的使用"></a>Redis中的哈希算法的使用</h2><h3 id="32-bit-MixFunction"><a href="#32-bit-MixFunction" class="headerlink" title="32 bit MixFunction"></a>32 bit MixFunction</h3><p>就是左移右移等基本操作的组合</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Thomas Wang&#x27;s 32 bit Mix Function */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dictIntHashFunction</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    key += ~(key &lt;&lt; <span class="number">15</span>);</span><br><span class="line">    key ^=  (key &gt;&gt; <span class="number">10</span>);</span><br><span class="line">    key +=  (key &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    key ^=  (key &gt;&gt; <span class="number">6</span>);</span><br><span class="line">    key += ~(key &lt;&lt; <span class="number">11</span>);</span><br><span class="line">    key ^=  (key &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MurmurHash2"><a href="#MurmurHash2" class="headerlink" title="MurmurHash2"></a>MurmurHash2</h3><p>有MurmurHash1,MurmurHash2,MurmurHash3<br>redis中用的是MurmurHash2</p>
<p>将字符串视作int32进行hash运算<br>也都是最基础的算法<br>代码中的<code>m</code>,<code>r</code>的值为什么是这几个数字,只能说用这几个数字计算的结果效果好</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* MurmurHash2, by Austin Appleby</span></span><br><span class="line"><span class="comment"> * Note - This code makes a few assumptions about how your machine behaves -</span></span><br><span class="line"><span class="comment"> * 1. We can read a 4-byte value from any address without crashing</span></span><br><span class="line"><span class="comment"> * 2. sizeof(int) == 4</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * And it has a few limitations -</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. It will not work incrementally.</span></span><br><span class="line"><span class="comment"> * 2. It will not produce the same results on little-endian and big-endian</span></span><br><span class="line"><span class="comment"> *    machines.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dictGenHashFunction</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* &#x27;m&#x27; and &#x27;r&#x27; are mixing constants generated offline.</span></span><br><span class="line"><span class="comment">     They&#x27;re not really &#x27;magic&#x27;, they just happen to work well.  */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> seed = dict_hash_function_seed;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> m = <span class="number">0x5bd1e995</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> r = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the hash to a &#x27;random&#x27; value */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> h = seed ^ len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Mix 4 bytes at a time into the hash */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *data = (<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *)key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(len &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> k = *(<span class="keyword">uint32_t</span>*)data;</span><br><span class="line"></span><br><span class="line">        k *= m;</span><br><span class="line">        k ^= k &gt;&gt; r;</span><br><span class="line">        k *= m;</span><br><span class="line"></span><br><span class="line">        h *= m;</span><br><span class="line">        h ^= k;</span><br><span class="line"></span><br><span class="line">        data += <span class="number">4</span>;</span><br><span class="line">        len -= <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle the last few bytes of the input array  */</span></span><br><span class="line">    <span class="keyword">switch</span>(len) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: h ^= data[<span class="number">2</span>] &lt;&lt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: h ^= data[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: h ^= data[<span class="number">0</span>]; h *= m;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do a few final mixes of the hash to ensure the last few</span></span><br><span class="line"><span class="comment">     * bytes are well-incorporated. */</span></span><br><span class="line">    h ^= h &gt;&gt; <span class="number">13</span>;</span><br><span class="line">    h *= m;</span><br><span class="line">    h ^= h &gt;&gt; <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="djb-hash"><a href="#djb-hash" class="headerlink" title="djb hash"></a>djb hash</h3><p>不区分大小写的字符串hash算法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* And a case insensitive hash function (based on djb hash) */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dictGenCaseHashFunction</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)dict_hash_function_seed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (len--)</span><br><span class="line">        hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + (<span class="built_in">tolower</span>(*buf++)); <span class="comment">/* hash * 33 + c */</span></span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>algorithmic</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis算法 引用计数</title>
    <url>/2018/05/21/redis-algorithmic-referencecount/</url>
    <content><![CDATA[<p>Redis的内存回收算法采用<br>引用计数算法<br>通过增减对象的引用计数来判断<br>是否需要回收对象的内存</p>
<ul>
<li>优点<ul>
<li>代码逻辑清晰</li>
<li>不会有集中清理数据时造成的假死现象</li>
</ul>
</li>
<li>缺点<ul>
<li>无法解决循环引用问题(无视弱指针吧)</li>
<li>增加/减少引用数时的函数要对称,不能漏掉(c里面没有构造析构函数)</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></span><br><span class="line">    <span class="keyword">int</span> refcount; <span class="comment">// 引用计数器</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="comment">// 引用数为1</span></span><br><span class="line"><span class="function">robj *<span class="title">createObject</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(*o));</span><br><span class="line">    o-&gt;type = type;</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_RAW;</span><br><span class="line">    o-&gt;ptr = ptr;</span><br><span class="line">    o-&gt;refcount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the LRU to the current lruclock (minutes resolution). */</span></span><br><span class="line">    o-&gt;lru = LRU_CLOCK();</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加引用数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrRefCount</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    o-&gt;refcount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减少引用数</span></span><br><span class="line"><span class="comment">// 当引用数为0时,释放内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCount</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount &lt;= <span class="number">0</span>) serverPanic(<span class="string">&quot;decrRefCount against refcount &lt;= 0&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(o-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> OBJ_STRING: freeStringObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_LIST: freeListObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_SET: freeSetObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_ZSET: freeZsetObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_HASH: freeHashObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: serverPanic(<span class="string">&quot;Unknown object type&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        zfree(o);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        o-&gt;refcount--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>algorithmic</tag>
      </tags>
  </entry>
  <entry>
    <title>1. 初识redis</title>
    <url>/2018/03/27/redis-basic-1/</url>
    <content><![CDATA[<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol>
<li>速度快<ul>
<li>数据在内存中</li>
<li>C语言实现的</li>
<li>单线程架构,预防了多线程可能产生的资源竞争问题</li>
<li>代码细节</li>
</ul>
</li>
<li>基于键值对的数据结构服务器(Remote Dictionary Server)</li>
<li>丰富的功能<ul>
<li>键过期</li>
<li>发布订阅</li>
<li>lua脚本</li>
<li>简单事物</li>
<li>pipeline(将命令一次性传到redis)</li>
</ul>
</li>
<li>简单稳定</li>
<li>客户端语言多</li>
<li>持久化</li>
<li>主从复制(复制功能是分布式Redis的基础)</li>
<li>高可用和分布式<ul>
<li><code>Redis Sentinel</code>可以保证能够<code>Redis</code>节点的故障发现和故障自动转移</li>
<li><code>Redis Cluster</code>是<code>Redis</code>真正的分布式实现,提供了高可用,读写和容量的扩展性</li>
</ul>
</li>
</ol>
<a id="more"></a>

<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="适合"><a href="#适合" class="headerlink" title="适合"></a>适合</h3><ol>
<li>缓存<br>合理的使用缓存可以加快数据的访问速度,有效降低后端数据源的压力.<br><code>Redis</code>提供了键值过期时间设置,也提供了最大内存和内存溢出后的淘汰策略.</li>
<li>排行榜系统<br><code>Redis</code>提供了列表和有序集合数据结构,合理的使用可以很方便的构建各种排行榜系统.</li>
<li>计数器应用<br><code>Redis</code>天然支持计数功能而且计数性能也很好.</li>
<li>社交网络<br><code>Redis</code>的数据结构比传统关系型数据库更适合社交网络.</li>
<li>消息队列系统<br><code>Redis</code>提供了发布订阅功能和阻塞队列功能.</li>
</ol>
<h3 id="不适合"><a href="#不适合" class="headerlink" title="不适合"></a>不适合</h3><ol>
<li>从数据规模上看<br>如果数据量非常大,使用<code>Redis</code>来存储,基本是个无底洞</li>
<li>从数据冷热角度看<br>冷数据放在<code>Redis</code>中存储是对内存的一种浪费</li>
</ol>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ol>
<li>切勿当作黑盒使用,开发与运维同样重要,如:<ul>
<li>在有千万个键的<code>Redis</code>上执行<code>keys*</code>操作</li>
<li>在一个写操作量很大的<code>Redis</code>上配置自动保存<code>RDB</code></li>
</ul>
</li>
<li>阅读源码<br>加深对<code>Redis</code>的理解,提高自身的编码水平,对<code>Redis</code>做定制化.</li>
</ol>
<h2 id="程序文件说明"><a href="#程序文件说明" class="headerlink" title="程序文件说明"></a>程序文件说明</h2><p>可执行文件 | 作用<br>-|<br>redis-server | 启动<code>Redis</code><br>redis-cli | Redis命令行客户端<br>redis-benchmark | Redis基准测试工具<br>redis-check-aof | Redis AOF持久化文件检测和修复工具<br>redis-check-dump | Redis RDB持久化文件检测和修复工具<br>redis-sentinel | 启动Redis Sentinel</p>
<h3 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h3><h4 id="服务器启动"><a href="#服务器启动" class="headerlink" title="服务器启动"></a>服务器启动</h4><ol>
<li>直接启动<code>redis-server</code></li>
<li>命令行参数启动<code>redis-server --configKey1 configValue1 --configKey2 configValue2</code></li>
<li>配置文件启动<code>redis-server /opt/redis/redis.conf</code></li>
</ol>
<h4 id="客户端启动"><a href="#客户端启动" class="headerlink" title="客户端启动"></a>客户端启动</h4><ol>
<li>命令行参数连接<code>redis-cli -h 127.0.0.1 -p 6379</code></li>
<li>命令行参数直接查询<code>redis-cli  -h 127.0.0.1 -p 6379 get hello</code></li>
</ol>
<h4 id="停止Redis服务"><a href="#停止Redis服务" class="headerlink" title="停止Redis服务"></a>停止<code>Redis</code>服务</h4><ol>
<li><code>redis-server shutdown nosave|save</code></li>
<li><code>kill $pid</code></li>
</ol>
<p>断开与客户端的连接,持久化文件生成</p>
]]></content>
      <categories>
        <category>redis</category>
        <category>development &amp; operation</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>2. Redis API的理解和使用</title>
    <url>/2018/04/04/redis-basic-2/</url>
    <content><![CDATA[<h2 id="全局命令"><a href="#全局命令" class="headerlink" title="全局命令"></a>全局命令</h2><ol>
<li>查看所有的键,o(n),线上应禁止使用<br><code>keys *</code></li>
<li>查看键总数,o(1)<br><code>dbsize</code></li>
<li>检查键是否存在<br><code>exists $key</code></li>
<li>删除键<br><code>del $key...</code></li>
<li>键过期,设置键的过期秒数,<code>RedisLV</code>不支持<br><code>expire $key $seconds</code><br>查询<code>key</code>的剩余有效时间,<br><code>ttl $key</code><ul>
<li><code>&gt;0</code>,剩余有效时间秒</li>
<li><code>-1</code>,无过期时间</li>
<li><code>-2</code>,键不存在</li>
</ul>
</li>
<li>键的数据结构类型<br><code>type $key</code></li>
</ol>
<a id="more"></a>

<h2 id="数据结构和内部编码"><a href="#数据结构和内部编码" class="headerlink" title="数据结构和内部编码"></a>数据结构和内部编码</h2><p>每种数据结构都有自己的底层内部编码实现,而且是多种实现<br><code>object encoding $key</code>命令可以查询内部编码</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li>字符串</li>
<li>哈希</li>
<li>列表</li>
<li>集合</li>
<li>有序集合</li>
</ul>
<img src="/2018/04/04/redis-basic-2/basic_type.jpg" class="" title="basic type">

<h3 id="内部编码"><a href="#内部编码" class="headerlink" title="内部编码"></a>内部编码</h3><img src="/2018/04/04/redis-basic-2/basic_type_encoding.jpg" class="" title="basic type encoding">

<p>优点:</p>
<ul>
<li>无需改动外部数据结构和命令,即可将代码替换成更合适的数据结构</li>
<li>不同的结构在不同情况下有不同的优势</li>
</ul>
<h2 id="单线程架构"><a href="#单线程架构" class="headerlink" title="单线程架构"></a>单线程架构</h2><p><code>Redis</code>使用了单线程架构和<code>I/O</code>多路复用模型来实现高性能的内存数据库服务.</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol>
<li>客户端发送命令</li>
<li><code>Redis</code>执行命令</li>
<li>返回结果</li>
</ol>
<p>因为是单线程,所有命令在一个队列里等待执行,不存在多个命令同时执行的情况</p>
<h3 id="快的原因"><a href="#快的原因" class="headerlink" title="快的原因"></a>快的原因</h3><ol>
<li>纯内存访问</li>
<li>非阻塞I/O(内部使用epoll)</li>
<li>避免了线程切换和竞争(单线程的阻塞问题需要注意)</li>
</ol>
]]></content>
      <categories>
        <category>redis</category>
        <category>development &amp; operation</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>3. Redis API的理解和使用-字符串</title>
    <url>/2018/04/04/redis-basic-3/</url>
    <content><![CDATA[<p>字符串是<code>Redis</code>最基础的数据结构<br>支持二进制数据<br>最大值不能超过512MB</p>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p><code>set $key $value [ex $seconds][px milliseconds][nx|xx]</code></p>
<p>ex:过期的秒数<br>px:过期的毫秒数<br>nx:$key不存在才能设置<br>xx:$key存在才能设置</p>
<p><code>setex</code>,<code>setnx</code>就是简化了<code>set</code>的使用方法</p>
<p><code>setnx</code>可以做分布式锁</p>
<a id="more"></a>

<h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><p><code>get $key</code></p>
<p>如果<code>$key</code>不存在,则返回<code>nil</code></p>
<h3 id="批量设置值"><a href="#批量设置值" class="headerlink" title="批量设置值"></a>批量设置值</h3><p><code>mset $key $value [$key $value ...]</code></p>
<h3 id="批量获取值"><a href="#批量获取值" class="headerlink" title="批量获取值"></a>批量获取值</h3><p><code>mget $key [$key ...]</code></p>
<p>不存在就返回<code>nil</code>,顺序和<code>$key</code>的顺序一致<br><code>mget</code>可以减少通信次数,提高效率</p>
<p><strong>单次命令发送的字节数也不是无限的,数量过多可能造成Redis或者网络阻塞</strong></p>
<h3 id="记数"><a href="#记数" class="headerlink" title="记数"></a>记数</h3><ul>
<li><code>incr $key</code>(自增)<ul>
<li>值存在<ul>
<li>整数:返回自增后的结果</li>
<li>非整数:返回错误</li>
</ul>
</li>
<li>不存在,按0处理,返回结果为1</li>
</ul>
</li>
<li><code>decr $key</code>(自减)</li>
<li><code>incrby $key $increment</code>(自增指定数值)</li>
<li><code>decrby $key $decrement</code>(自减指定数值)</li>
<li><code>incrbyfloat $key $increment</code>(自增指定浮点数)</li>
</ul>
<h2 id="不常用命令"><a href="#不常用命令" class="headerlink" title="不常用命令"></a>不常用命令</h2><h3 id="追加值"><a href="#追加值" class="headerlink" title="追加值"></a>追加值</h3><p><code>append $key $value</code><br>在字符串结尾追加字符串</p>
<h3 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h3><p><code>strlen $key</code></p>
<h3 id="获取原始值并设置新值"><a href="#获取原始值并设置新值" class="headerlink" title="获取原始值并设置新值"></a>获取原始值并设置新值</h3><p><code>getset $key $value</code></p>
<h3 id="从指定位置开始设置字符串"><a href="#从指定位置开始设置字符串" class="headerlink" title="从指定位置开始设置字符串"></a>从指定位置开始设置字符串</h3><p><code>setrange $key $offset $value</code><br>是覆盖/替换操作,可以增加字符串的长度</p>
<h3 id="获取指定位置区间的字符串"><a href="#获取指定位置区间的字符串" class="headerlink" title="获取指定位置区间的字符串"></a>获取指定位置区间的字符串</h3><p><code>getrange $key $start $end</code><br>从0开始,闭区间,包含两个端点</p>
<h2 id="内部编码"><a href="#内部编码" class="headerlink" title="内部编码"></a>内部编码</h2><ul>
<li>int:8字节的长整型</li>
<li>embstr:&lt;=39字节的字符串(实测没有找到这个数据结构的使用)</li>
<li>raw:&gt;39字节的字符串</li>
</ul>
<p>Redis会根据当前值的类型和长度决定使用那种内部编码实现</p>
<p>查看<code>$key</code>的内部编码命令:<br><code>object encoding $key</code></p>
<h2 id="典型使用场景"><a href="#典型使用场景" class="headerlink" title="典型使用场景"></a>典型使用场景</h2><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>应用程序+Redis+Mysql</p>
<img src="/2018/04/04/redis-basic-3/cache.jpg" class="" title="cache">

<p>Redis没有命令空间,推荐使用的命名方式是:<br><code>业务名:对象名:id:属性</code>作为键(也可以不是<code>:</code>)<br>可以在意义明确的情况下缩写键名减少因为键过长导致的内存浪费</p>
<h3 id="记数-1"><a href="#记数-1" class="headerlink" title="记数"></a>记数</h3><h3 id="共享Session"><a href="#共享Session" class="headerlink" title="共享Session"></a>共享Session</h3><h3 id="限制指定时间指定次数"><a href="#限制指定时间指定次数" class="headerlink" title="限制指定时间指定次数"></a>限制指定时间指定次数</h3><p>通过<code>$key</code>的时效性和自增功能可以实现</p>
]]></content>
      <categories>
        <category>redis</category>
        <category>development &amp; operation</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>4. Redis API的理解和使用-哈希</title>
    <url>/2018/04/08/redis-basic-4/</url>
    <content><![CDATA[<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ul>
<li>设置值<br>  <code>hset $key $field $value</code><br>  <code>hsetnx</code>:当不存在<code>$field</code>时设置</li>
<li>获取值<br>  <code>hget $key $field</code></li>
<li>删除<code>$field</code><br>  <code>hdel $key $field [$field ...]</code></li>
<li>计算<code>$field</code>个数<br>  <code>hlen $key</code></li>
<li>批量设置<br>  <code>hmset $key $field $value [$field $value ...]</code></li>
<li>批量获取<br>  <code>hmget $key $field [$field ...]</code></li>
<li>判断<code>$field</code>是否存在<br>  <code>hexists $key $field</code></li>
<li>获取所有<code>$field</code><br>  <code>hkeys $key</code></li>
<li>获取所有<code>$value</code><br>  <code>hvals $key</code></li>
<li>获取所有的<code>$field-$value</code><br>  <code>hgetall $key</code><br>  当哈希元素个数比较多的时候,该命令可能会阻塞<code>Redis</code>,只需要部分数据的话推荐使用<code>hmget</code>,一定要获得全部的话,也可以使用<code>hscan   </code>来遍历</li>
<li>递增计数<br>  <code>hincrby $key $field</code><br>  <code>hincrbyfloat $key $field</code></li>
<li>计算<code>$value</code>的长度(Redis3.2以上)<br>  <code>hstrlen $key $field</code></li>
</ul>
<a id="more"></a>
<h2 id="内部编码"><a href="#内部编码" class="headerlink" title="内部编码"></a>内部编码</h2><p>两种内部编码</p>
<ol>
<li>ziplist(压缩列表)<br> 当元素个数小于<code>hash-max-ziplist-entries</code>(默认512个)同时所有值小于<code>hash-max-ziplist-value</code>(默认64字节)时会使用.ziplist比hashtable更紧凑,节省内存</li>
<li>hashtable(哈希表)<br> 当不满足ziplist条件时,就是使用哈希表存储.因为这时ziplist的读写效率会下降,而哈希表读写时间复杂度为O(1)</li>
</ol>
<h2 id="与关系型数据库对比"><a href="#与关系型数据库对比" class="headerlink" title="与关系型数据库对比"></a>与关系型数据库对比</h2><ul>
<li>哈希表类型更加直观</li>
<li>哈希表是稀疏的,单条数据增加一个<code>$key</code>不影响其他数据的字段,而关系行数据库增加列需要给所有数据都增加一个属性值</li>
<li>关系型数据库可以做复杂关系查询,而使用<code>Redis</code>去模拟复杂查询开发困难,维护成本高</li>
</ul>
<img src="/2018/04/08/redis-basic-4/db_compare.jpg" class="" title="db compare">

<h2 id="几种数据存储方法"><a href="#几种数据存储方法" class="headerlink" title="几种数据存储方法"></a>几种数据存储方法</h2><ol>
<li>原生字符串:每个属性一个键<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set user:1:name a</span><br><span class="line">set user:1:age 1</span><br><span class="line">set user:1:city b</span><br></pre></td></tr></table></figure>
<ul>
<li>优点:简单直观,所有属性都支持更新操作</li>
<li>缺点:键过多,内存占用大,用户信息内聚性差</li>
</ul>
</li>
<li>系列化字符串类型:将用户信息系列化为一个键后保存<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set user:1 serialize(userInfo)</span><br></pre></td></tr></table></figure>
<ul>
<li>优点:简化变成,如果合理使用序列化可以提高内存使用效率</li>
<li>缺点:序列化和反序列化有一定开销,每次更新属性都需要把全部数据取出后更新,反序列化</li>
</ul>
</li>
<li>哈希类型:用户属性存储为<code>$field-$value</code>,但只用一个键保存<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hmset user:1 name a age 1 city b</span><br></pre></td></tr></table></figure>
<ul>
<li>优点:简单直观,如果使用合理可以减少内存空间的使用</li>
<li>缺点:要控制哈希在ziplist和hashtable两种内部编码的转换,hashtable会消耗更多的内存</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>redis</category>
        <category>development &amp; operation</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>5. Redis API的理解和使用-列表</title>
    <url>/2018/04/08/redis-basic-5/</url>
    <content><![CDATA[<p>列表(list)是用来存储多个有序的字符串,<br>列表中的每个字符串成为元素(element),<br>一个列表最多可以存储2^32-1个元素.<br>它可以充当栈和队列<br>(可以理解为有长度限制的链表)</p>
<img src="/2018/04/08/redis-basic-5/list_basic_operation_0.jpg" class="" title="list basic operation 0">
<img src="/2018/04/08/redis-basic-5/list_basic_operation_1.jpg" class="" title="list basic operation 1">

<a id="more"></a>

<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>有序<br> 可以通过索引下标来获取元素和这范围内的元素列表</li>
<li>可以重复</li>
</ol>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><img src="/2018/04/08/redis-basic-5/list_oper_command.jpg" class="" title="command">

<ul>
<li>获得<br>  <code>lrange $begin $end</code>,$begin,$end:从左至右[0,(N-1)],从右直左[-1, -N],包含两端元素<br>  <code>lindex $key $index</code>,获取指定位置的元素<br>  <code>llen $key</code>,获得列表长度</li>
<li>添加<br>  <code>rpush $key $value [$value ...]</code><br>  <code>lpush $key $value [$value ...]</code></li>
<li>插入<br>  <code>linsert $key before|after $pivot $value</code> 找到等于<code>$pivot</code>的元素,在其前|后插入一个新元素<code>$value</code></li>
<li>删除<br>  <code>lpop $key</code>,删除左侧第一个元素<br>  <code>rpop $key</code>,删除右侧第一个元素<br>  <code>lrem $key $count $value</code>,删除指定元素<pre><code>  - `$count &gt; 0`,从左到右删除`$count`个元素
  - `$count &lt; 0`,从右到左删除`-$count`个元素
  - `$count = 0`,删除所有</code></pre>
  <code>ltrim $key $start $end</code>,截断表</li>
<li>修改<br>  <code>lset $key $index $value</code>,设置列表第<code>$index</code>元素的值</li>
<li>阻塞操作<br>  <code>blpop|brpop $key [$key ...] $timeout</code>,是<code>lpop</code>和<code>rpop</code>的阻塞版本<pre><code>  - 其中`$key [$key ...]`为多个列表,如果有多个列表,则按照顺序从左到右遍历,返回最先有数据的列表和对应的数据
  - `$timeout`为超时时间(秒),如果为0则一直阻塞等待下去.(不会阻塞`Redis`进程)
  - 当有多个block操作等待时,按照时间顺序返回给每一个block操作的结果</code></pre>
</li>
</ul>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>有两种编码实现</p>
<ol>
<li>ziplist(压缩列表)<br> 当元素个数小于<code>list-max-ziplist-entries</code>(默认512个),同时每个元素值都小于<code>list-max-ziplist-value</code>(默认64字节)时,会使用ziplist来减少内存的使用</li>
<li>linkedlist(链表)<br> 当不满足ziplist条件时,使用链表作为内部实现</li>
</ol>
<p>注:<br>Redis3.2提供了额外的<code>quicklist</code>内部编码,简单的说它是一个以ziplist为节点的linkedlist,<br>结合了两者的优势. </p>
<h2 id="常用组合"><a href="#常用组合" class="headerlink" title="常用组合"></a>常用组合</h2><ul>
<li><code>lpush</code>+<code>lpop</code>,栈</li>
<li><code>lpush</code>+<code>rpop</code>,队列</li>
<li><code>lpush</code>+<code>ltrim</code>,有限集合</li>
<li><code>lpush</code>+<code>brpop</code>,消息队列,生产者消费者模式</li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
        <category>development &amp; operation</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>6. Redis API的理解和使用-集合</title>
    <url>/2018/04/08/redis-basic-6/</url>
    <content><![CDATA[<p>集合(set)<br>无序不重复的元素的集合,<br>元素数量上限:2^32-1,<br>支持多个集合取:交集/并集/差集.</p>
<a id="more"></a>

<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="单个集合"><a href="#单个集合" class="headerlink" title="单个集合"></a>单个集合</h3><ul>
<li>添加<br>  <code>sadd $key $element [$element ...]</code>,返回添加成功的元素个数</li>
<li>删除<br>  <code>srem $key $element [$element ...]</code>,返回删除成功的元素个数</li>
<li>获取元素个数<br>  <code>scard $key</code>,时间复杂度为O(1),不会遍历</li>
<li>判断元素是否在集合中<br>  <code>sismember $key $element</code></li>
<li>随机从集合返回指定个数的元素<br>  <code>srandmember $key [$count]</code>,默认为1</li>
<li>随机从集合弹出元素<br>  <code>spop $key</code>,Redis3.2后,支持<code>$count</code>参数</li>
<li>获取所有元素<br>  <code>smembers $key</code></li>
</ul>
<p><strong><code>smembers</code>,<code>lrange</code>和<code>hgetall</code>都属于比较重的命令,如果元素过多,可能阻塞Redis,这是用可以使用<code>sscan</code>来完成</strong></p>
<h3 id="多个集合"><a href="#多个集合" class="headerlink" title="多个集合"></a>多个集合</h3><ul>
<li>交集<br>  <code>sinter $key [$key ...]</code></li>
<li>并集<br>  <code>sunion $key [$key ...]</code></li>
<li>差集(第一个集合元素剔除后面所有集合的元素后剩下的元素组成的集合)<br>  <code>sdiff $key [$key ...]</code></li>
<li>将上述集合操作结果保存(命令+store)<br>  <code>sinterstore $destination $key [$key ...]</code><br>  <code>sunionstore $destination $key [$key ...]</code><br>  <code>sdiffstore $destination $key [$key ...]</code></li>
</ul>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>有两种</p>
<ol>
<li>intset<br> 元素都是整数且个数小于<code>set-max-intset-entries</code>(默认512个)时会使用intset减少内存的使用</li>
<li>hashtable<br> 无法满足intset条件时,使用hashtable</li>
</ol>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>标签(tag)(sadd)</li>
<li>随机抽奖(spop|srandmember)</li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
        <category>development &amp; operation</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>7. Redis API的理解和使用-有序集合</title>
    <url>/2018/04/08/redis-basic-7/</url>
    <content><![CDATA[<p>有序的集合,<br>像集合一样元素不能重复,<br>增加了一个分数(可以重复)用于排序</p>
<img src="/2018/04/08/redis-basic-7/collections_diff.jpg" class="" title="collections different">

<a id="more"></a>

<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="单集合操作"><a href="#单集合操作" class="headerlink" title="单集合操作"></a>单集合操作</h3><ul>
<li>添加<br>  <code>zadd $key $score $member [$score $member ...]</code>,返回成功添加的个数<br>  <code>zadd</code>时间复杂度为O(log(n)),<code>sadd</code>时间复杂度为O(1),有序是有代价的</li>
<li>计算成员个数<br>  <code>zcard $key</code></li>
<li>获取成员分数<br>  <code>zscore $key $member</code></li>
<li>获取成员排名<br>  <code>zrank $key $member</code><br>  <code>zrevrank $key $member</code>,倒序</li>
<li>删除成员<br>  <code>zrem $key $member [$member ...]</code>,返回成功删除的个数</li>
<li>增加成员分数<br>  <code>zincrby $key $increment $member</code>,返回当前该元素的分数</li>
<li>获取指定排名范围的成员<br>  <code>zrange $key $start $end [withscores]</code>,<code>$start</code><br>  <code>zrevrange $key $start $end [withscores]</code>,倒序</li>
<li>获取指定分数范围的成员(后面的参数不会用)(分数范围支持<code>(</code>开区间,只要在数字前加上对应的符号即可(默认是闭区间))<br>  <code>zrangebyscore $key $min $max [withscores] [$limit $offset $count]</code><br>  <code>zrevrangebyscore $key $min $max [withscores] [$limit $offset $count]</code></li>
<li>获取指定分数范围内的元素个数<br>  <code>zcount $key $min $max</code></li>
<li>删除指定排名内的元素<br>  <code>zremrangebyrank $key $start $end</code></li>
<li>删除指定分数范围内的成员<br>  <code>zremrangebyscore $key $min $max</code></li>
</ul>
<h3 id="多集合操作"><a href="#多集合操作" class="headerlink" title="多集合操作"></a>多集合操作</h3><ul>
<li>交集<br>  <code>zinterstore $destination $numberkeys $key [$key ...] [$weight ...] [aggregate sum|min|max]</code><ul>
<li><code>$destination</code>结果存储位置</li>
<li><code>$numberkeys</code>进行交集的<code>$key</code>的数量</li>
<li><code>$key</code>键</li>
<li><code>$weight</code>每个键的权重,计算时,会将每个<code>$key</code>的分数乘以自己的权重进行比较,默认为1</li>
<li><code>[aggregate sum|min|max]</code>计算后,分值的汇总方式,默认是<code>sum</code></li>
</ul>
</li>
<li>并集<br>  <code>zunionstore $destination $numkeys $key [$key ...] [weight ...] [aggregate sum|min|max]</code></li>
</ul>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>两种</p>
<ol>
<li>ziplist(压缩列表)<br> 当有序集合元素个数小于<code>zset-max-ziplist-entries</code>(默认128个),同时每个元素值都小于<code>zset-max-ziplist-value</code>(默认64字节)时会使用ziplist,减少内存的使用</li>
<li>skiplist(跳跃表)<br> 当不满足条件时,采用skiplist,因为此时ziplist读写效率会下降</li>
</ol>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>排行榜点赞次数</p>
<ul>
<li>添加用户赞数:<code>zadd</code></li>
<li>取消用户赞数:<code>zrem</code></li>
<li>展示赞数前1名:<code>zrevrangebyrank $key 0 9</code></li>
<li>展示用户信息及分数:<code>hgetall</code>,<code>zscore</code>,<code>zrank</code></li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
        <category>development &amp; operation</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>8. Redis API的理解和使用-键管理</title>
    <url>/2018/04/09/redis-basic-8/</url>
    <content><![CDATA[<h2 id="单个键"><a href="#单个键" class="headerlink" title="单个键"></a>单个键</h2><ul>
<li>键重命名<br>  <code>rename $key $newkey</code>,会覆盖已有键值<br>  <code>renamenx $key $newkey</code>,不会覆盖已有键值<br>  <strong>重命名时会使用<code>del</code>删除旧的键,如果值比较大,可能会阻塞Redis</strong></li>
<li>随机返回一个键<br>  <code>randomkey</code>,从已有的key中随机一个key返回</li>
<li>键过期<ul>
<li><code>expire $key $seconds</code>,键在<code>$seconds</code>秒后过期</li>
<li><code>expireat $key $timestamp</code>,键在秒级时间戳后过期</li>
<li><code>ttl $key</code>,查看过期时间(秒),<code>-1</code>无限时间,<code>-2</code>键不存在</li>
<li><code>pexpire $key $milliseconds</code>,键在<code>$seconds</code>毫秒后过期</li>
<li><code>pexpireat $key $milliseconds-timestamp</code>,键在毫秒级时间戳后过期</li>
<li><code>pttl $key</code>,查看过期时间(毫秒)</li>
<li><code>persist $key</code>,清除键的过期时间</li>
</ul>
  <strong>对于字符串类型的键,执行<code>set</code>命令时,很容易会覆盖掉过期时间</strong><a id="more"></a></li>
<li>迁移键<br>  将部分数据从一个数据库移动到另一个数据库<ul>
<li><code>move $key $db</code>(自评:不好用)<br>  内部使用,Redis内部有多个数据库,该命令会将数据从一个数据库移动到另一个数据库中(不建议使用)</li>
<li><code>dump</code>+<code>restore</code>(自评:不好用)<br>  <code>dump $key</code>会将对应键的数据转为RDB格式<br>  <code>restore $key $ttl $serialized-value</code>会将RDB数据设置到<code>$key</code>中<br>  伪代码:  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = redis.Redis(host=<span class="string">&quot;src&quot;</span>, port=<span class="number">9898</span>, db=<span class="number">0</span>)</span><br><span class="line">t = redis.Redis(host=<span class="string">&quot;tar&quot;</span>, port=<span class="number">9898</span>, db=<span class="number">0</span>)</span><br><span class="line">k = <span class="string">&quot;hello&quot;</span></span><br><span class="line">t.restore(k, <span class="number">0</span>, s.dump(k))</span><br></pre></td></tr></table></figure></li>
<li><code>migrate</code>  <img src="/2018/04/09/redis-basic-8/migrate.jpg" class="" title="migrate">
  <code>migrate $host $port $key|&quot;&quot; $destination-db $timeout [copy] [replace] [keys key ...]</code><ul>
<li><code>$host</code>:目标Redis的IP地址</li>
<li><code>$port</code>:目标Redis的端口</li>
<li><code>$key|&quot;&quot;</code>:Redis3.0.6之前只支持一个<code>$key</code>,后面支持多个<code>$key</code>.当使用多个<code>$key</code>时,这里添空字符串</li>
<li><code>$destination-db</code>:目标Redis的数据库索引</li>
<li><code>$timeout</code>:前移超时时间(毫秒)</li>
<li><code>[copy]</code>:迁移后不删除源数据</li>
<li><code>[replace]</code>:覆盖目标数据库数据</li>
<li><code>[key ...]</code>:迁移多个键的键名</li>
<li>例:<ul>
<li><code>migrate 127.0.0.1 6666 hello 0 1000 copy replace</code></li>
<li><code>migrate 127.0.0.1 6666 &quot;&quot; 0 5000 keys hello1 hello2 hello3</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="遍历键"><a href="#遍历键" class="headerlink" title="遍历键"></a>遍历键</h2><ol>
<li>全量遍历键<br> <code>keys $pattern</code><br> 根据后面的正则表达式来查找显示所有符合条件的键<br> 因为是单线程阻塞操作,所以当键值较多的时候,要注意该命令的使用.</li>
<li>渐进式遍历<br> <code>scan $cursor [match $pattern] [count $number]</code><ul>
<li><code>$cursor</code>:游标指针,初始是0,后面是每次返回的结果,当游标指针再次为0时,遍历结束</li>
<li><code>match $pattern</code>:只返回满足正则匹配条件的值</li>
<li><code>count $number</code>:每次运行命令处理的键的数量,默认是10</li>
<li>例:<code>scan 0 match user* count 13</code><br>其他数据结构对应的遍历命令:</li>
<li><code>hgetall</code>-&gt;<code>hscan</code></li>
<li><code>smembers</code>-&gt;<code>sscan</code></li>
<li><code>zrange</code>-&gt;<code>zscan</code></li>
</ul>
 <strong>渐进式遍历可以有效解决<code>keys</code>命令可能产生的阻塞问题,但是如果在<code>scan</code>中键发生变化(增加/删除/修改),那么就可能出现新增键可能没有遍历到,或者遍历出重复键的情况.<code>scan</code>不保证完整遍历出所有的键.</strong></li>
</ol>
<h2 id="数据库管理"><a href="#数据库管理" class="headerlink" title="数据库管理"></a>数据库管理</h2><p>Redis提供了几个面向数据库操作的命令</p>
<ul>
<li>切换数据库<br>  Redis默认有16个数据库(0-15)<br>  默认使用<code>0</code>数据库<br>  切换当前使用的数据库使用命令:<br>  <code>select $dbIndex</code><br>  Redis3.0中已经逐渐弱化这个功能,Redis分布式实现Redis Cluster只允许使用0号数据库.<br>  不使用多个数据库的原因:<pre><code>  - Redis是单线程的,使用多个数据库,仍然是一个CPU管理,影响效率
  - 多数据库会让调试和运维不同业务的数据库更困难,一个慢查询会影响所有的数据库,定位问题也很困难
  - 部分Redis客户端不支持,按照数字切换数据库容易混乱</code></pre>
</li>
<li>清除数据库数据<br>  <code>flushdb</code>:清空当前数据库数据<br>  <code>flushall</code>:清空所有数据库数据<br>  当当前数据库键值数据比较多的时候,这两个命令可能会引起阻塞</li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
        <category>development &amp; operation</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>9. Redis API的理解和使用-总结</title>
    <url>/2018/04/09/redis-basic-9/</url>
    <content><![CDATA[<ul>
<li>Redis提供了<code>string</code>,<code>hash</code>,<code>list</code>,<code>set</code>,<code>zset</code>5中基本数据结构,没有数据结构都有多种内部编码实现</li>
<li>高性能原因:纯内存存储,IO多路复用技术,单线程架构</li>
<li>因为是单线程架构,所以必须要保证所有命令都能快速执行完成,如果命令长时阻塞线程,可能会导致业务运行问题</li>
<li>批量操作,Redis提供了批量操作的命令,可以通过有效减少网络通信次数来提高效率</li>
<li>命令的时间复杂度要注意,使用长时命令要注意影响</li>
<li><code>persist</code>/<code>set</code>命令都会删除键的过期时间</li>
<li>键前移基本使用的命令是<code>migrate</code>,有原子性,是Redis服务器端之间的通信</li>
<li><code>scan</code>命令可以替代<code>keys</code>等命令,采用循环遍历的方式来防止大数据造成的阻塞</li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
        <category>development &amp; operation</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>1. Redis 客户端-客户端通信协议</title>
    <url>/2018/04/24/redis-client-1/</url>
    <content><![CDATA[<ul>
<li>使用TCP协议</li>
<li>定制了RESP(Redis Serialization Protocol)序列化协议</li>
</ul>
<h2 id="协议格式"><a href="#协议格式" class="headerlink" title="协议格式"></a>协议格式</h2><p>请求格式(换行符使用<code>\r\n</code>):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*3</span><br><span class="line">$3</span><br><span class="line">SET</span><br><span class="line">$5</span><br><span class="line">hello</span><br><span class="line">$5</span><br><span class="line">world</span><br></pre></td></tr></table></figure>
<p>返回格式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+OK</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>格式说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*&lt;参数数量&gt;CRLF</span><br><span class="line">$&lt;参数1字节数&gt;CRLF</span><br><span class="line">&lt;参数1&gt;CRLF</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>实际是字符串:<br><code>*3\r\nSET\r\n$5\r\nhello\r\n$5\r\nworld\r\n</code></p>
<p>返回第一个字节为</p>
<ul>
<li><code>+</code>,状态回复,如<code>set hello world</code></li>
<li><code>-</code>,错误回复,命令错误</li>
<li><code>:</code>,整数回复,如<code>incr a</code></li>
<li><code>$</code>,字符串回复,如<code>get hello</code></li>
<li><code>*</code>,多条字符串回复,如<code>mget hello a</code></li>
</ul>
<h3 id="使用nc命令来查看原始返回"><a href="#使用nc命令来查看原始返回" class="headerlink" title="使用nc命令来查看原始返回"></a>使用<code>nc</code>命令来查看原始返回</h3><p><code>nc</code>是<code>ncat</code>的缩写,安装运行命令<code>yum install -y nc</code>,实际安装包名为:<code>nmap-ncat</code></p>
<ul>
<li>连接redis-server<br>  <code>nc 127.0.0.1 6666</code></li>
<li>发送命令<br>  <code>set hello world</code></li>
<li>收到返回<br>  <code>+OK</code></li>
<li>发送命令<br>  <code>get hello</code></li>
<li>收到返回  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$5</span><br><span class="line">world</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
        <category>development &amp; operation</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis慢日志</title>
    <url>/2018/07/23/redis-slowlog/</url>
    <content><![CDATA[<p>慢日志是记录命令执行超过<br>配置时间的命令的功能<br>用于查询较慢的命令操作,<br>根据慢日志可以分析并确定一些<br>数据库的使用问题,<br>进而可以针对这些问题进行优化.</p>
<p><strong>慢日志是内存数据,不参与持久化,重启数据库清空</strong></p>
<a id="more"></a>
<h2 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slowlog-log-slower-than 10000</span><br><span class="line">slowlog-max-len 128</span><br></pre></td></tr></table></figure>

<p>慢日志配置单位为微秒<br>1秒=1000000微秒<br>本身是双向链表结构<br>当数据超过长度限制后<br>会从头数据开始删除</p>
<h2 id="查询慢日志的方法"><a href="#查询慢日志的方法" class="headerlink" title="查询慢日志的方法"></a>查询慢日志的方法</h2><p>客户端连接<br>发送查询命令即可<br>(慢日志不是写文件的日志,<br>是在内存内维护的一套数据结构)</p>
<p>命令</p>
<ul>
<li><code>slowlog get [条数]</code>,没有参数则获取所有慢日志,添加条数则按由近到远的时间顺序<br>  显示最近几条的慢日志</li>
<li><code>slowlog len</code>,显示当前公有多少条慢日志</li>
<li><code>slowlog reset</code>,重置所有慢日志,清除记录</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:9898&gt; slowlog len</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:9898&gt; slowlog get 1</span><br><span class="line">1) 1) (integer) 2</span><br><span class="line">   2) (integer) 1532317655</span><br><span class="line">   3) (integer) 1000648</span><br><span class="line">   4) 1) &quot;SET&quot;</span><br><span class="line">      2) &quot;c&quot;</span><br><span class="line">      3) &quot;ccc&quot;</span><br><span class="line">127.0.0.1:9898&gt; slowlog get</span><br><span class="line">1) 1) (integer) 2</span><br><span class="line">   2) (integer) 1532317655</span><br><span class="line">   3) (integer) 1000648</span><br><span class="line">   4) 1) &quot;SET&quot;</span><br><span class="line">      2) &quot;c&quot;</span><br><span class="line">      3) &quot;ccc&quot;</span><br><span class="line">2) 1) (integer) 1</span><br><span class="line">   2) (integer) 1532317654</span><br><span class="line">   3) (integer) 1001048</span><br><span class="line">   4) 1) &quot;SET&quot;</span><br><span class="line">      2) &quot;b&quot;</span><br><span class="line">      3) &quot;bbb&quot;</span><br><span class="line">3) 1) (integer) 0</span><br><span class="line">   2) (integer) 1532317653</span><br><span class="line">   3) (integer) 1000425</span><br><span class="line">   4) 1) &quot;SET&quot;</span><br><span class="line">      2) &quot;a&quot;</span><br><span class="line">      3) &quot;aaa&quot;</span><br><span class="line">127.0.0.1:9898&gt; slowlog reset</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:9898&gt; slowlog len</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注:<br>字段说明:</p>
<ol>
<li>id</li>
<li>运行命令的时间戳(秒,unixtime)</li>
<li>执行命令时间,单位:微秒</li>
<li>执行的具体命令和参数信息</li>
</ol>
<h2 id="使用慢日志的思路"><a href="#使用慢日志的思路" class="headerlink" title="使用慢日志的思路"></a>使用慢日志的思路</h2><p>通过客户端,定时想数据库请求慢日志信息,<br>根据慢日志的id整理所有慢日志,<br>并将同类命令的整理在一起,<br>进而找到花费时间长的命令进行有针对的优化.</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>slowlog</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 源码分析-intset</title>
    <url>/2018/05/04/redis-source-intset/</url>
    <content><![CDATA[<p>set的一种优化数据结构<br>试用于元素数量较少<br>元素类型为int16_t,int32_t,int64_t<br>的情况<br>本质是uint8_t[]<br>set的编码会根据内容元素自动变更<br>不需要手动变更编码<br>从小到大递增排序</p>
<h2 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h2><ul>
<li>intset.h</li>
<li>intset.c</li>
</ul>
<a id="more"></a>

<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul>
<li>rand<br>  随机数生成<br>  范围:0-RAND_MAX<br>  RAND_MAX:系统相关,至少为32767</li>
<li>大小端<ul>
<li>大端<br>  高位字节存放在内存的低位地址中<br>  就是和阅读顺序一致,高位放在前面的低位地址中</li>
<li>小端<br>  低位字节存放在内存的低位地址中</li>
<li>网络字节序<br>  就是大端字节序</li>
<li>本地字节序<br>  根据机器不同而不同</li>
</ul>
</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding; <span class="comment">// 编码长度(就是sizeof(类型))</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length; <span class="comment">// 元素个数,不是占用字节数</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[]; <span class="comment">// 实际数据存储结构</span></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<h2 id="主要宏"><a href="#主要宏" class="headerlink" title="主要宏"></a>主要宏</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Note that these encodings are ordered, so:</span></span><br><span class="line"><span class="comment"> * INTSET_ENC_INT16 &lt; INTSET_ENC_INT32 &lt; INTSET_ENC_INT64. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))</span></span><br></pre></td></tr></table></figure>

<h2 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h2><h3 id="static-uint8-t-intsetValueEncoding-int64-t-v"><a href="#static-uint8-t-intsetValueEncoding-int64-t-v" class="headerlink" title="static uint8_t _intsetValueEncoding(int64_t v);"></a><code>static uint8_t _intsetValueEncoding(int64_t v);</code></h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>判断存储v需要的编码类型长度</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Return the required encoding for the provided value. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> _intsetValueEncoding(<span class="keyword">int64_t</span> v) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v &lt; INT32_MIN || v &gt; INT32_MAX)</span><br><span class="line">        <span class="keyword">return</span> INTSET_ENC_INT64;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; INT16_MIN || v &gt; INT16_MAX)</span><br><span class="line">        <span class="keyword">return</span> INTSET_ENC_INT32;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> INTSET_ENC_INT16;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="static-int64-t-intsetGetEncoded-intset-is-int-pos-uint8-t-enc"><a href="#static-int64-t-intsetGetEncoded-intset-is-int-pos-uint8-t-enc" class="headerlink" title="static int64_t _intsetGetEncoded(intset *is, int pos, uint8_t enc);"></a><code>static int64_t _intsetGetEncoded(intset *is, int pos, uint8_t enc);</code></h3><h4 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h4><p>根据指定编码获取intset的指定位置的值</p>
<h4 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Return the value at pos, given an encoding. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int64_t</span> _intsetGetEncoded(intset *is, <span class="keyword">int</span> pos, <span class="keyword">uint8_t</span> enc) &#123;</span><br><span class="line">    <span class="keyword">int64_t</span> v64;</span><br><span class="line">    <span class="keyword">int32_t</span> v32;</span><br><span class="line">    <span class="keyword">int16_t</span> v16;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enc == INTSET_ENC_INT64) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;v64,((<span class="keyword">int64_t</span>*)is-&gt;contents)+pos,<span class="keyword">sizeof</span>(v64));</span><br><span class="line">        memrev64ifbe(&amp;v64);</span><br><span class="line">        <span class="keyword">return</span> v64;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (enc == INTSET_ENC_INT32) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;v32,((<span class="keyword">int32_t</span>*)is-&gt;contents)+pos,<span class="keyword">sizeof</span>(v32));</span><br><span class="line">        memrev32ifbe(&amp;v32);</span><br><span class="line">        <span class="keyword">return</span> v32;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;v16,((<span class="keyword">int16_t</span>*)is-&gt;contents)+pos,<span class="keyword">sizeof</span>(v16));</span><br><span class="line">        memrev16ifbe(&amp;v16);</span><br><span class="line">        <span class="keyword">return</span> v16;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="static-int64-t-intsetGet-intset-is-int-pos"><a href="#static-int64-t-intsetGet-intset-is-int-pos" class="headerlink" title="static int64_t _intsetGet(intset *is, int pos);"></a><code>static int64_t _intsetGet(intset *is, int pos);</code></h3><h4 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h4><p>根据intset的编码类型获取指定位置的值</p>
<h4 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Return the value at pos, using the configured encoding. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int64_t</span> _intsetGet(intset *is, <span class="keyword">int</span> pos) &#123;</span><br><span class="line">    <span class="keyword">return</span> _intsetGetEncoded(is,pos,intrev32ifbe(is-&gt;encoding));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="static-void-intsetSet-intset-is-int-pos-int64-t-value"><a href="#static-void-intsetSet-intset-is-int-pos-int64-t-value" class="headerlink" title="static void _intsetSet(intset *is, int pos, int64_t value);"></a><code>static void _intsetSet(intset *is, int pos, int64_t value);</code></h3><h4 id="功能-3"><a href="#功能-3" class="headerlink" title="功能"></a>功能</h4><p>根据intset的编码类型设置指定位置的值</p>
<h4 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set the value at pos, using the configured encoding. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _intsetSet(intset *is, <span class="keyword">int</span> pos, <span class="keyword">int64_t</span> value) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> encoding = intrev32ifbe(is-&gt;encoding);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (encoding == INTSET_ENC_INT64) &#123;</span><br><span class="line">        ((<span class="keyword">int64_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">        memrev64ifbe(((<span class="keyword">int64_t</span>*)is-&gt;contents)+pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == INTSET_ENC_INT32) &#123;</span><br><span class="line">        ((<span class="keyword">int32_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">        memrev32ifbe(((<span class="keyword">int32_t</span>*)is-&gt;contents)+pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ((<span class="keyword">int16_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">        memrev16ifbe(((<span class="keyword">int16_t</span>*)is-&gt;contents)+pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="intset-intsetNew-void"><a href="#intset-intsetNew-void" class="headerlink" title="intset *intsetNew(void);"></a><code>intset *intsetNew(void);</code></h3><h4 id="功能-4"><a href="#功能-4" class="headerlink" title="功能"></a>功能</h4><p>创建一个空的intset</p>
<h4 id="源码-4"><a href="#源码-4" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create an empty intset. */</span></span><br><span class="line"><span class="function">intset *<span class="title">intsetNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    intset *is = zmalloc(<span class="keyword">sizeof</span>(intset)); <span class="comment">// 申请内存</span></span><br><span class="line">    is-&gt;encoding = intrev32ifbe(INTSET_ENC_INT16); <span class="comment">// 设置默认编码</span></span><br><span class="line">    is-&gt;length = <span class="number">0</span>; <span class="comment">// 设置初始长度</span></span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="static-intset-intsetResize-intset-is-uint32-t-len"><a href="#static-intset-intsetResize-intset-is-uint32-t-len" class="headerlink" title="static intset *intsetResize(intset *is, uint32_t len);"></a><code>static intset *intsetResize(intset *is, uint32_t len);</code></h3><h4 id="功能-5"><a href="#功能-5" class="headerlink" title="功能"></a>功能</h4><p>为intset重新分配内存大小</p>
<h4 id="源码-5"><a href="#源码-5" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Resize the intset */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> intset *<span class="title">intsetResize</span><span class="params">(intset *is, <span class="keyword">uint32_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> size = len*intrev32ifbe(is-&gt;encoding); <span class="comment">// 获取默认编码对应的所有数据的长度</span></span><br><span class="line">    is = zrealloc(is,<span class="keyword">sizeof</span>(intset)+size); <span class="comment">// 变更内存大小</span></span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="static-uint8-t-intsetSearch-intset-is-int64-t-value-uint32-t-pos"><a href="#static-uint8-t-intsetSearch-intset-is-int64-t-value-uint32-t-pos" class="headerlink" title="static uint8_t intsetSearch(intset *is, int64_t value, uint32_t *pos);"></a><code>static uint8_t intsetSearch(intset *is, int64_t value, uint32_t *pos);</code></h3><h4 id="功能-6"><a href="#功能-6" class="headerlink" title="功能"></a>功能</h4><p>查找value在intset的位置<br>返回是否找到<br>pos指针为value的位置或可以插入到的位置</p>
<h4 id="源码-6"><a href="#源码-6" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Search for the position of &quot;value&quot;. Return 1 when the value was found and</span></span><br><span class="line"><span class="comment"> * sets &quot;pos&quot; to the position of the value within the intset. Return 0 when</span></span><br><span class="line"><span class="comment"> * the value is not present in the intset and sets &quot;pos&quot; to the position</span></span><br><span class="line"><span class="comment"> * where &quot;value&quot; can be inserted. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint8_t</span> <span class="title">intsetSearch</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">uint32_t</span> *pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>, max = intrev32ifbe(is-&gt;length)<span class="number">-1</span>, mid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int64_t</span> cur = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The value can never be found when the set is empty */</span></span><br><span class="line">    <span class="keyword">if</span> (intrev32ifbe(is-&gt;length) == <span class="number">0</span>) &#123; <span class="comment">// 空集合</span></span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = <span class="number">0</span>; <span class="comment">// 没有找到</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 没有找到</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Check for the case where we know we cannot find the value,</span></span><br><span class="line"><span class="comment">         * but do know the insert position. */</span></span><br><span class="line">        <span class="keyword">if</span> (value &gt; _intsetGet(is,intrev32ifbe(is-&gt;length)<span class="number">-1</span>)) &#123; <span class="comment">// 值如果大于最大值</span></span><br><span class="line">            <span class="keyword">if</span> (pos) *pos = intrev32ifbe(is-&gt;length); <span class="comment">// 可以直接添加到数组末尾</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 没有找到</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; _intsetGet(is,<span class="number">0</span>)) &#123; <span class="comment">// 比最小的小</span></span><br><span class="line">            <span class="keyword">if</span> (pos) *pos = <span class="number">0</span>; <span class="comment">// 可以插入到最前面</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 没有找到</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(max &gt;= min) &#123; <span class="comment">// 二分法查找value的pos</span></span><br><span class="line">        mid = ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)min + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)max) &gt;&gt; <span class="number">1</span>; <span class="comment">// 取到中间值位置</span></span><br><span class="line">        cur = _intsetGet(is,mid); <span class="comment">// 获取中间的值</span></span><br><span class="line">        <span class="keyword">if</span> (value &gt; cur) &#123;</span><br><span class="line">            min = mid+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; cur) &#123;</span><br><span class="line">            max = mid<span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value == cur) &#123; <span class="comment">// 找到了</span></span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = mid; <span class="comment">// 设置找到的位置</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 找到了</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = min; <span class="comment">// 设置可以插入的位置</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 没找到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="static-intset-intsetUpgradeAndAdd-intset-is-int64-t-value"><a href="#static-intset-intsetUpgradeAndAdd-intset-is-int64-t-value" class="headerlink" title="static intset *intsetUpgradeAndAdd(intset *is, int64_t value);"></a><code>static intset *intsetUpgradeAndAdd(intset *is, int64_t value);</code></h3><h4 id="功能-7"><a href="#功能-7" class="headerlink" title="功能"></a>功能</h4><p>当编码类型发生扩大时调用,<br>整体扩展intset的所有数据到更大的数据编码<br>并将value的值插入到intset的开头或结尾<br>必然在开头或结尾的原因是大的数据结构的取值范围一定大于小的数据结构<br>所以整数肯定在最后,负数肯定在起始位置</p>
<h4 id="源码-7"><a href="#源码-7" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Upgrades the intset to a larger encoding and inserts the given integer. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> intset *<span class="title">intsetUpgradeAndAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> curenc = intrev32ifbe(is-&gt;encoding); <span class="comment">// 获取当前编码</span></span><br><span class="line">    <span class="keyword">uint8_t</span> newenc = _intsetValueEncoding(value); <span class="comment">// 获取新编码</span></span><br><span class="line">    <span class="keyword">int</span> length = intrev32ifbe(is-&gt;length); <span class="comment">// 获取原始长度</span></span><br><span class="line">    <span class="keyword">int</span> prepend = value &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// 是插入在前面还是插入在最后(负数在前面,正数在后面)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First set new encoding and resize */</span></span><br><span class="line">    is-&gt;encoding = intrev32ifbe(newenc); <span class="comment">// 设置新编码</span></span><br><span class="line">    is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>); <span class="comment">// 调整intset的容量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Upgrade back-to-front so we don&#x27;t overwrite values.</span></span><br><span class="line"><span class="comment">     * Note that the &quot;prepend&quot; variable is used to make sure we have an empty</span></span><br><span class="line"><span class="comment">     * space at either the beginning or the end of the intset. */</span></span><br><span class="line">    <span class="keyword">while</span>(length--) <span class="comment">// 按照从后向前的顺序遍历移动每个元素(倒序的原因是不会覆盖没有移动的数据)</span></span><br><span class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc)); <span class="comment">// 将原数据移动到新位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the value at the beginning or the end. */</span></span><br><span class="line">    <span class="keyword">if</span> (prepend) <span class="comment">// 是否插入在前面</span></span><br><span class="line">        _intsetSet(is,<span class="number">0</span>,value); <span class="comment">// 插入在前面</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _intsetSet(is,intrev32ifbe(is-&gt;length),value); <span class="comment">// 插入在后面</span></span><br><span class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>); <span class="comment">// 更新长度</span></span><br><span class="line">    <span class="keyword">return</span> is; <span class="comment">// 返回新的intset指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="static-void-intsetMoveTail-intset-is-uint32-t-from-uint32-t-to"><a href="#static-void-intsetMoveTail-intset-is-uint32-t-from-uint32-t-to" class="headerlink" title="static void intsetMoveTail(intset *is, uint32_t from, uint32_t to);"></a><code>static void intsetMoveTail(intset *is, uint32_t from, uint32_t to);</code></h3><h4 id="功能-8"><a href="#功能-8" class="headerlink" title="功能"></a>功能</h4><p>将intset的连续内存地址从from开始到数据结尾移动到to的位置<br>就是为插入/删除数据操作封装的移动数据的接口</p>
<h4 id="源码-8"><a href="#源码-8" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">intsetMoveTail</span><span class="params">(intset *is, <span class="keyword">uint32_t</span> from, <span class="keyword">uint32_t</span> to)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *src, *dst;</span><br><span class="line">    <span class="keyword">uint32_t</span> bytes = intrev32ifbe(is-&gt;length)-from; <span class="comment">// 获取到总共要移动多少个元素</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding = intrev32ifbe(is-&gt;encoding); <span class="comment">// 获取当前编码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (encoding == INTSET_ENC_INT64) &#123; <span class="comment">// 统计起始位置,目标位置,总共移动的字节数</span></span><br><span class="line">        src = (<span class="keyword">int64_t</span>*)is-&gt;contents+from;</span><br><span class="line">        dst = (<span class="keyword">int64_t</span>*)is-&gt;contents+to;</span><br><span class="line">        bytes *= <span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == INTSET_ENC_INT32) &#123;</span><br><span class="line">        src = (<span class="keyword">int32_t</span>*)is-&gt;contents+from;</span><br><span class="line">        dst = (<span class="keyword">int32_t</span>*)is-&gt;contents+to;</span><br><span class="line">        bytes *= <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        src = (<span class="keyword">int16_t</span>*)is-&gt;contents+from;</span><br><span class="line">        dst = (<span class="keyword">int16_t</span>*)is-&gt;contents+to;</span><br><span class="line">        bytes *= <span class="keyword">sizeof</span>(<span class="keyword">int16_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    memmove(dst,src,bytes); <span class="comment">// 移动内存数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="intset-intsetAdd-intset-is-int64-t-value-uint8-t-success"><a href="#intset-intsetAdd-intset-is-int64-t-value-uint8-t-success" class="headerlink" title="intset *intsetAdd(intset *is, int64_t value, uint8_t *success);"></a><code>intset *intsetAdd(intset *is, int64_t value, uint8_t *success);</code></h3><h4 id="功能-9"><a href="#功能-9" class="headerlink" title="功能"></a>功能</h4><p>添加一个新的值<br>success:成功失败<br>返回新的intset指针</p>
<h4 id="源码-9"><a href="#源码-9" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Insert an integer in the intset */</span></span><br><span class="line"><span class="function">intset *<span class="title">intsetAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">uint8_t</span> *success)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> valenc = _intsetValueEncoding(value); <span class="comment">// 获取新的值的编码</span></span><br><span class="line">    <span class="keyword">uint32_t</span> pos;</span><br><span class="line">    <span class="keyword">if</span> (success) *success = <span class="number">1</span>; <span class="comment">// 初始标记为成功</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Upgrade encoding if necessary. If we need to upgrade, we know that</span></span><br><span class="line"><span class="comment">     * this value should be either appended (if &gt; 0) or prepended (if &lt; 0),</span></span><br><span class="line"><span class="comment">     * because it lies outside the range of existing values. */</span></span><br><span class="line">    <span class="keyword">if</span> (valenc &gt; intrev32ifbe(is-&gt;encoding)) &#123; <span class="comment">// 数据编码超出当前intset编码范围</span></span><br><span class="line">        <span class="comment">/* This always succeeds, so we don&#x27;t need to curry *success. */</span></span><br><span class="line">        <span class="keyword">return</span> intsetUpgradeAndAdd(is,value); <span class="comment">// 扩展intset编码并插入数据</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Abort if the value is already present in the set.</span></span><br><span class="line"><span class="comment">         * This call will populate &quot;pos&quot; with the right position to insert</span></span><br><span class="line"><span class="comment">         * the value when it cannot be found. */</span></span><br><span class="line">        <span class="keyword">if</span> (intsetSearch(is,value,&amp;pos)) &#123; <span class="comment">// 查找是否已经存在这个值并获取可插入的位置</span></span><br><span class="line">            <span class="keyword">if</span> (success) *success = <span class="number">0</span>; <span class="comment">// 已经存在,则插入失败</span></span><br><span class="line">            <span class="keyword">return</span> is; <span class="comment">// 返回原始intset地址</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>); <span class="comment">// 扩展容量</span></span><br><span class="line">        <span class="keyword">if</span> (pos &lt; intrev32ifbe(is-&gt;length)) intsetMoveTail(is,pos,pos+<span class="number">1</span>); <span class="comment">// 插入位置不是结尾的话,所有插入位置之后的数据需要向后移动</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _intsetSet(is,pos,value); <span class="comment">// 在指定位置插入数据</span></span><br><span class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>); <span class="comment">// 扩展intset的长度</span></span><br><span class="line">    <span class="keyword">return</span> is; <span class="comment">// 返回新的intset指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="intset-intsetRemove-intset-is-int64-t-value-int-success"><a href="#intset-intsetRemove-intset-is-int64-t-value-int-success" class="headerlink" title="intset *intsetRemove(intset *is, int64_t value, int *success);"></a><code>intset *intsetRemove(intset *is, int64_t value, int *success);</code></h3><h4 id="功能-10"><a href="#功能-10" class="headerlink" title="功能"></a>功能</h4><p>删除value的值<br>success表示是否成功</p>
<h4 id="源码-10"><a href="#源码-10" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Delete integer from intset */</span></span><br><span class="line"><span class="function">intset *<span class="title">intsetRemove</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">int</span> *success)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> valenc = _intsetValueEncoding(value); <span class="comment">// 获取元素编码</span></span><br><span class="line">    <span class="keyword">uint32_t</span> pos;</span><br><span class="line">    <span class="keyword">if</span> (success) *success = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (valenc &lt;= intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is,value,&amp;pos)) &#123; <span class="comment">// 判断元素编码是否在intset编码范围内,同时可以查找到指定的值</span></span><br><span class="line">        <span class="keyword">uint32_t</span> len = intrev32ifbe(is-&gt;length); <span class="comment">// 获取到intset的元素个数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We know we can delete */</span></span><br><span class="line">        <span class="keyword">if</span> (success) *success = <span class="number">1</span>; <span class="comment">// 标记删除成功</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Overwrite value with tail and update length */</span></span><br><span class="line">        <span class="keyword">if</span> (pos &lt; (len<span class="number">-1</span>)) intsetMoveTail(is,pos+<span class="number">1</span>,pos); <span class="comment">// 直接移动数据覆盖以前的value值</span></span><br><span class="line">        is = intsetResize(is,len<span class="number">-1</span>); <span class="comment">// 缩小intset容量</span></span><br><span class="line">        is-&gt;length = intrev32ifbe(len<span class="number">-1</span>); <span class="comment">// 记录intset长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is; <span class="comment">// 返回新的intset指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="uint8-t-intsetFind-intset-is-int64-t-value"><a href="#uint8-t-intsetFind-intset-is-int64-t-value" class="headerlink" title="uint8_t intsetFind(intset *is, int64_t value);"></a><code>uint8_t intsetFind(intset *is, int64_t value);</code></h3><h4 id="功能-11"><a href="#功能-11" class="headerlink" title="功能"></a>功能</h4><p>查找值是否在intset中</p>
<h4 id="源码-11"><a href="#源码-11" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Determine whether a value belongs to this set */</span></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">intsetFind</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> valenc = _intsetValueEncoding(value); <span class="comment">// 获取编码</span></span><br><span class="line">    <span class="keyword">return</span> valenc &lt;= intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is,value,<span class="literal">NULL</span>); <span class="comment">// 判断值的编码在intset范围内,并且可以找到这个值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int64-t-intsetRandom-intset-is"><a href="#int64-t-intsetRandom-intset-is" class="headerlink" title="int64_t intsetRandom(intset *is);"></a><code>int64_t intsetRandom(intset *is);</code></h3><h4 id="功能-12"><a href="#功能-12" class="headerlink" title="功能"></a>功能</h4><p>获取随机的元素</p>
<h4 id="源码-12"><a href="#源码-12" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Return random member */</span></span><br><span class="line"><span class="function"><span class="keyword">int64_t</span> <span class="title">intsetRandom</span><span class="params">(intset *is)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _intsetGet(is,rand()%intrev32ifbe(is-&gt;length));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="uint8-t-intsetGet-intset-is-uint32-t-pos-int64-t-value"><a href="#uint8-t-intsetGet-intset-is-uint32-t-pos-int64-t-value" class="headerlink" title="uint8_t intsetGet(intset *is, uint32_t pos, int64_t *value)"></a><code>uint8_t intsetGet(intset *is, uint32_t pos, int64_t *value)</code></h3><h4 id="功能-13"><a href="#功能-13" class="headerlink" title="功能"></a>功能</h4><p>获取intset指定位置的值<br>返回成功失败</p>
<h4 id="源码-13"><a href="#源码-13" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Sets the value to the value at the given position. When this position is</span></span><br><span class="line"><span class="comment"> * out of range the function returns 0, when in range it returns 1. */</span></span><br><span class="line"><span class="function"><span class="keyword">uint8_t</span> <span class="title">intsetGet</span><span class="params">(intset *is, <span class="keyword">uint32_t</span> pos, <span class="keyword">int64_t</span> *value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; intrev32ifbe(is-&gt;length)) &#123;</span><br><span class="line">        *value = _intsetGet(is,pos);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="uint32-t-intsetLen-intset-is"><a href="#uint32-t-intsetLen-intset-is" class="headerlink" title="uint32_t intsetLen(intset *is);"></a><code>uint32_t intsetLen(intset *is);</code></h3><h4 id="功能-14"><a href="#功能-14" class="headerlink" title="功能"></a>功能</h4><p>获取intset的数据个数</p>
<h4 id="源码-14"><a href="#源码-14" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Return intset length */</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">intsetLen</span><span class="params">(intset *is)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> intrev32ifbe(is-&gt;length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="size-t-intsetBlobLen-intset-is"><a href="#size-t-intsetBlobLen-intset-is" class="headerlink" title="size_t intsetBlobLen(intset *is);"></a><code>size_t intsetBlobLen(intset *is);</code></h3><h4 id="功能-15"><a href="#功能-15" class="headerlink" title="功能"></a>功能</h4><p>获取intset的占用内存空间<br>全部空间(结构体大小+数据量大小)</p>
<h4 id="源码-15"><a href="#源码-15" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Return intset blob size in bytes. */</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">intsetBlobLen</span><span class="params">(intset *is)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span>(intset)+intrev32ifbe(is-&gt;length)*intrev32ifbe(is-&gt;encoding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>redis</category>
        <category>source</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 源码分析-list</title>
    <url>/2018/05/09/redis-source-list/</url>
    <content><![CDATA[<p>Redis3.2版本前的数据结构<br>本质是一个双向链表<br>最基本的双向链表<br>附带一个迭代器<br>3.2版本后使用quicklist代替</p>
<h2 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h2><ul>
<li>adlist.h</li>
<li>adlist.c<a id="more"></a>

</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line">    listNode *next;</span><br><span class="line">    <span class="keyword">int</span> direction;</span><br><span class="line">&#125; listIter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr); <span class="comment">// 单个数据复制</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr); <span class="comment">// 单个数据释放</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key); <span class="comment">// 单个数据比较</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<h2 id="主要宏"><a href="#主要宏" class="headerlink" title="主要宏"></a>主要宏</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Functions implemented as macros */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listLength(l) ((l)-&gt;len)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listFirst(l) ((l)-&gt;head)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listLast(l) ((l)-&gt;tail)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listPrevNode(n) ((n)-&gt;prev)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listNextNode(n) ((n)-&gt;next)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listNodeValue(n) ((n)-&gt;value)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetDupMethod(l,m) ((l)-&gt;dup = (m))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetFreeMethod(l,m) ((l)-&gt;free = (m))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listSetMatchMethod(l,m) ((l)-&gt;match = (m))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetDupMethod(l) ((l)-&gt;dup)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetFree(l) ((l)-&gt;free)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> listGetMatchMethod(l) ((l)-&gt;match)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Directions for iterators */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AL_START_HEAD 0 <span class="comment">// 迭代器迭代方向,从前向后</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AL_START_TAIL 1 <span class="comment">// 迭代器迭代方向,从后向前</span></span></span><br></pre></td></tr></table></figure>

<h2 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h2><h3 id="list-listCreate-void"><a href="#list-listCreate-void" class="headerlink" title="list *listCreate(void);"></a><code>list *listCreate(void);</code></h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>创建list</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create a new list. The created list can be freed with</span></span><br><span class="line"><span class="comment"> * AlFreeList(), but private value of every node need to be freed</span></span><br><span class="line"><span class="comment"> * by the user before to call AlFreeList().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On error, NULL is returned. Otherwise the pointer to the new list. */</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listCreate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">list</span> = zmalloc(<span class="keyword">sizeof</span>(*<span class="built_in">list</span>))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;dup = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">free</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;match = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void-listRelease-list-list"><a href="#void-listRelease-list-list" class="headerlink" title="void listRelease(list *list);"></a><code>void listRelease(list *list);</code></h3><h4 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h4><p>释放list</p>
<h4 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Free the whole list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function can&#x27;t fail. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    listNode *current, *next;</span><br><span class="line"></span><br><span class="line">    current = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    len = <span class="built_in">list</span>-&gt;len;</span><br><span class="line">    <span class="keyword">while</span>(len--) &#123;</span><br><span class="line">        next = current-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(current-&gt;value);</span><br><span class="line">        zfree(current);</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    zfree(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="list-listAddNodeHead-list-list-void-value"><a href="#list-listAddNodeHead-list-list-void-value" class="headerlink" title="list *listAddNodeHead(list *list, void *value);"></a><code>list *listAddNodeHead(list *list, void *value);</code></h3><h4 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h4><p>在list头插入元素</p>
<h4 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Add a new node to the list, to head, containing the specified &#x27;value&#x27;</span></span><br><span class="line"><span class="comment"> * pointer as value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On error, NULL is returned and no operation is performed (i.e. the</span></span><br><span class="line"><span class="comment"> * list remains unaltered).</span></span><br><span class="line"><span class="comment"> * On success the &#x27;list&#x27; pointer you pass to the function is returned. */</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeHead</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        node-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head-&gt;prev = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="list-listAddNodeTail-list-list-void-value"><a href="#list-listAddNodeTail-list-list-void-value" class="headerlink" title="list *listAddNodeTail(list *list, void *value);"></a><code>list *listAddNodeTail(list *list, void *value);</code></h3><h4 id="功能-3"><a href="#功能-3" class="headerlink" title="功能"></a>功能</h4><p>在list尾插入元素</p>
<h4 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Add a new node to the list, to tail, containing the specified &#x27;value&#x27;</span></span><br><span class="line"><span class="comment"> * pointer as value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On error, NULL is returned and no operation is performed (i.e. the</span></span><br><span class="line"><span class="comment"> * list remains unaltered).</span></span><br><span class="line"><span class="comment"> * On success the &#x27;list&#x27; pointer you pass to the function is returned. */</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listAddNodeTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;prev = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">list</span>-&gt;tail-&gt;next = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="list-listInsertNode-list-list-listNode-old-node-void-value-int-after"><a href="#list-listInsertNode-list-list-listNode-old-node-void-value-int-after" class="headerlink" title="list *listInsertNode(list *list, listNode *old_node, void *value, int after);"></a><code>list *listInsertNode(list *list, listNode *old_node, void *value, int after);</code></h3><h4 id="功能-4"><a href="#功能-4" class="headerlink" title="功能"></a>功能</h4><p>在old_node前/后插入新的数据</p>
<h4 id="源码-4"><a href="#源码-4" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listInsertNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *old_node, <span class="keyword">void</span> *value, <span class="keyword">int</span> after)</span> </span>&#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="keyword">if</span> (after) &#123;</span><br><span class="line">        node-&gt;prev = old_node;</span><br><span class="line">        node-&gt;next = old_node-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;tail == old_node) &#123;</span><br><span class="line">            <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;next = old_node;</span><br><span class="line">        node-&gt;prev = old_node-&gt;prev;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;head == old_node) &#123;</span><br><span class="line">            <span class="built_in">list</span>-&gt;head = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node-&gt;next-&gt;prev = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void-listDelNode-list-list-listNode-node"><a href="#void-listDelNode-list-list-listNode-node" class="headerlink" title="void listDelNode(list *list, listNode *node);"></a><code>void listDelNode(list *list, listNode *node);</code></h3><h4 id="功能-5"><a href="#功能-5" class="headerlink" title="功能"></a>功能</h4><p>删除元素节点</p>
<h4 id="源码-5"><a href="#源码-5" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Remove the specified node from the specified list.</span></span><br><span class="line"><span class="comment"> * It&#x27;s up to the caller to free the private value of the node.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function can&#x27;t fail. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listDelNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;prev)</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next)</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;tail = node-&gt;prev;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(node-&gt;value);</span><br><span class="line">    zfree(node);</span><br><span class="line">    <span class="built_in">list</span>-&gt;len--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="listIter-listGetIterator-list-list-int-direction"><a href="#listIter-listGetIterator-list-list-int-direction" class="headerlink" title="listIter *listGetIterator(list *list, int direction);"></a><code>listIter *listGetIterator(list *list, int direction);</code></h3><h4 id="功能-6"><a href="#功能-6" class="headerlink" title="功能"></a>功能</h4><p>创建一个list的迭代器</p>
<h4 id="源码-6"><a href="#源码-6" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Returns a list iterator &#x27;iter&#x27;. After the initialization every</span></span><br><span class="line"><span class="comment"> * call to listNext() will return the next element of the list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function can&#x27;t fail. */</span></span><br><span class="line"><span class="function">listIter *<span class="title">listGetIterator</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">int</span> direction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listIter *iter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((iter = zmalloc(<span class="keyword">sizeof</span>(*iter))) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (direction == AL_START_HEAD)</span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">    iter-&gt;direction = direction;</span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void-listReleaseIterator-listIter-iter"><a href="#void-listReleaseIterator-listIter-iter" class="headerlink" title="void listReleaseIterator(listIter *iter);"></a><code>void listReleaseIterator(listIter *iter);</code></h3><h4 id="功能-7"><a href="#功能-7" class="headerlink" title="功能"></a>功能</h4><p>释放迭代器</p>
<h4 id="源码-7"><a href="#源码-7" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Release the iterator memory */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listReleaseIterator</span><span class="params">(listIter *iter)</span> </span>&#123;</span><br><span class="line">    zfree(iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void-listRewind-list-list-listIter-li"><a href="#void-listRewind-list-list-listIter-li" class="headerlink" title="void listRewind(list *list, listIter *li);"></a><code>void listRewind(list *list, listIter *li);</code></h3><h4 id="功能-8"><a href="#功能-8" class="headerlink" title="功能"></a>功能</h4><p>重置迭代器,方向调整为从头到尾</p>
<h4 id="源码-8"><a href="#源码-8" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create an iterator in the list private iterator structure */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewind</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span> </span>&#123;</span><br><span class="line">    li-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    li-&gt;direction = AL_START_HEAD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void-listRewindTail-list-list-listIter-li"><a href="#void-listRewindTail-list-list-listIter-li" class="headerlink" title="void listRewindTail(list *list, listIter *li);"></a><code>void listRewindTail(list *list, listIter *li);</code></h3><h4 id="功能-9"><a href="#功能-9" class="headerlink" title="功能"></a>功能</h4><p>重置迭代器,方向调整为从尾到头</p>
<h4 id="源码-9"><a href="#源码-9" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRewindTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span> </span>&#123;</span><br><span class="line">    li-&gt;next = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">    li-&gt;direction = AL_START_TAIL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="listNode-listNext-listIter-iter"><a href="#listNode-listNext-listIter-iter" class="headerlink" title="listNode *listNext(listIter *iter);"></a><code>listNode *listNext(listIter *iter);</code></h3><h4 id="功能-10"><a href="#功能-10" class="headerlink" title="功能"></a>功能</h4><p>迭代,获取下一个元素</p>
<h4 id="源码-10"><a href="#源码-10" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Return the next element of an iterator.</span></span><br><span class="line"><span class="comment"> * It&#x27;s valid to remove the currently returned element using</span></span><br><span class="line"><span class="comment"> * listDelNode(), but not to remove other elements.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns a pointer to the next element of the list,</span></span><br><span class="line"><span class="comment"> * or NULL if there are no more elements, so the classical usage patter</span></span><br><span class="line"><span class="comment"> * is:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * iter = listGetIterator(list,&lt;direction&gt;);</span></span><br><span class="line"><span class="comment"> * while ((node = listNext(iter)) != NULL) &#123;</span></span><br><span class="line"><span class="comment"> *     doSomethingWith(listNodeValue(node));</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function">listNode *<span class="title">listNext</span><span class="params">(listIter *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listNode *current = iter-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;direction == AL_START_HEAD)</span><br><span class="line">            iter-&gt;next = current-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            iter-&gt;next = current-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="list-listDup-list-orig"><a href="#list-listDup-list-orig" class="headerlink" title="list *listDup(list *orig);"></a><code>list *listDup(list *orig);</code></h3><h4 id="功能-11"><a href="#功能-11" class="headerlink" title="功能"></a>功能</h4><p>复制list</p>
<h4 id="源码-11"><a href="#源码-11" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Duplicate the whole list. On out of memory NULL is returned.</span></span><br><span class="line"><span class="comment"> * On success a copy of the original list is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The &#x27;Dup&#x27; method set with listSetDupMethod() function is used</span></span><br><span class="line"><span class="comment"> * to copy the node value. Otherwise the same pointer value of</span></span><br><span class="line"><span class="comment"> * the original node is used as value of the copied node.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The original list both on success or error is never modified. */</span></span><br><span class="line"><span class="function"><span class="built_in">list</span> *<span class="title">listDup</span><span class="params">(<span class="built_in">list</span> *orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span> *copy;</span><br><span class="line">    listIter *iter;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((copy = listCreate()) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    copy-&gt;dup = orig-&gt;dup;</span><br><span class="line">    copy-&gt;<span class="built_in">free</span> = orig-&gt;<span class="built_in">free</span>;</span><br><span class="line">    copy-&gt;match = orig-&gt;match;</span><br><span class="line">    iter = listGetIterator(orig, AL_START_HEAD);</span><br><span class="line">    <span class="keyword">while</span>((node = listNext(iter)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">void</span> *value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (copy-&gt;dup) &#123;</span><br><span class="line">            value = copy-&gt;dup(node-&gt;value);</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                listRelease(copy);</span><br><span class="line">                listReleaseIterator(iter);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            value = node-&gt;value;</span><br><span class="line">        <span class="keyword">if</span> (listAddNodeTail(copy, value) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            listRelease(copy);</span><br><span class="line">            listReleaseIterator(iter);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    listReleaseIterator(iter);</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="listNode-listSearchKey-list-list-void-key"><a href="#listNode-listSearchKey-list-list-void-key" class="headerlink" title="listNode *listSearchKey(list *list, void *key);"></a><code>listNode *listSearchKey(list *list, void *key);</code></h3><h4 id="功能-12"><a href="#功能-12" class="headerlink" title="功能"></a>功能</h4><p>在list中查找指定key<br>返回找到的节点</p>
<h4 id="源码-12"><a href="#源码-12" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Search the list for a node matching a given key.</span></span><br><span class="line"><span class="comment"> * The match is performed using the &#x27;match&#x27; method</span></span><br><span class="line"><span class="comment"> * set with listSetMatchMethod(). If no &#x27;match&#x27; method</span></span><br><span class="line"><span class="comment"> * is set, the &#x27;value&#x27; pointer of every node is directly</span></span><br><span class="line"><span class="comment"> * compared with the &#x27;key&#x27; pointer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On success the first matching node pointer is returned</span></span><br><span class="line"><span class="comment"> * (search starts from head). If no matching node exists</span></span><br><span class="line"><span class="comment"> * NULL is returned. */</span></span><br><span class="line"><span class="function">listNode *<span class="title">listSearchKey</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    listIter *iter;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">    iter = listGetIterator(<span class="built_in">list</span>, AL_START_HEAD);</span><br><span class="line">    <span class="keyword">while</span>((node = listNext(iter)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;match) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;match(node-&gt;value, key)) &#123;</span><br><span class="line">                listReleaseIterator(iter);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (key == node-&gt;value) &#123;</span><br><span class="line">                listReleaseIterator(iter);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    listReleaseIterator(iter);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="listNode-listIndex-list-list-long-index"><a href="#listNode-listIndex-list-list-long-index" class="headerlink" title="listNode *listIndex(list *list, long index);"></a><code>listNode *listIndex(list *list, long index);</code></h3><h4 id="功能-13"><a href="#功能-13" class="headerlink" title="功能"></a>功能</h4><p>获取第index位置的元素节点</p>
<h4 id="源码-13"><a href="#源码-13" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Return the element at the specified zero-based index</span></span><br><span class="line"><span class="comment"> * where 0 is the head, 1 is the element next to head</span></span><br><span class="line"><span class="comment"> * and so on. Negative integers are used in order to count</span></span><br><span class="line"><span class="comment"> * from the tail, -1 is the last element, -2 the penultimate</span></span><br><span class="line"><span class="comment"> * and so on. If the index is out of range NULL is returned. */</span></span><br><span class="line"><span class="function">listNode *<span class="title">listIndex</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="keyword">long</span> index)</span> </span>&#123;</span><br><span class="line">    listNode *n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        index = (-index)<span class="number">-1</span>;</span><br><span class="line">        n = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">        <span class="keyword">while</span>(index-- &amp;&amp; n) n = n-&gt;prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="keyword">while</span>(index-- &amp;&amp; n) n = n-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void-listRotate-list-list"><a href="#void-listRotate-list-list" class="headerlink" title="void listRotate(list *list);"></a><code>void listRotate(list *list);</code></h3><h4 id="功能-14"><a href="#功能-14" class="headerlink" title="功能"></a>功能</h4><p>旋转list,将结尾节点移动到头部</p>
<h4 id="源码-14"><a href="#源码-14" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Rotate the list removing the tail node and inserting it to the head. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listRotate</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    listNode *tail = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listLength(<span class="built_in">list</span>) &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Detach current tail */</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;tail = tail-&gt;prev;</span><br><span class="line">    <span class="built_in">list</span>-&gt;tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* Move it as head */</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;head-&gt;prev = tail;</span><br><span class="line">    tail-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    tail-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="built_in">list</span>-&gt;head = tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>redis</category>
        <category>source</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 源码分析-内存管理</title>
    <url>/2018/04/25/redis-source-memory/</url>
    <content><![CDATA[<p>在所有申请的指定长度的内存前加了一个<code>sizeof(size_t)</code>的长度<br>用于记录实际申请的内存长度,<br>方便统计内存使用占用和内存使用状态分析</p>
<h2 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h2><ul>
<li>zmalloc.h</li>
<li>zmalloc.c</li>
</ul>
<a id="more"></a>

<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul>
<li>RSS<br>  Resident Set Size,进程实际锁驻留在内存的空间大小,不包括交换区数据(swap)值<br>  RSS = Shared_Clean + Shared_Dirty + Private_Clean + Private_Dirty<ul>
<li>Shared_Clean<br>  多进程共享内存,且其内容未被任意进程修改</li>
<li>Shared_Dirty<br>  多进程共享内存,且其内容已经被某个程序修改</li>
<li>Private_Clean<br>  进程独享内存,且其内容未被修改</li>
<li>Private_Dirty<br>  进程独享内存,且其内容已经被修改</li>
</ul>
</li>
<li>内存碎片<ul>
<li>内部碎片<br>  已经被分配给程序进程的,不能被操作系统使用的内存</li>
<li>外部碎片<br>  没有分配给程序进程,但是因为连续空间过小导致无法使用的内存</li>
</ul>
</li>
<li><code>/proc/self/*</code>与<code>/proc/$pid/</code><br>  系统使用<code>self</code>来代替<code>$pid</code>,实际上两个目录一样的.不同的进程调用<code>self</code>是对应的文件夹连接就是自己的<code>$pid</code>文件夹连接</li>
<li>共享内存<br>  在Linux中主要是<code>.so</code>动态库文件,还有一些其他内容</li>
<li>内存对齐<br>  系统版本与CPU同时决定对齐的位数<br>  x86是4,x64是8<br>  gcc中申请的内存默认都是要对齐的,不足位数的需要凑齐为对齐位数的整数倍<br>  (可以使用<code>__attribute__ ((__packed__))</code>来强制不对齐)</li>
</ul>
<h2 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h2><h3 id="void-zmalloc-size-t-size"><a href="#void-zmalloc-size-t-size" class="headerlink" title="void *zmalloc(size_t size);"></a><code>void *zmalloc(size_t size);</code></h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>申请指定大小的内存,不会初始化</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> used_memory = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size+PREFIX_SIZE); <span class="comment">// `PREFIX_SIZE`就是`sizeof(size_t)`</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size); <span class="comment">// `zmalloc_oom_handler`是当`malloc`失败是Redis的处理机制</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE <span class="comment">// `HAVE_MALLOC_SIZE`在GCC中是0,不会定义</span></span></span><br><span class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    *((<span class="keyword">size_t</span>*)ptr) = size; <span class="comment">// 将申请的内存的开头用于记录申请的内存的大小(不包括记录这个长度所用的PREFIX_SIZE长度)</span></span><br><span class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE); <span class="comment">// 更新并记录当前使用的内存大小(实际是更新字段`used_memory`的值)</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE; <span class="comment">// 返回新申请的去掉记录长度的字符数组的指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="static-void-zmalloc-default-oom-size-t-size"><a href="#static-void-zmalloc-default-oom-size-t-size" class="headerlink" title="static void zmalloc_default_oom(size_t size);"></a><code>static void zmalloc_default_oom(size_t size);</code></h3><h4 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h4><p>Redis默认内存<code>Out Of Memory</code>的处理函数</p>
<h4 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zmalloc_default_oom</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;zmalloc: Out of memory trying to allocate %zu bytes\n&quot;</span>,</span><br><span class="line">        size); <span class="comment">// 记录申请了多少内存失败了</span></span><br><span class="line">    fflush(<span class="built_in">stderr</span>); <span class="comment">// 立刻写入日志系统</span></span><br><span class="line">    <span class="built_in">abort</span>(); <span class="comment">// 抛出异常,终止程序继续运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="define-update-zmalloc-stat-alloc-n"><a href="#define-update-zmalloc-stat-alloc-n" class="headerlink" title="#define update_zmalloc_stat_alloc(__n)"></a><code>#define update_zmalloc_stat_alloc(__n)</code></h3><h4 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h4><p>记录实际使用的内存的大小(增加)</p>
<h4 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_alloc(__n) do &#123; \</span></span><br><span class="line">    <span class="keyword">size_t</span> _n = (__n); \</span><br><span class="line">    <span class="keyword">if</span> (_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)); \ <span class="comment">// 这里是保证used_memory记录的申请的内存的尺寸是8的倍数(malloc本身已经保证申请的内存是8位对齐了)(另外在gcc中64位系统的size_t就是long unsigned int)</span></span><br><span class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) &#123; \ <span class="comment">// 是否启用线程安全功能</span></span><br><span class="line">        update_zmalloc_stat_add(_n); \ <span class="comment">// 以线程安全的方式增加used_memory</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; \</span><br><span class="line">        used_memory += _n; \ <span class="comment">// 不考虑线程安全直接增加used_memory</span></span><br><span class="line">    &#125; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>) <span class="comment">// 这种写法的两个好处:1:代替`&#123;&#125;`可以限制变量作用域;2:可以随时使用break来达到goto的效果</span></span><br></pre></td></tr></table></figure>

<h3 id="define-update-zmalloc-stat-add-n"><a href="#define-update-zmalloc-stat-add-n" class="headerlink" title="#define update_zmalloc_stat_add(__n)"></a><code>#define update_zmalloc_stat_add(__n)</code></h3><h4 id="功能-3"><a href="#功能-3" class="headerlink" title="功能"></a>功能</h4><p>保证线程安全的增加<code>used_memory</code></p>
<h4 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_add(__n) do &#123; \</span></span><br><span class="line">    pthread_mutex_lock(&amp;used_memory_mutex); \ <span class="comment">// 加锁</span></span><br><span class="line">    used_memory += (__n); \ <span class="comment">// 修改used_memory</span></span><br><span class="line">    pthread_mutex_unlock(&amp;used_memory_mutex); \ <span class="comment">// 解锁</span></span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="void-zcalloc-size-t-size"><a href="#void-zcalloc-size-t-size" class="headerlink" title="void *zcalloc(size_t size);"></a><code>void *zcalloc(size_t size);</code></h3><h4 id="功能-4"><a href="#功能-4" class="headerlink" title="功能"></a>功能</h4><p>同<code>zmalloc</code>一样,但是会将所申请的所有内存初始化为0</p>
<h4 id="源码-4"><a href="#源码-4" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zcalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">calloc</span>(<span class="number">1</span>, size+PREFIX_SIZE); <span class="comment">// 申请并清空带长度的连续内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size); <span class="comment">// 内存不足处理</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    *((<span class="keyword">size_t</span>*)ptr) = size; <span class="comment">// 记录实际数据长度(无PREFIX_SIZE长度)</span></span><br><span class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE); <span class="comment">// 记录实际内存申请数量</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE; <span class="comment">// 返回申请的地址指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="void-zrealloc-void-ptr-size-t-size"><a href="#void-zrealloc-void-ptr-size-t-size" class="headerlink" title="void *zrealloc(void *ptr, size_t size);"></a><code>void *zrealloc(void *ptr, size_t size);</code></h3><h4 id="功能-5"><a href="#功能-5" class="headerlink" title="功能"></a>功能</h4><p>重新分配指针的数据的长度,不会初始化新增数据</p>
<h4 id="源码-5"><a href="#源码-5" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zrealloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="keyword">void</span> *realptr; <span class="comment">// 声明ptr的实际指针(就是从记录长度的头地址开始计算)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">size_t</span> oldsize; <span class="comment">// 原始大小</span></span><br><span class="line">    <span class="keyword">void</span> *newptr; <span class="comment">// 新分配的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span> zmalloc(size); <span class="comment">// 如果原指针是空,则同重新申请地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE <span class="comment">// 特殊平台操作</span></span></span><br><span class="line">    oldsize = zmalloc_size(ptr);</span><br><span class="line">    newptr = <span class="built_in">realloc</span>(ptr,size);</span><br><span class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom_handler(size);</span><br><span class="line"></span><br><span class="line">    update_zmalloc_stat_free(oldsize);</span><br><span class="line">    update_zmalloc_stat_alloc(zmalloc_size(newptr));</span><br><span class="line">    <span class="keyword">return</span> newptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE; <span class="comment">// 获取实际指针</span></span><br><span class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr); <span class="comment">// 获取实际指针指向的数据长度</span></span><br><span class="line">    newptr = <span class="built_in">realloc</span>(realptr,size+PREFIX_SIZE); <span class="comment">// 重新非配指针所指的连续内存的大小(分两种情况,1:新需要内存比原内存小或一样,则数据截断;3:新数据长度比旧数据长度长,则申请新数据长度的连续内存,将旧数据按顺序拷贝到新地址中,自动释放旧数据地址指针,返回新地址指针)</span></span><br><span class="line">    <span class="keyword">if</span> (!newptr) zmalloc_oom_handler(size); <span class="comment">// 内存分配失败处理</span></span><br><span class="line"></span><br><span class="line">    *((<span class="keyword">size_t</span>*)newptr) = size; <span class="comment">// 记录新长度</span></span><br><span class="line">    update_zmalloc_stat_free(oldsize); <span class="comment">// 维护used_memory长度(没有PREFIX_SIZE的原因是一减一增无需处理,是减少计算的优化)</span></span><br><span class="line">    update_zmalloc_stat_alloc(size); <span class="comment">// 维护used_memory长度</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)newptr+PREFIX_SIZE; <span class="comment">// 返回新指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="define-update-zmalloc-stat-free-n"><a href="#define-update-zmalloc-stat-free-n" class="headerlink" title="#define update_zmalloc_stat_free(__n)"></a><code>#define update_zmalloc_stat_free(__n)</code></h3><h4 id="功能-6"><a href="#功能-6" class="headerlink" title="功能"></a>功能</h4><p>记录实际使用的内存的大小(减少)</p>
<h4 id="源码-6"><a href="#源码-6" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_free(__n) do &#123; \</span></span><br><span class="line">    <span class="keyword">size_t</span> _n = (__n); \ <span class="comment">// 记录实际使用的内存</span></span><br><span class="line">    <span class="keyword">if</span> (_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)); \ <span class="comment">// 保证内存的对齐</span></span><br><span class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) &#123; \ <span class="comment">// 是否启用线程安全接口</span></span><br><span class="line">        update_zmalloc_stat_sub(_n); \ <span class="comment">// 线程安全的减少used_memory</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; \ <span class="comment">// 非线程安全操作</span></span><br><span class="line">        used_memory -= _n; \ <span class="comment">// 减少used_memory</span></span><br><span class="line">    &#125; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="define-update-zmalloc-stat-sub-n"><a href="#define-update-zmalloc-stat-sub-n" class="headerlink" title="#define update_zmalloc_stat_sub(__n)"></a><code>#define update_zmalloc_stat_sub(__n)</code></h3><h4 id="功能-7"><a href="#功能-7" class="headerlink" title="功能"></a>功能</h4><p>保证线程安全的减小<code>used_memory</code></p>
<h4 id="源码-7"><a href="#源码-7" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_sub(__n) do &#123; \</span></span><br><span class="line">    pthread_mutex_lock(&amp;used_memory_mutex); \ <span class="comment">// 上锁</span></span><br><span class="line">    used_memory -= (__n); \ <span class="comment">// 减少used_memory</span></span><br><span class="line">    pthread_mutex_unlock(&amp;used_memory_mutex); \ <span class="comment">// 解锁</span></span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="void-zfree-void-ptr"><a href="#void-zfree-void-ptr" class="headerlink" title="void zfree(void *ptr);"></a><code>void zfree(void *ptr);</code></h3><h4 id="功能-8"><a href="#功能-8" class="headerlink" title="功能"></a>功能</h4><p>释放指针空间</p>
<h4 id="源码-8"><a href="#源码-8" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zfree</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="keyword">void</span> *realptr; <span class="comment">// 实际指针</span></span><br><span class="line">    <span class="keyword">size_t</span> oldsize; <span class="comment">// 实际指针数据长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) <span class="keyword">return</span>; <span class="comment">// 空指针直接返回</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    update_zmalloc_stat_free(zmalloc_size(ptr));</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE; <span class="comment">// 获取实际指针</span></span><br><span class="line">    oldsize = *((<span class="keyword">size_t</span>*)realptr); <span class="comment">// 获取实际指针数据长度</span></span><br><span class="line">    update_zmalloc_stat_free(oldsize+PREFIX_SIZE); <span class="comment">// 维护used_memory,减少实际使用内存的记录值</span></span><br><span class="line">    <span class="built_in">free</span>(realptr); <span class="comment">// 释放实际指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="char-zstrdup-const-char-s"><a href="#char-zstrdup-const-char-s" class="headerlink" title="char *zstrdup(const char *s);"></a><code>char *zstrdup(const char *s);</code></h3><h4 id="功能-9"><a href="#功能-9" class="headerlink" title="功能"></a>功能</h4><p>字符串复制(因为复制的原始字符串结尾是什么,这里复制出的字符串结尾就是什么(一定是<code>\0</code>))</p>
<h4 id="源码-9"><a href="#源码-9" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">zstrdup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> l = <span class="built_in">strlen</span>(s)+<span class="number">1</span>; <span class="comment">// 获取字符串长度+1</span></span><br><span class="line">    <span class="keyword">char</span> *p = zmalloc(l); <span class="comment">// 申请新的连续内存</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(p,s,l); <span class="comment">// 复制字符串</span></span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">// 返回新的字符串指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="size-t-zmalloc-used-memory-void"><a href="#size-t-zmalloc-used-memory-void" class="headerlink" title="size_t zmalloc_used_memory(void);"></a><code>size_t zmalloc_used_memory(void);</code></h3><h4 id="功能-10"><a href="#功能-10" class="headerlink" title="功能"></a>功能</h4><p>获取当前已经使用的内存大小(字节)(used_memory的值)</p>
<h4 id="源码-10"><a href="#源码-10" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_used_memory</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> um;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zmalloc_thread_safe) &#123; <span class="comment">// 是否使用线程安全接口</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__ATOMIC_RELAXED) || defined(HAVE_ATOMIC)</span></span><br><span class="line">        um = update_zmalloc_stat_add(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        pthread_mutex_lock(&amp;used_memory_mutex); <span class="comment">// 上锁</span></span><br><span class="line">        um = used_memory; <span class="comment">// 复制</span></span><br><span class="line">        pthread_mutex_unlock(&amp;used_memory_mutex); <span class="comment">// 解锁</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 非线程安全</span></span><br><span class="line">        um = used_memory; <span class="comment">// 复制</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> um; <span class="comment">// 返回当前内存用量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void-zmalloc-enable-thread-safeness-void"><a href="#void-zmalloc-enable-thread-safeness-void" class="headerlink" title="void zmalloc_enable_thread_safeness(void);"></a><code>void zmalloc_enable_thread_safeness(void);</code></h3><h4 id="功能-11"><a href="#功能-11" class="headerlink" title="功能"></a>功能</h4><p>开启内存用量记录的线程安全模式(开启后所有内存用量记录都会上锁)</p>
<h4 id="源码-11"><a href="#源码-11" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> zmalloc_thread_safe = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zmalloc_enable_thread_safeness</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    zmalloc_thread_safe = <span class="number">1</span>; <span class="comment">// 标记为真</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void-zmalloc-set-oom-handler-void-oom-handler-size-t"><a href="#void-zmalloc-set-oom-handler-void-oom-handler-size-t" class="headerlink" title="void zmalloc_set_oom_handler(void (*oom_handler)(size_t));"></a><code>void zmalloc_set_oom_handler(void (*oom_handler)(size_t));</code></h3><h4 id="功能-12"><a href="#功能-12" class="headerlink" title="功能"></a>功能</h4><p>设置内存溢出触发时的回调函数</p>
<h4 id="源码-12"><a href="#源码-12" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*zmalloc_oom_handler)</span><span class="params">(<span class="keyword">size_t</span>)</span> </span>= zmalloc_default_oom;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zmalloc_set_oom_handler</span><span class="params">(<span class="keyword">void</span> (*oom_handler)(<span class="keyword">size_t</span>))</span> </span>&#123;</span><br><span class="line">    zmalloc_oom_handler = oom_handler; <span class="comment">// 设置函数指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="float-zmalloc-get-fragmentation-ratio-size-t-rss"><a href="#float-zmalloc-get-fragmentation-ratio-size-t-rss" class="headerlink" title="float zmalloc_get_fragmentation_ratio(size_t rss);"></a><code>float zmalloc_get_fragmentation_ratio(size_t rss);</code></h3><h4 id="功能-13"><a href="#功能-13" class="headerlink" title="功能"></a>功能</h4><p>获取当前Redis的内存碎片率(内部碎片)</p>
<h4 id="源码-13"><a href="#源码-13" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">zmalloc_get_fragmentation_ratio</span><span class="params">(<span class="keyword">size_t</span> rss)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">float</span>)rss/zmalloc_used_memory(); <span class="comment">// rss是程序占用的所有内存(文件内存+匿名内存)(包含共享内存)(rss内存有重复统计的可能);zmalloc_used_memory就是实际redis通过命令分配出去的内存大小;这里的rss值使用过`serverCron`函数循环调用更新的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="size-t-zmalloc-get-rss-void"><a href="#size-t-zmalloc-get-rss-void" class="headerlink" title="size_t zmalloc_get_rss(void);"></a><code>size_t zmalloc_get_rss(void);</code></h3><h4 id="功能-14"><a href="#功能-14" class="headerlink" title="功能"></a>功能</h4><p>通过系统信息截取到当前Redis使用的RSS(Resident Set Size)(进程实际所驻留在内存的空间大小,不包括交换区数据(swap))值</p>
<h4 id="源码-14"><a href="#源码-14" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_rss</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> page = sysconf(_SC_PAGESIZE); <span class="comment">// 获取单个页面大小</span></span><br><span class="line">    <span class="keyword">size_t</span> rss; <span class="comment">// 声明rss</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4096</span>]; <span class="comment">// 数据缓冲</span></span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">256</span>]; <span class="comment">// 文件名</span></span><br><span class="line">    <span class="keyword">int</span> fd, count;</span><br><span class="line">    <span class="keyword">char</span> *p, *x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(filename,<span class="number">256</span>,<span class="string">&quot;/proc/%d/stat&quot;</span>,getpid()); <span class="comment">// 拼接Redis的相关进程状态文件名</span></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(filename,O_RDONLY)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 打开状态文件</span></span><br><span class="line">    <span class="keyword">if</span> (read(fd,buf,<span class="number">4096</span>) &lt;= <span class="number">0</span>) &#123; <span class="comment">// 读取全部状态文件</span></span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd); <span class="comment">// 关闭fd</span></span><br><span class="line"></span><br><span class="line">    p = buf;</span><br><span class="line">    count = <span class="number">23</span>; <span class="comment">/* RSS is the 24th field in /proc/&lt;pid&gt;/stat */</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; count--) &#123; <span class="comment">// 获取文件中的rss的页面数量</span></span><br><span class="line">        p = <span class="built_in">strchr</span>(p,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (p) p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    x = <span class="built_in">strchr</span>(p,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    *x = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    rss = strtoll(p,<span class="literal">NULL</span>,<span class="number">10</span>); <span class="comment">// 字符串转数字(10进制)</span></span><br><span class="line">    rss *= page; <span class="comment">// 程序占用总内存=单个页面尺寸*页面总数</span></span><br><span class="line">    <span class="keyword">return</span> rss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="size-t-zmalloc-get-private-dirty-void"><a href="#size-t-zmalloc-get-private-dirty-void" class="headerlink" title="size_t zmalloc_get_private_dirty(void);"></a><code>size_t zmalloc_get_private_dirty(void);</code></h3><h4 id="功能-15"><a href="#功能-15" class="headerlink" title="功能"></a>功能</h4><p>获取当前Redis所有私有的已实际使用过的内存的大小(字节)</p>
<h4 id="源码-15"><a href="#源码-15" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_private_dirty</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> zmalloc_get_smap_bytes_by_field(<span class="string">&quot;Private_Dirty:&quot;</span>); <span class="comment">// 获取&quot;Private_Dirty&quot;字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="size-t-zmalloc-get-smap-bytes-by-field-char-field"><a href="#size-t-zmalloc-get-smap-bytes-by-field-char-field" class="headerlink" title="size_t zmalloc_get_smap_bytes_by_field(char *field);"></a><code>size_t zmalloc_get_smap_bytes_by_field(char *field);</code></h3><h4 id="功能-16"><a href="#功能-16" class="headerlink" title="功能"></a>功能</h4><p>根据参数字段,在<code>/proc/self/smaps</code>中(就是当前进程的smaps文件)中查找对应的属性的值</p>
<h4 id="源码-16"><a href="#源码-16" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_smap_bytes_by_field</span><span class="params">(<span class="keyword">char</span> *field)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> line[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">size_t</span> bytes = <span class="number">0</span>;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;/proc/self/smaps&quot;</span>,<span class="string">&quot;r&quot;</span>); <span class="comment">// 打开状态文件</span></span><br><span class="line">    <span class="keyword">int</span> flen = <span class="built_in">strlen</span>(field);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fp) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(fgets(line,<span class="keyword">sizeof</span>(line),fp) != <span class="literal">NULL</span>) &#123; <span class="comment">// 逐行读取</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(line,field,flen) == <span class="number">0</span>) &#123; <span class="comment">// 查找字段</span></span><br><span class="line">            <span class="keyword">char</span> *p = <span class="built_in">strchr</span>(line,<span class="string">&#x27;k&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (p) &#123;</span><br><span class="line">                *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                bytes += strtol(line+flen,<span class="literal">NULL</span>,<span class="number">10</span>) * <span class="number">1024</span>; <span class="comment">// 将字符串转化为数字并从`kb`转化成`byte`</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp); <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="size-t-zmalloc-get-memory-size-void"><a href="#size-t-zmalloc-get-memory-size-void" class="headerlink" title="size_t zmalloc_get_memory_size(void);"></a><code>size_t zmalloc_get_memory_size(void);</code></h3><h4 id="功能-17"><a href="#功能-17" class="headerlink" title="功能"></a>功能</h4><p>简洁的获得物理内存尺寸(单位:字节)(跨平台)</p>
<h4 id="源码-17"><a href="#源码-17" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_get_memory_size</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__unix__) || defined(__unix) || defined(unix) || \</span></span><br><span class="line">    (defined(__APPLE__) &amp;&amp; defined(__MACH__))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CTL_HW) &amp;&amp; (defined(HW_MEMSIZE) || defined(HW_PHYSMEM64))</span></span><br><span class="line">    <span class="keyword">int</span> mib[<span class="number">2</span>];</span><br><span class="line">    mib[<span class="number">0</span>] = CTL_HW;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(HW_MEMSIZE)</span></span><br><span class="line">    mib[<span class="number">1</span>] = HW_MEMSIZE;            <span class="comment">/* OSX. --------------------- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(HW_PHYSMEM64)</span></span><br><span class="line">    mib[<span class="number">1</span>] = HW_PHYSMEM64;          <span class="comment">/* NetBSD, OpenBSD. --------- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int64_t</span> size = <span class="number">0</span>;               <span class="comment">/* 64-bit */</span></span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="keyword">sizeof</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (sysctl( mib, <span class="number">2</span>, &amp;size, &amp;len, <span class="literal">NULL</span>, <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">size_t</span>)size;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>;          <span class="comment">/* Failed? */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_SC_PHYS_PAGES) &amp;&amp; defined(_SC_PAGESIZE)</span></span><br><span class="line">    <span class="comment">/* FreeBSD, Linux, OpenBSD, and Solaris. -------------------- */</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">size_t</span>)sysconf(_SC_PHYS_PAGES) * (<span class="keyword">size_t</span>)sysconf(_SC_PAGESIZE);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(CTL_HW) &amp;&amp; (defined(HW_PHYSMEM) || defined(HW_REALMEM))</span></span><br><span class="line">    <span class="comment">/* DragonFly BSD, FreeBSD, NetBSD, OpenBSD, and OSX. -------- */</span></span><br><span class="line">    <span class="keyword">int</span> mib[<span class="number">2</span>];</span><br><span class="line">    mib[<span class="number">0</span>] = CTL_HW;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(HW_REALMEM)</span></span><br><span class="line">    mib[<span class="number">1</span>] = HW_REALMEM;        <span class="comment">/* FreeBSD. ----------------- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(HW_PYSMEM)</span></span><br><span class="line">    mib[<span class="number">1</span>] = HW_PHYSMEM;        <span class="comment">/* Others. ------------------ */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = <span class="number">0</span>;      <span class="comment">/* 32-bit */</span></span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="keyword">sizeof</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (sysctl(mib, <span class="number">2</span>, &amp;size, &amp;len, <span class="literal">NULL</span>, <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">size_t</span>)size;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>;          <span class="comment">/* Failed? */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>;          <span class="comment">/* Unknown method to get the data. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>;          <span class="comment">/* Unknown OS. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void-zlibc-free-void-ptr"><a href="#void-zlibc-free-void-ptr" class="headerlink" title="void zlibc_free(void *ptr);"></a><code>void zlibc_free(void *ptr);</code></h3><h4 id="功能-18"><a href="#功能-18" class="headerlink" title="功能"></a>功能</h4><p>libc的free的封装(This is useful for instance to free results obtained by backtrace_symbols())</p>
<h4 id="源码-18"><a href="#源码-18" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zlibc_free</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="size-t-zmalloc-size-void-ptr"><a href="#size-t-zmalloc-size-void-ptr" class="headerlink" title="size_t zmalloc_size(void *ptr)"></a><code>size_t zmalloc_size(void *ptr)</code></h3><h4 id="功能-19"><a href="#功能-19" class="headerlink" title="功能"></a>功能</h4><p>获取按位对齐后的实际指针所占用的总内存量</p>
<h4 id="源码-19"><a href="#源码-19" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zmalloc_size</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *realptr = (<span class="keyword">char</span>*)ptr-PREFIX_SIZE;</span><br><span class="line">    <span class="keyword">size_t</span> size = *((<span class="keyword">size_t</span>*)realptr);</span><br><span class="line">    <span class="comment">/* Assume at least that all the allocations are padded at sizeof(long) by</span></span><br><span class="line"><span class="comment">     * the underlying allocator. */</span></span><br><span class="line">    <span class="keyword">if</span> (size&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) size += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(size&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> size+PREFIX_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>redis</category>
        <category>source</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 源码分析-压缩map</title>
    <url>/2018/05/02/redis-source-zipmap/</url>
    <content><![CDATA[<p>本质上就是<code>char*</code>字符串<br>通过指定的格式排列的数据结构<br>基本格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;zmlen&gt;	&#x2F;&#x2F; 当zmlen小于254时,记录的是键值对的个数,当等于254时,表示需要遍历整个zipmap才能指导具体的长度</span><br><span class="line">		&lt;len&gt;$key1&lt;len&gt;&lt;free&gt;$value1	&#x2F;&#x2F; 键长度-&gt;键-&gt;值长度-&gt;1字节无用空间长度-&gt;无用空间-&gt;值(无用空间在代码中貌似不太对,有的地方有用,有的地方没有用(关于free的代码都不完善,没有统一),应该是所有使用的地方,无用空间长度都是0)</span><br><span class="line">		&lt;len&gt;$key2&lt;len&gt;&lt;free&gt;$value2</span><br><span class="line">		...</span><br><span class="line">&lt;255&gt; &#x2F;&#x2F; zipmap结尾</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPMAP_BIGLEN 254 <span class="comment">// zm的长度上限,当数据长度超过254时,使用254标记,并将后4(根据unsigned int长度变化)为记录为数据长度</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPMAP_END 255 <span class="comment">// zm的结尾标记</span></span></span><br></pre></td></tr></table></figure>

<h2 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h2><ul>
<li>zipmap.h</li>
<li>zipmap.c</li>
</ul>
<a id="more"></a>

<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul>
<li><code>void *memmove( void* dest, const void* src, size_t count );</code><br>  memmove用于从src拷贝count个字节到dest，如果目标区域和源区域有重叠的话，memmove能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中。但复制后src内容会被更改。但是当目标区域与源区域没有重叠则和memcpy函数功能相同。</li>
</ul>
<h2 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h2><h3 id="unsigned-char-zipmapNew-void"><a href="#unsigned-char-zipmapNew-void" class="headerlink" title="unsigned char *zipmapNew(void);"></a><code>unsigned char *zipmapNew(void);</code></h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>创建一个空的zipmap</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create a new empty zipmap. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">zipmapNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zm = zmalloc(<span class="number">2</span>); <span class="comment">// 只有开始,结束两个标记位</span></span><br><span class="line"></span><br><span class="line">    zm[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">/* Length */</span></span><br><span class="line">    zm[<span class="number">1</span>] = ZIPMAP_END;</span><br><span class="line">    <span class="keyword">return</span> zm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unsigned-char-zipmapSet-unsigned-char-zm-unsigned-char-key-unsigned-int-klen-unsigned-char-val-unsigned-int-vlen-int-update"><a href="#unsigned-char-zipmapSet-unsigned-char-zm-unsigned-char-key-unsigned-int-klen-unsigned-char-val-unsigned-int-vlen-int-update" class="headerlink" title="unsigned char *zipmapSet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char *val, unsigned int vlen, int *update);"></a><code>unsigned char *zipmapSet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char *val, unsigned int vlen, int *update);</code></h3><h4 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h4><p>insert/update(merge)功能,新增或者修改值</p>
<h4 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set key to value, creating the key if it does not already exist.</span></span><br><span class="line"><span class="comment"> * If &#x27;update&#x27; is not NULL, *update is set to 1 if the key was</span></span><br><span class="line"><span class="comment"> * already preset, otherwise to 0. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">zipmapSet</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zm, <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">unsigned</span> <span class="keyword">int</span> klen, <span class="keyword">unsigned</span> <span class="keyword">char</span> *val, <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen, <span class="keyword">int</span> *update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> zmlen, offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> freelen, reqlen = zipmapRequiredLength(klen,vlen); <span class="comment">// 获取到实际需要使用的内存的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> empty, vempty;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line"></span><br><span class="line">    freelen = reqlen;</span><br><span class="line">    <span class="keyword">if</span> (update) *update = <span class="number">0</span>;</span><br><span class="line">    p = zipmapLookupRaw(zm,key,klen,&amp;zmlen); <span class="comment">// 查找获取需要更新的key的指针</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123; <span class="comment">// 没有找到,新增</span></span><br><span class="line">        <span class="comment">/* Key not found: enlarge */</span></span><br><span class="line">        zm = zipmapResize(zm, zmlen+reqlen);</span><br><span class="line">        p = zm+zmlen<span class="number">-1</span>;</span><br><span class="line">        zmlen = zmlen+reqlen;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Increase zipmap length (this is an insert) */</span></span><br><span class="line">        <span class="keyword">if</span> (zm[<span class="number">0</span>] &lt; ZIPMAP_BIGLEN) zm[<span class="number">0</span>]++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Key found. Is there enough space for the new value? */</span></span><br><span class="line">        <span class="comment">/* Compute the total length: */</span></span><br><span class="line">        <span class="keyword">if</span> (update) *update = <span class="number">1</span>; <span class="comment">// 标记是更新,不是新增</span></span><br><span class="line">        freelen = zipmapRawEntryLength(p); <span class="comment">// 获取到原始键值对的总长度</span></span><br><span class="line">        <span class="keyword">if</span> (freelen &lt; reqlen) &#123; <span class="comment">// 当前zipmap长度不够,需要扩展</span></span><br><span class="line">            <span class="comment">/* Store the offset of this key within the current zipmap, so</span></span><br><span class="line"><span class="comment">             * it can be resized. Then, move the tail backwards so this</span></span><br><span class="line"><span class="comment">             * pair fits at the current position. */</span></span><br><span class="line">            offset = p-zm;</span><br><span class="line">            zm = zipmapResize(zm, zmlen-freelen+reqlen); <span class="comment">// 扩展空间</span></span><br><span class="line">            p = zm+offset;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* The +1 in the number of bytes to be moved is caused by the</span></span><br><span class="line"><span class="comment">             * end-of-zipmap byte. Note: the *original* zmlen is used. */</span></span><br><span class="line">            memmove(p+reqlen, p+freelen, zmlen-(offset+freelen+<span class="number">1</span>)); <span class="comment">// 将旧数据去掉,后面的数据前移</span></span><br><span class="line">            zmlen = zmlen-freelen+reqlen;</span><br><span class="line">            freelen = reqlen;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We now have a suitable block where the key/value entry can</span></span><br><span class="line"><span class="comment">     * be written. If there is too much free space, move the tail</span></span><br><span class="line"><span class="comment">     * of the zipmap a few bytes to the front and shrink the zipmap,</span></span><br><span class="line"><span class="comment">     * as we want zipmaps to be very space efficient. */</span></span><br><span class="line">    empty = freelen-reqlen; <span class="comment">// 这里永远是0,所以数据结构中的`free`实际上完全没有使用</span></span><br><span class="line">    <span class="keyword">if</span> (empty &gt;= ZIPMAP_VALUE_MAX_FREE) &#123;</span><br><span class="line">        <span class="comment">/* First, move the tail &lt;empty&gt; bytes to the front, then resize</span></span><br><span class="line"><span class="comment">         * the zipmap to be &lt;empty&gt; bytes smaller. */</span></span><br><span class="line">        offset = p-zm;</span><br><span class="line">        memmove(p+reqlen, p+freelen, zmlen-(offset+freelen+<span class="number">1</span>));</span><br><span class="line">        zmlen -= empty;</span><br><span class="line">        zm = zipmapResize(zm, zmlen);</span><br><span class="line">        p = zm+offset;</span><br><span class="line">        vempty = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vempty = empty;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Just write the key + value and we are done. */</span></span><br><span class="line">    <span class="comment">/* Key: */</span></span><br><span class="line">    p += zipmapEncodeLength(p,klen); <span class="comment">// 写键长度</span></span><br><span class="line">    <span class="built_in">memcpy</span>(p,key,klen); <span class="comment">// 复制键</span></span><br><span class="line">    p += klen; <span class="comment">// 指针后移</span></span><br><span class="line">    <span class="comment">/* Value: */</span></span><br><span class="line">    p += zipmapEncodeLength(p,vlen); <span class="comment">// 写值长度</span></span><br><span class="line">    *p++ = vempty; <span class="comment">// 写free的长度(就是0,后面连按照free长度写空字节的代码都没有,如果free真有意义,这里就有逻辑问题了)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(p,val,vlen); <span class="comment">// 复制值</span></span><br><span class="line">    <span class="keyword">return</span> zm; <span class="comment">// 返回新的zipmap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unsigned-char-zipmapDel-unsigned-char-zm-unsigned-char-key-unsigned-int-klen-int-deleted"><a href="#unsigned-char-zipmapDel-unsigned-char-zm-unsigned-char-key-unsigned-int-klen-int-deleted" class="headerlink" title="unsigned char *zipmapDel(unsigned char *zm, unsigned char *key, unsigned int klen, int *deleted);"></a><code>unsigned char *zipmapDel(unsigned char *zm, unsigned char *key, unsigned int klen, int *deleted);</code></h3><h4 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h4><p>删除指定键值对</p>
<h4 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Remove the specified key. If &#x27;deleted&#x27; is not NULL the pointed integer is</span></span><br><span class="line"><span class="comment"> * set to 0 if the key was not found, to 1 if it was found and deleted. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">zipmapDel</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zm, <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">unsigned</span> <span class="keyword">int</span> klen, <span class="keyword">int</span> *deleted)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> zmlen, freelen;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = zipmapLookupRaw(zm,key,klen,&amp;zmlen); <span class="comment">// 找到key的起始位置</span></span><br><span class="line">    <span class="keyword">if</span> (p) &#123; <span class="comment">// 找到了</span></span><br><span class="line">        freelen = zipmapRawEntryLength(p); <span class="comment">// 获取整体的键值对长度</span></span><br><span class="line">        memmove(p, p+freelen, zmlen-((p-zm)+freelen+<span class="number">1</span>)); <span class="comment">// 后面的前移覆盖</span></span><br><span class="line">        zm = zipmapResize(zm, zmlen-freelen); <span class="comment">// 重新分配内存使用大小</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Decrease zipmap length */</span></span><br><span class="line">        <span class="keyword">if</span> (zm[<span class="number">0</span>] &lt; ZIPMAP_BIGLEN) zm[<span class="number">0</span>]--; <span class="comment">// 更新头部的长度记录</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (deleted) *deleted = <span class="number">1</span>; <span class="comment">// 标记已找到</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 没找到</span></span><br><span class="line">        <span class="keyword">if</span> (deleted) *deleted = <span class="number">0</span>; <span class="comment">// 标记未找到</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> zm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unsigned-char-zipmapRewind-unsigned-char-zm"><a href="#unsigned-char-zipmapRewind-unsigned-char-zm" class="headerlink" title="unsigned char *zipmapRewind(unsigned char *zm);"></a><code>unsigned char *zipmapRewind(unsigned char *zm);</code></h3><h4 id="功能-3"><a href="#功能-3" class="headerlink" title="功能"></a>功能</h4><p>跳过zm开头的长度记录字节,遍历用的统一起始接口</p>
<h4 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Call before iterating through elements via zipmapNext() */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">zipmapRewind</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> zm+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unsigned-char-zipmapNext-unsigned-char-zm-unsigned-char-key-unsigned-int-klen-unsigned-char-value-unsigned-int-vlen"><a href="#unsigned-char-zipmapNext-unsigned-char-zm-unsigned-char-key-unsigned-int-klen-unsigned-char-value-unsigned-int-vlen" class="headerlink" title="unsigned char *zipmapNext(unsigned char *zm, unsigned char **key, unsigned int *klen, unsigned char **value, unsigned int *vlen);"></a><code>unsigned char *zipmapNext(unsigned char *zm, unsigned char **key, unsigned int *klen, unsigned char **value, unsigned int *vlen);</code></h3><h4 id="功能-4"><a href="#功能-4" class="headerlink" title="功能"></a>功能</h4><p>遍历,获取下一个数据,无数据则返回空</p>
<h4 id="源码-4"><a href="#源码-4" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This function is used to iterate through all the zipmap elements.</span></span><br><span class="line"><span class="comment"> * In the first call the first argument is the pointer to the zipmap + 1.</span></span><br><span class="line"><span class="comment"> * In the next calls what zipmapNext returns is used as first argument.</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * unsigned char *i = zipmapRewind(my_zipmap);</span></span><br><span class="line"><span class="comment"> * while((i = zipmapNext(i,&amp;key,&amp;klen,&amp;value,&amp;vlen)) != NULL) &#123;</span></span><br><span class="line"><span class="comment"> *     printf(&quot;%d bytes key at $p\n&quot;, klen, key);</span></span><br><span class="line"><span class="comment"> *     printf(&quot;%d bytes value at $p\n&quot;, vlen, value);</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">zipmapNext</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zm, <span class="keyword">unsigned</span> <span class="keyword">char</span> **key, <span class="keyword">unsigned</span> <span class="keyword">int</span> *klen, <span class="keyword">unsigned</span> <span class="keyword">char</span> **value, <span class="keyword">unsigned</span> <span class="keyword">int</span> *vlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (zm[<span class="number">0</span>] == ZIPMAP_END) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 结尾返回空</span></span><br><span class="line">    <span class="keyword">if</span> (key) &#123;</span><br><span class="line">        *key = zm; <span class="comment">// 记录键的起始指针</span></span><br><span class="line">        *klen = zipmapDecodeLength(zm); <span class="comment">// 获取键的长度</span></span><br><span class="line">        *key += ZIPMAP_LEN_BYTES(*klen); <span class="comment">// 获取实际键的偏移指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    zm += zipmapRawKeyLength(zm); <span class="comment">// 过掉键字段</span></span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        *value = zm+<span class="number">1</span>; <span class="comment">// 获取到值的首地址</span></span><br><span class="line">        *vlen = zipmapDecodeLength(zm); <span class="comment">// 获取值的长度</span></span><br><span class="line">        *value += ZIPMAP_LEN_BYTES(*vlen); <span class="comment">// 获取值的实际偏移指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    zm += zipmapRawValueLength(zm); <span class="comment">// 过掉值字段</span></span><br><span class="line">    <span class="keyword">return</span> zm; <span class="comment">// 返回偏移后的zipmap数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int-zipmapGet-unsigned-char-zm-unsigned-char-key-unsigned-int-klen-unsigned-char-value-unsigned-int-vlen"><a href="#int-zipmapGet-unsigned-char-zm-unsigned-char-key-unsigned-int-klen-unsigned-char-value-unsigned-int-vlen" class="headerlink" title="int zipmapGet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char **value, unsigned int *vlen);"></a><code>int zipmapGet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char **value, unsigned int *vlen);</code></h3><h4 id="功能-5"><a href="#功能-5" class="headerlink" title="功能"></a>功能</h4><p>根据键,获取值,返回是否找到</p>
<h4 id="源码-5"><a href="#源码-5" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Search a key and retrieve the pointer and len of the associated value.</span></span><br><span class="line"><span class="comment"> * If the key is found the function returns 1, otherwise 0. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zipmapGet</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zm, <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">unsigned</span> <span class="keyword">int</span> klen, <span class="keyword">unsigned</span> <span class="keyword">char</span> **value, <span class="keyword">unsigned</span> <span class="keyword">int</span> *vlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((p = zipmapLookupRaw(zm,key,klen,<span class="literal">NULL</span>)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 查找键的位置</span></span><br><span class="line">    p += zipmapRawKeyLength(p); <span class="comment">// 跳过键的整体长度</span></span><br><span class="line">    *vlen = zipmapDecodeLength(p); <span class="comment">// 获取值的长度</span></span><br><span class="line">    *value = p + ZIPMAP_LEN_BYTES(*vlen) + <span class="number">1</span>; <span class="comment">// 获取值的指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int-zipmapExists-unsigned-char-zm-unsigned-char-key-unsigned-int-klen"><a href="#int-zipmapExists-unsigned-char-zm-unsigned-char-key-unsigned-int-klen" class="headerlink" title="int zipmapExists(unsigned char *zm, unsigned char *key, unsigned int klen);"></a><code>int zipmapExists(unsigned char *zm, unsigned char *key, unsigned int klen);</code></h3><h4 id="功能-6"><a href="#功能-6" class="headerlink" title="功能"></a>功能</h4><p>判断键是否存在</p>
<h4 id="源码-6"><a href="#源码-6" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Return 1 if the key exists, otherwise 0 is returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zipmapExists</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zm, <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">unsigned</span> <span class="keyword">int</span> klen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> zipmapLookupRaw(zm,key,klen,<span class="literal">NULL</span>) != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unsigned-int-zipmapLen-unsigned-char-zm"><a href="#unsigned-int-zipmapLen-unsigned-char-zm" class="headerlink" title="unsigned int zipmapLen(unsigned char *zm);"></a><code>unsigned int zipmapLen(unsigned char *zm);</code></h3><h4 id="功能-7"><a href="#功能-7" class="headerlink" title="功能"></a>功能</h4><p>获取zipmap的长度<br>zm[0] &lt; ZIPMAP_BIGLEN则取首地址值,否则遍历计算</p>
<h4 id="源码-7"><a href="#源码-7" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Return the number of entries inside a zipmap */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipmapLen</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (zm[<span class="number">0</span>] &lt; ZIPMAP_BIGLEN) &#123;</span><br><span class="line">        len = zm[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = zipmapRewind(zm);</span><br><span class="line">        <span class="keyword">while</span>((p = zipmapNext(p,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>)) != <span class="literal">NULL</span>) len++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Re-store length if small enough */</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; ZIPMAP_BIGLEN) zm[<span class="number">0</span>] = len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="size-t-zipmapBlobLen-unsigned-char-zm"><a href="#size-t-zipmapBlobLen-unsigned-char-zm" class="headerlink" title="size_t zipmapBlobLen(unsigned char *zm);"></a><code>size_t zipmapBlobLen(unsigned char *zm);</code></h3><h4 id="功能-8"><a href="#功能-8" class="headerlink" title="功能"></a>功能</h4><p>获取zipmap所占的所有字节数(从头到结束)</p>
<h4 id="源码-8"><a href="#源码-8" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Return the raw size in bytes of a zipmap, so that we can serialize</span></span><br><span class="line"><span class="comment"> * the zipmap on disk (or everywhere is needed) just writing the returned</span></span><br><span class="line"><span class="comment"> * amount of bytes of the C array starting at the zipmap pointer. */</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">zipmapBlobLen</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> totlen;</span><br><span class="line">    zipmapLookupRaw(zm,<span class="literal">NULL</span>,<span class="number">0</span>,&amp;totlen); <span class="comment">// 这里不需要查找键值对,只需要统计总字节数</span></span><br><span class="line">    <span class="keyword">return</span> totlen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="static-unsigned-int-zipmapDecodeLength-unsigned-char-p"><a href="#static-unsigned-int-zipmapDecodeLength-unsigned-char-p" class="headerlink" title="static unsigned int zipmapDecodeLength(unsigned char *p);"></a><code>static unsigned int zipmapDecodeLength(unsigned char *p);</code></h3><h4 id="功能-9"><a href="#功能-9" class="headerlink" title="功能"></a>功能</h4><p>通用的获取长度值的方法</p>
<h4 id="源码-9"><a href="#源码-9" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Decode the encoded length pointed by &#x27;p&#x27; */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipmapDecodeLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len = *p; <span class="comment">// 获取首地址值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt; ZIPMAP_BIGLEN) <span class="keyword">return</span> len; <span class="comment">// 小于254,直接返回</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;len,p+<span class="number">1</span>,<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>)); <span class="comment">// 获取后4(动态)位</span></span><br><span class="line">    memrev32ifbe(&amp;len); <span class="comment">// 将数据按照host本地字节序转化</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="static-unsigned-int-zipmapEncodeLength-unsigned-char-p-unsigned-int-len"><a href="#static-unsigned-int-zipmapEncodeLength-unsigned-char-p-unsigned-int-len" class="headerlink" title="static unsigned int zipmapEncodeLength(unsigned char *p, unsigned int len);"></a><code>static unsigned int zipmapEncodeLength(unsigned char *p, unsigned int len);</code></h3><h4 id="功能-10"><a href="#功能-10" class="headerlink" title="功能"></a>功能</h4><p>根据实际长度,获取到编码后占用的字节长度</p>
<h4 id="源码-10"><a href="#源码-10" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Encode the length &#x27;l&#x27; writing it in &#x27;p&#x27;. If p is NULL it just returns</span></span><br><span class="line"><span class="comment"> * the amount of bytes required to encode such a length. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipmapEncodeLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123; <span class="comment">// 没有传入zm</span></span><br><span class="line">        <span class="keyword">return</span> ZIPMAP_LEN_BYTES(len); <span class="comment">// 直接返回容纳这个长度需要的字节数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 记录数据长度</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; ZIPMAP_BIGLEN) &#123;</span><br><span class="line">            p[<span class="number">0</span>] = len;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p[<span class="number">0</span>] = ZIPMAP_BIGLEN;</span><br><span class="line">            <span class="built_in">memcpy</span>(p+<span class="number">1</span>,&amp;len,<span class="keyword">sizeof</span>(len));</span><br><span class="line">            memrev32ifbe(p+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+<span class="keyword">sizeof</span>(len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="static-unsigned-char-zipmapLookupRaw-unsigned-char-zm-unsigned-char-key-unsigned-int-klen-unsigned-int-totlen"><a href="#static-unsigned-char-zipmapLookupRaw-unsigned-char-zm-unsigned-char-key-unsigned-int-klen-unsigned-int-totlen" class="headerlink" title="static unsigned char *zipmapLookupRaw(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned int *totlen);"></a><code>static unsigned char *zipmapLookupRaw(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned int *totlen);</code></h3><h4 id="功能-11"><a href="#功能-11" class="headerlink" title="功能"></a>功能</h4><p>key存在,查找指定key所在的头指针<br>totlen存在,返回整个zm占用的字节长度</p>
<h4 id="源码-11"><a href="#源码-11" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Search for a matching key, returning a pointer to the entry inside the</span></span><br><span class="line"><span class="comment"> * zipmap. Returns NULL if the key is not found.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If NULL is returned, and totlen is not NULL, it is set to the entire</span></span><br><span class="line"><span class="comment"> * size of the zimap, so that the calling function will be able to</span></span><br><span class="line"><span class="comment"> * reallocate the original zipmap to make room for more entries. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">zipmapLookupRaw</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zm, <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">unsigned</span> <span class="keyword">int</span> klen, <span class="keyword">unsigned</span> <span class="keyword">int</span> *totlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = zm+<span class="number">1</span>, *k = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l,llen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*p != ZIPMAP_END) &#123; <span class="comment">// 循环遍历字节到结尾</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Match or skip the key */</span></span><br><span class="line">        l = zipmapDecodeLength(p);</span><br><span class="line">        llen = zipmapEncodeLength(<span class="literal">NULL</span>,l);</span><br><span class="line">        <span class="keyword">if</span> (key != <span class="literal">NULL</span> &amp;&amp; k == <span class="literal">NULL</span> &amp;&amp; l == klen &amp;&amp; !<span class="built_in">memcmp</span>(p+llen,key,l)) &#123; <span class="comment">// 查找匹配的key</span></span><br><span class="line">            <span class="comment">/* Only return when the user doesn&#x27;t care</span></span><br><span class="line"><span class="comment">             * for the total length of the zipmap. */</span></span><br><span class="line">            <span class="keyword">if</span> (totlen != <span class="literal">NULL</span>) &#123; <span class="comment">// 不需要计算长度,则直接返回,否则继续循环</span></span><br><span class="line">                k = p;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p += llen+l;</span><br><span class="line">        <span class="comment">/* Skip the value as well */</span></span><br><span class="line">        l = zipmapDecodeLength(p);</span><br><span class="line">        p += zipmapEncodeLength(<span class="literal">NULL</span>,l);</span><br><span class="line">        <span class="built_in">free</span> = p[<span class="number">0</span>];</span><br><span class="line">        p += l+<span class="number">1</span>+<span class="built_in">free</span>; <span class="comment">/* +1 to skip the free byte */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (totlen != <span class="literal">NULL</span>) *totlen = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(p-zm)+<span class="number">1</span>; <span class="comment">// 计算最终字节长度</span></span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="static-unsigned-long-zipmapRequiredLength-unsigned-int-klen-unsigned-int-vlen"><a href="#static-unsigned-long-zipmapRequiredLength-unsigned-int-klen-unsigned-int-vlen" class="headerlink" title="static unsigned long zipmapRequiredLength(unsigned int klen, unsigned int vlen);"></a><code>static unsigned long zipmapRequiredLength(unsigned int klen, unsigned int vlen);</code></h3><h4 id="功能-12"><a href="#功能-12" class="headerlink" title="功能"></a>功能</h4><p>根据键值长度,计算存储需要的数据量</p>
<h4 id="源码-12"><a href="#源码-12" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">zipmapRequiredLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> klen, <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l;</span><br><span class="line"></span><br><span class="line">    l = klen+vlen+<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (klen &gt;= ZIPMAP_BIGLEN) l += <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (vlen &gt;= ZIPMAP_BIGLEN) l += <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="static-unsigned-int-zipmapRawKeyLength-unsigned-char-p"><a href="#static-unsigned-int-zipmapRawKeyLength-unsigned-char-p" class="headerlink" title="static unsigned int zipmapRawKeyLength(unsigned char *p);"></a><code>static unsigned int zipmapRawKeyLength(unsigned char *p);</code></h3><h4 id="功能-13"><a href="#功能-13" class="headerlink" title="功能"></a>功能</h4><p>获取key的总长度(数据+长度记录)</p>
<h4 id="源码-13"><a href="#源码-13" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Return the total amount used by a key (encoded length + payload) */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipmapRawKeyLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l = zipmapDecodeLength(p);</span><br><span class="line">    <span class="keyword">return</span> zipmapEncodeLength(<span class="literal">NULL</span>,l) + l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="static-unsigned-int-zipmapRawValueLength-unsigned-char-p"><a href="#static-unsigned-int-zipmapRawValueLength-unsigned-char-p" class="headerlink" title="static unsigned int zipmapRawValueLength(unsigned char *p);"></a><code>static unsigned int zipmapRawValueLength(unsigned char *p);</code></h3><h4 id="功能-14"><a href="#功能-14" class="headerlink" title="功能"></a>功能</h4><p>获取value的总长度(数据+长度记录)</p>
<h4 id="源码-14"><a href="#源码-14" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Return the total amount used by a value</span></span><br><span class="line"><span class="comment"> * (encoded length + single byte free count + payload) */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipmapRawValueLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l = zipmapDecodeLength(p);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> used;</span><br><span class="line"></span><br><span class="line">    used = zipmapEncodeLength(<span class="literal">NULL</span>,l);</span><br><span class="line">    used += p[used] + <span class="number">1</span> + l; <span class="comment">// 多了一个free的处理</span></span><br><span class="line">    <span class="keyword">return</span> used;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="static-unsigned-int-zipmapRawEntryLength-unsigned-char-p"><a href="#static-unsigned-int-zipmapRawEntryLength-unsigned-char-p" class="headerlink" title="static unsigned int zipmapRawEntryLength(unsigned char *p);"></a><code>static unsigned int zipmapRawEntryLength(unsigned char *p);</code></h3><h4 id="功能-15"><a href="#功能-15" class="headerlink" title="功能"></a>功能</h4><p>获取键值对的完整长度</p>
<h4 id="源码-15"><a href="#源码-15" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* If &#x27;p&#x27; points to a key, this function returns the total amount of</span></span><br><span class="line"><span class="comment"> * bytes used to store this entry (entry = key + associated value + trailing</span></span><br><span class="line"><span class="comment"> * free space if any). */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipmapRawEntryLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l = zipmapRawKeyLength(p);</span><br><span class="line">    <span class="keyword">return</span> l + zipmapRawValueLength(p+l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="static-inline-unsigned-char-zipmapResize-unsigned-char-zm-unsigned-int-len"><a href="#static-inline-unsigned-char-zipmapResize-unsigned-char-zm-unsigned-int-len" class="headerlink" title="static inline unsigned char *zipmapResize(unsigned char *zm, unsigned int len);"></a><code>static inline unsigned char *zipmapResize(unsigned char *zm, unsigned int len);</code></h3><h4 id="功能-16"><a href="#功能-16" class="headerlink" title="功能"></a>功能</h4><p>重新设置zm的内存大小(新长度小于就长度会截断)</p>
<h4 id="源码-16"><a href="#源码-16" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">zipmapResize</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zm, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    zm = zrealloc(zm, len);</span><br><span class="line">    zm[len<span class="number">-1</span>] = ZIPMAP_END;</span><br><span class="line">    <span class="keyword">return</span> zm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>redis</category>
        <category>source</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>1. Redis 扩展功能-慢查询</title>
    <url>/2018/04/23/redis-utility-1/</url>
    <content><![CDATA[<p>慢日志就是程序记录命令的执行(无网络通信,排队等待的时间)前后的时间差,<br>当执行时间超过预设的阀值时,就会记录这条命令相关的信息.<br>可以根据慢日志来定位性能问题</p>
<a id="more"></a>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul>
<li><code>slowlog-log-slower-than</code>是超时时间(微秒),默认是10000,0:记录所有命令,&lt;0:停用慢日志</li>
<li><code>slowlog-max-len</code>慢日志记录数量限制,超出的按照时间早晚删除,是队列,先进先出</li>
</ul>
<h3 id="配置修改命令"><a href="#配置修改命令" class="headerlink" title="配置修改命令"></a>配置修改命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config set slowlog-log-slower-than 20000 # 设置超时时间</span><br><span class="line">config set slowlog-max-len 100 # 设置最大长度</span><br><span class="line">config rewrite # 写配置文件到硬盘</span><br></pre></td></tr></table></figure>

<h2 id="慢日志命令"><a href="#慢日志命令" class="headerlink" title="慢日志命令"></a>慢日志命令</h2><ul>
<li>显示慢日志<br>  <code>slowlog get [$count]</code><br>  获取所有(指定条目)的慢日志<br>  每个慢日志有4个属性组成<ul>
<li>日志id</li>
<li>发生时间戳</li>
<li>命令耗时</li>
<li>执行的完整命令(包含参数)</li>
</ul>
</li>
<li>获取慢日志长度<br>  <code>slowlog len</code></li>
<li>慢日志重置(清空)<br>  <code>slowlog reset</code></li>
</ul>
<h2 id="可以注意的地方"><a href="#可以注意的地方" class="headerlink" title="可以注意的地方"></a>可以注意的地方</h2><ul>
<li>慢日志条目限制可以适当增多,减少慢日志被顶掉的数量</li>
<li>默认10毫秒超时,根据需要设置超时时间</li>
<li>可以定时执行<code>slowlog get</code>+<code>slowlog reset</code>命令将慢日志存储在其他文件中,保证慢日志不会丢失</li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
        <category>development &amp; operation</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>10. Redis 扩展功能-发布订阅</title>
    <url>/2018/04/24/redis-utility-10/</url>
    <content><![CDATA[<ul>
<li>发布者,订阅者都是客户端</li>
<li>频道信息记录在Redis服务器中</li>
</ul>
<img src="/2018/04/24/redis-utility-10/publish_subscribe.jpg" class="" title="publish subscribe">

<a id="more"></a>

<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ul>
<li>发布消息<br>  <code>publish $channel $message</code><br>  返回订阅者个数</li>
<li>订阅消息<br>  <code>subscribe $channel [$channel...]</code><br>  持续返回相关频道的信息<br>  不会显示之前发布的信息<br>  只会显示订阅开始后新发布的信息</li>
<li>取消订阅<br>  <code>unsubscribe $channel [$channel...]</code></li>
<li>模式匹配订阅和取消订阅<br>  <code>psubscribe $channelPattern [$channelPattern...]</code><br>  <code>punsubscribe $channelPattern [$channelPattern...]</code></li>
<li>订阅查询<ul>
<li>查询活跃频道<br>  <code>pubsub channels [$channelPattern]</code><br>  查询所有符合<code>$channelPattern</code>的频道<br>  (必须至少有一个订阅者)</li>
<li>查看频道订阅数<br>  <code>pubsub numsub [$channel...]</code></li>
<li>查看模式订阅数<br>  <code>pubsub numpat</code></li>
</ul>
</li>
</ul>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>聊天室/公告牌/服务之间消息解耦用</p>
]]></content>
      <categories>
        <category>redis</category>
        <category>development &amp; operation</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>11. Redis 扩展功能-地理定位(GEO)</title>
    <url>/2018/04/24/redis-utility-11/</url>
    <content><![CDATA[<p>为了计算地理位置提供的接口集<br>GEO数据结构本质是<code>zset</code></p>
<a id="more"></a>

<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ul>
<li>增加地理位置信息<br>  <code>geoadd $key $经度 $纬度 $成员名 [$经度 $纬度 $成员名...]</code><br>  重复添加相同成员名的数据会返回0,只能添加一次,但是会更新相应的位置信息</li>
<li>获取地理位置信息<br>  <code>geopos $key $成员名 [$成员名...]</code></li>
<li>获取两点之间的距离<br>  <code>geodist $key $成员1 $成员2 [$单位]</code><ul>
<li>$单位<ul>
<li>m(meter)米</li>
<li>km(kilometer)千米</li>
<li>mi(mile)英里</li>
<li>ft(feet)尺</li>
</ul>
</li>
</ul>
</li>
<li>获取指定范围内的地理信息位置集合<br>  <code>getradius $key $中心点精度 $中心点纬度 $半径 $单位</code><br>  <code>getrediusbymember $key $成员名 $半径 $单位</code><br>  这两条命令还有扩展参数<ul>
<li>withcoord 结果包含经纬度</li>
<li>withdist 结果包含距离中心点距离</li>
<li>withhash 结果包含<code>geohash</code>(就是将经纬度转化为一个字符串,所有的点都可以转化为字符串,字符串长度越长越精确,转换是双向的)</li>
<li>COUNT $count 指定返回结果的数量</li>
<li>asc|desc 按照距离中心点的距离做升序降序排列</li>
<li>store $key 将结果的地理位置信息保存到指定键中</li>
<li>sotredist $key 将结果距离中心点的距离保存到指定键中</li>
</ul>
</li>
<li>删除地理位置信息<br>  <code>zrem $key $成员名</code><br>  直接使用<code>zrem</code>删除数据,<code>geo</code>命令本身无删除命令</li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
        <category>development &amp; operation</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>12. Redis 扩展功能-总结</title>
    <url>/2018/04/24/redis-utility-12/</url>
    <content><![CDATA[<p>外围扩展功能</p>
<ul>
<li>slowlog 慢查询</li>
<li>redis-cli 客户端</li>
<li>redis-benchmark 标准测试工具</li>
<li>pipeline 批处理命令</li>
<li>lua 批处理命令</li>
<li>bitmaps 位操作</li>
<li>hyperloglog 高压缩set,有小量误差</li>
<li>pubsub 发布订阅</li>
<li>GEO 地理位置处理</li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
        <category>development &amp; operation</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>2. Redis 扩展功能-redis-cli</title>
    <url>/2018/04/23/redis-utility-2/</url>
    <content><![CDATA[<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li><code>--help</code>所有参数帮助</li>
<li><code>-h</code>IP</li>
<li><code>-p</code>端口</li>
<li><code>redis-cli -p 6666 -r 5 -i 1 ping</code>每隔1秒执行一次命令<code>ping</code>,总共执行5次</li>
<li><code>-x</code>从输出获取命令的最后一个参数<code>echo &quot;world&quot; | redis-cli -p 6666 -x set hello</code>(只能获取最后一个参数,即时输出中有空格也是只能获取一个)<a id="more"></a></li>
<li><code>-c</code>cluster选项,功能我还不知道</li>
<li><code>--slave</code>将客户端模拟成<code>redis-server</code>的从数据库</li>
<li><code>--rdb</code>将数据库文件保存为rdb文件在本地<code>redis-cli -p 6666 --rdb $filename</code></li>
<li><code>--eval</code>执行lua脚本</li>
<li><code>--latency</code>,当前客户端和服务器的网络延迟信息</li>
<li><code>--latency-history</code>,显示两次调用该命令的延迟信息(可以配合<code>-r-i</code>参数定时输出)</li>
<li><code>--latency-dist</code>,已图表的形式输出延迟信息</li>
<li><code>--stat</code>查看redis的运行状态(key数量,内存使用,客户端数量,阻塞数量,请求数量,连接数)<br>  在命令行内部,可以直接使用<code>info</code>命令来查看更详细的信息</li>
<li><code>--raw</code>和<code>--no-raw</code>直接运行的命令是否格式化</li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
        <category>development &amp; operation</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>3. Redis 扩展功能-redis-server</title>
    <url>/2018/04/23/redis-utility-3/</url>
    <content><![CDATA[<p>redis的server,实际的数据处理都是使用这个程序</p>
<a id="more"></a>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li><code>--test-memory $内存大小(MB)</code>,检测是否可以正确的分配指定大小的内存给redis-server使用,可以减少因为内存问题导致的redis-server服务错误(极端内存使用测试用)</li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
        <category>development &amp; operation</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>4. Redis 扩展功能-redis-benchmark</title>
    <url>/2018/04/23/redis-utility-4/</url>
    <content><![CDATA[<p>redis-benchmark是redis测试工具<br>用于测试redis的性能</p>
<a id="more"></a>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li><code>-c</code><br>  客户端并发数量,默认50</li>
<li><code>-n $requests</code><br>  客户端<strong>总</strong>请求数量,默认100000</li>
<li><code>-q</code><br>  显示简略信息</li>
<li><code>-r $随机标志</code><br>  向redis随机插入键,如:10000是随机键值的后4位</li>
<li><code>-P</code><br>  每个请求pipeline的数量,默认为1</li>
<li><code>-k $是否长连</code><br>  客户端是否使用keeplive,1:使用,0:不实用,默认为1</li>
<li><code>-t $command1[,$command2...]</code><br>  对指定命令进行测试</li>
<li><code>--csv</code><br>  将结果输出为csv格式输出,可以重定向到文件</li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
        <category>development &amp; operation</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>5. Redis 扩展功能-Pipeline</title>
    <url>/2018/04/23/redis-utility-5/</url>
    <content><![CDATA[<p>组装命令,批处理<br>按照顺序组装一系列命令统一发给服务器,<br>服务器再按照命令的顺序将结果统一组装发给客户端,<br>减少了多次执行命令所使用的网络通信时间</p>
<p><strong>pipeline不能过长,会引起阻塞</strong></p>
<a id="more"></a>

<h2 id="执行命令流程"><a href="#执行命令流程" class="headerlink" title="执行命令流程"></a>执行命令流程</h2><ol>
<li>发送命令</li>
<li>命令排队</li>
<li>命令执行</li>
<li>返回结果</li>
</ol>
<p>其中:1,4组合成为Round Trip Time(RTT,往返时间)</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>pipeline的执行速度比逐条执行要快</li>
<li>客户端服务器网络延迟越大,pipeline的效果越明显</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>单次执行前需要统计好所有需要执行的命令</li>
<li>无法根据上次命令查询结果来修改本次命令的内容</li>
</ul>
<h2 id="与mset-mget等天然支持批量操作命令的对比"><a href="#与mset-mget等天然支持批量操作命令的对比" class="headerlink" title="与mset,mget等天然支持批量操作命令的对比"></a>与<code>mset</code>,<code>mget</code>等天然支持批量操作命令的对比</h2><ul>
<li>原生命令是原子性的,pipeline是非原子性的</li>
<li>原生命令只是单条命令,pipeline是多条命令</li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
        <category>development &amp; operation</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>6. Redis 扩展功能-事务</title>
    <url>/2018/04/23/redis-utility-6/</url>
    <content><![CDATA[<p>事务就是保证命令组合原子性的一种机制,<br>一组命令,要么全部执行,要么全部不执行.<br><strong>Reids的事务没有回滚功能,一旦开始执行,就必定都会执行,判断不能执行事务的依据是没有语法错误,并且关注的键值没有发生变化</strong></p>
<a id="more"></a>

<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>两个命令中间的命令会按照顺序执行</p>
<ul>
<li><code>multi</code>开始事务</li>
<li><code>exec</code>结束事务</li>
<li><code>discard</code>终止事务(所有命令都不执行)</li>
<li><code>watch $key</code>在开始事务前关注指定的<code>$key</code>,保证在执行事务过程中<code>$key</code>的内容没有发生变化,否则事务执行失败</li>
</ul>
<h2 id="事务出错的处理方式"><a href="#事务出错的处理方式" class="headerlink" title="事务出错的处理方式"></a>事务出错的处理方式</h2><ol>
<li>编写命令时错误(命令拼写错误)<br> 整个事务失败,所有命令无法执行</li>
<li>运行时错误(将A命令写成了B命令,但语法正确(即使运行时报错也不会回滚))<br> 整个事务运行成功,并不会发生回滚,需要手动修复</li>
</ol>
]]></content>
      <categories>
        <category>redis</category>
        <category>development &amp; operation</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>7. Redis 扩展功能-Lua</title>
    <url>/2018/04/24/redis-utility-7/</url>
    <content><![CDATA[<h2 id="在Redis中使用Lua"><a href="#在Redis中使用Lua" class="headerlink" title="在Redis中使用Lua"></a>在Redis中使用Lua</h2><ul>
<li>外部<ol>
<li><code>redis-cli --eval $脚本文件名</code><br> <code>redis-cli -p 6666 --eval a.lua</code></li>
</ol>
</li>
<li>内部<ol>
<li><code>eval $脚本内容 $参数个数 $参数列表...</code><br> <code>eval &#39;return &quot;hello&quot;..KEYS[1]..KEYS[2]&#39; 2 world haha</code><br> <code>KEYS</code>数组下标从1开始<a id="more"></a></li>
<li><code>evalsha $脚本sha1值 $参数个数 $参数列表...</code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli -p 6666 script load <span class="string">&quot;<span class="subst">$(cat a.lua)</span>&quot;</span> <span class="comment"># 获取到xxx.lua脚本的sha1值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">evalsha 4719dc708ac83e3d7c7252804b4b166e06519c61 2 world1 world2</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<p><strong>使用<code>script load</code>可以将脚本内容加载到数据库内存中,后面通过返回的sha1值来调用执行脚本即可</strong></p>
<h2 id="Lua调用Redis"><a href="#Lua调用Redis" class="headerlink" title="Lua调用Redis"></a>Lua调用Redis</h2><ul>
<li><code>redis.call</code>可以调用Redis的命令,执行失败报错,停止继续执行  <figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">redis.call(<span class="string">&quot;set&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> redis.call(<span class="string">&quot;get&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli -p 6666 --<span class="built_in">eval</span> a.lua</span><br><span class="line">redis-cli -p 6666 script load <span class="string">&quot;<span class="subst">$(cat a.lua)</span>&quot;</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">evalsha 86370eb220da770aec7bc7aeaacd7acefc3a8437 0</span><br></pre></td></tr></table></figure></li>
<li><code>redis.pcall</code>也可以调用Redis命令,执行失败会忽略错误继续执行脚本</li>
</ul>
<h2 id="使用Lua的好处"><a href="#使用Lua的好处" class="headerlink" title="使用Lua的好处"></a>使用Lua的好处</h2><ul>
<li>原子性,在Redis中执行脚本不会被中断插入其他命令执行</li>
<li>可以方便的组合命令来实现快捷操作</li>
<li>可以将多个命令打包,减少网络通信开销</li>
</ul>
<h2 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h2><ul>
<li><code>script load $脚本名</code><br>  将脚本加载到内存中</li>
<li><code>script exits $脚本sha1...</code><br>  判断脚本是否已经加载到内存中</li>
<li><code>script flush</code><br>  清空所有被加载到内存中的脚本</li>
<li><code>script kill</code><br>  杀掉当前正在执行的lua脚本,当lua脚本运行时间过长时可以使用该命令停止脚本的执行<br>  <strong>当脚本正在执行写操作时,是无法使用本条命令进行关闭的,只能使用<code>shutdown save</code>来停掉操作</strong><br>  所以写lua脚本时一定要注意</li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
        <category>development &amp; operation</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>8. Redis 扩展功能-位操作</title>
    <url>/2018/04/24/redis-utility-8/</url>
    <content><![CDATA[<p>位操作(Bitmaps)本质就是字符串<br>在Redis中提供了一系列位操作命令</p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><a id="more"></a>

<ul>
<li>设置值<br>  <code>setbit $key $offset $value</code></li>
<li>获取值<br>  <code>getbit $key $offset</code></li>
<li>获取指定范围内值为1的个数<br>  <code>bitcount $key [$start $end]</code>(起始字节和结束字节,不是位)</li>
<li>交,并,非,异或运算(多个位变量的操作)<br>  <code>bitop $op $destkey $key [$key...]</code><ul>
<li>$op<ul>
<li>and</li>
<li>or</li>
<li>not</li>
<li>xor<br>最终结果存放在<code>$destkey</code>中</li>
</ul>
</li>
</ul>
</li>
<li>从前到后查找第一个值为指定值的位置<br>  <code>bitpos $key $指定值(0|1) [$start $end]</code></li>
</ul>
<h2 id="试用范围"><a href="#试用范围" class="headerlink" title="试用范围"></a>试用范围</h2><p>需要用到的标记量比较多的时候,<br>如果用到的比较少,直接使用<code>set</code>来存储id即可,<br>如果很多,则使用位变量能减少空间.</p>
]]></content>
      <categories>
        <category>redis</category>
        <category>development &amp; operation</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>9. Redis 扩展功能-HyperLogLog</title>
    <url>/2018/04/24/redis-utility-9/</url>
    <content><![CDATA[<p>HyperLogLog是一种数据结构(本质为字符串)<br>基于一种基数算法<br>它可以用极小的内存空间完成数据统计<br>它本身属性有点像<code>set</code>一样<br>因为它的存储数据不是一一对应的关系,<br>实际是有错误的,<br>官方给出的错误率是0.81%</p>
<p><strong>优点:相比set,可以极大的减少内存的使用</strong></p>
<a id="more"></a>

<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ul>
<li>添加<br>  <code>pfadd $key $element [$element...]</code></li>
<li>查询数量<br>  <code>pfcount $key [$key...]</code></li>
<li>合并<br>  <code>pfmerge $destkey $key [%key...]</code><br>  就是求并集</li>
</ul>
<h2 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h2><ul>
<li>只做统计数量,不需要获取单条数据</li>
<li>可以容忍一定误差率</li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
        <category>development &amp; operation</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>REDISLV数据备份与恢复</title>
    <url>/2018/07/23/redislv-data-recover/</url>
    <content><![CDATA[<p>REDISLV的数据保存一般是根据配置文件<br>直接保存在本地硬盘上的</p>
<h2 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h2><p>一个基本的配置文件的例子<br>redis_simple.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 所有会使用到的配置整理</span><br><span class="line"> </span><br><span class="line"># 后台运行</span><br><span class="line"># daemonize yes </span><br><span class="line"> </span><br><span class="line"># 监听</span><br><span class="line">port 9898</span><br><span class="line"> </span><br><span class="line"># 客户端ip限制</span><br><span class="line">bind 127.0.0.1</span><br><span class="line"></span><br><span class="line"># 密码限制</span><br><span class="line">requirepass 192168119145</span><br><span class="line"> </span><br><span class="line"># 不保存rdb文件</span><br><span class="line">save &quot;&quot;</span><br><span class="line"> </span><br><span class="line"># 是否开启aof</span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line"># 每秒保存日志</span><br><span class="line">appendfsync everysec</span><br><span class="line"></span><br><span class="line"># aof重写配置</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"># 慢日志配置</span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line">slowlog-max-len 128</span><br><span class="line"></span><br><span class="line"># rdb,aof保存目录</span><br><span class="line">dir .&#x2F;database</span><br><span class="line"></span><br><span class="line"># levedb配置</span><br><span class="line">leveldb yes</span><br><span class="line">leveldb-path .&#x2F;leveldb</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>根据例子的配置<br>数据库不保存rdb文件</p>
<p>只使用aof和leveldb保存数据<br>aof是实时日志,防止leveldb出现问题无法恢复<br>或者当切换为普通的redis时,可以直接使用这个<br>aof文件来进行数据恢复.<br>aof文件是保存在配置中的<code>./database</code>中的</p>
<p>leveldb是使用leveldb的方式持久化数据<br>leveldb的数据是保存在<code>./database/leveldb</code>文件夹中的</p>
<h3 id="不使用rdb的原因"><a href="#不使用rdb的原因" class="headerlink" title="不使用rdb的原因"></a>不使用rdb的原因</h3><p>因为使用了leveldb,所以数据的压缩保存就不需要使用<br>rdb了.<br>rdb保存本身要fork进程<br>有可能占用更多的内存<br>当数据库比较大时,<br>写文件时间可能会比较长,<br>影响aof和leveldb的写操作.</p>
<h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>定期保存<code>./database</code>文件夹下的数据即可</p>
<h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><p>实际上就是用以前备份的文件覆盖掉现有文件的一个过程<br>整体回档也可以采用这种方案.</p>
<ol>
<li>数据库停机</li>
<li>将备份的数据库文件覆盖掉原来的数据库文件</li>
<li>启动数据库</li>
<li>完成</li>
</ol>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>redisLV</tag>
        <tag>data backup</tag>
        <tag>data recovery</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift基本操作符</title>
    <url>/2018/09/20/swift-basic-operators/</url>
    <content><![CDATA[<p><strong>本文是根据官方文档整理出来的阅读笔记,<a href="https://docs.swift.org/swift-book/LanguageGuide/BasicOperators.html">原文地址</a></strong></p>
<ul>
<li>就是<code>+</code>,<code>-</code>,<code>*</code>,<code>&amp;&amp;</code>等一些常用的操作符</li>
<li>包含了大部分的<code>C</code>语言操作符</li>
<li>扩展优化了个别操作符<ul>
<li><code>=</code>不会返回数值,防止在bool判断中出现问题</li>
<li>加减乘除取余运算符直接校验数值防止溢出(可以通过swift的溢出操作符来实现该需求)</li>
</ul>
</li>
<li>新增了一些操作符<ul>
<li><code>..&lt;</code>,表示一个范围,从起始开始,&lt;最终值</li>
<li><code>...</code>,表示一个范围,从起始开始,&lt;=最终值</li>
</ul>
</li>
</ul>
<h2 id="学术用语"><a href="#学术用语" class="headerlink" title="学术用语"></a>学术用语</h2><ul>
<li>一元运算符(<code>unary</code>)<ul>
<li>类似<code>-a</code>这种,只作用于一个参数的</li>
<li><code>!a</code>和<code>a!</code>分别是前缀和后缀的用法,意义不一样</li>
</ul>
</li>
<li>二元运算符(<code>binary</code>)<ul>
<li><code>2+3</code></li>
</ul>
</li>
<li>三元运算符(<code>ternary</code>)<ul>
<li>只有三目表达式是三元运算符</li>
<li><code>a ? b : c</code></li>
</ul>
</li>
</ul>
<a id="more"></a>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><ul>
<li>基本用法<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">5</span></span><br><span class="line">a = b</span><br><span class="line"><span class="comment">// a is now equal to 10</span></span><br></pre></td></tr></table></figure></li>
<li>同时给多个参数赋值<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> (x, y) = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// x is equal to 1, and y is equal to 2</span></span><br></pre></td></tr></table></figure></li>
<li><code>=</code>无返回值,所以以下代码无效,编译报错<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x = y &#123;</span><br><span class="line">    <span class="comment">// This is not valid, because x = y does not return a value.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><ul>
<li>基本<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span>       <span class="comment">// equals 3</span></span><br><span class="line"><span class="number">5</span> - <span class="number">3</span>       <span class="comment">// equals 2</span></span><br><span class="line"><span class="number">2</span> * <span class="number">3</span>       <span class="comment">// equals 6</span></span><br><span class="line"><span class="number">10.0</span> / <span class="number">2.5</span>  <span class="comment">// equals 4.0</span></span><br></pre></td></tr></table></figure></li>
<li>溢出操作符<ul>
<li>就是在普通的操作符前加上<code>&amp;</code><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">a &amp;+ b</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>支持字符串连接<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;hello, &quot;</span> + <span class="string">&quot;world&quot;</span>  <span class="comment">// equals &quot;hello, world&quot;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="取余操作符"><a href="#取余操作符" class="headerlink" title="取余操作符"></a>取余操作符</h3><ul>
<li><code>%</code><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span> % <span class="number">4</span>    <span class="comment">// equals 1</span></span><br></pre></td></tr></table></figure></li>
<li>被除数是负数的情况下<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">-<span class="number">9</span> % <span class="number">4</span>   <span class="comment">// equals -1</span></span><br></pre></td></tr></table></figure></li>
<li>操作符后面的数字的正负是忽略的,只和前面的数字的正负值有关<br>所以所有的余数的结果的正负都和前面的数字一致</li>
</ul>
<h3 id="一元-操作符"><a href="#一元-操作符" class="headerlink" title="一元-操作符"></a>一元<code>-</code>操作符</h3><ul>
<li>基础<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> three = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> minusThree = -three       <span class="comment">// minusThree equals -3</span></span><br><span class="line"><span class="keyword">let</span> plusThree = -minusThree   <span class="comment">// plusThree equals 3, or &quot;minus minus three&quot;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="一元-操作符-1"><a href="#一元-操作符-1" class="headerlink" title="一元+操作符"></a>一元<code>+</code>操作符</h3><ul>
<li>基础<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> minusSix = -<span class="number">6</span></span><br><span class="line"><span class="keyword">let</span> alsoMinusSix = +minusSix  <span class="comment">// alsoMinusSix equals -6</span></span><br></pre></td></tr></table></figure></li>
<li>无实际意义,可以对齐代码用</li>
</ul>
<h2 id="混合赋值操作符"><a href="#混合赋值操作符" class="headerlink" title="混合赋值操作符"></a>混合赋值操作符</h2><ul>
<li>基础<ul>
<li><code>+=</code>,<code>-=</code>等类似的操作符<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">a += <span class="number">2</span></span><br><span class="line"><span class="comment">// a is now equal to 3</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>该操作符无返回,不能用于后续赋值,如:<code>let b = a += 2</code></li>
</ul>
<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><ul>
<li>和标准C的比较操作符一样<ul>
<li><code>a == b</code></li>
<li><code>a != b</code></li>
<li><code>a &gt; b</code></li>
<li><code>a &lt; b</code></li>
<li><code>a &gt;= b</code></li>
<li><code>a &lt;= b</code></li>
</ul>
</li>
<li>扩展<ul>
<li>用于判断两个对象是否引用同一个对象</li>
<li><code>a === b</code></li>
<li><code>a !== b</code></li>
</ul>
</li>
<li>比较运算符返回bool值<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="number">1</span>   <span class="comment">// true because 1 is equal to 1</span></span><br><span class="line"><span class="number">2</span> != <span class="number">1</span>   <span class="comment">// true because 2 is not equal to 1</span></span><br><span class="line"><span class="number">2</span> &gt; <span class="number">1</span>    <span class="comment">// true because 2 is greater than 1</span></span><br><span class="line"><span class="number">1</span> &lt; <span class="number">2</span>    <span class="comment">// true because 1 is less than 2</span></span><br><span class="line"><span class="number">1</span> &gt;= <span class="number">1</span>   <span class="comment">// true because 1 is greater than or equal to 1</span></span><br><span class="line"><span class="number">2</span> &lt;= <span class="number">1</span>   <span class="comment">// false because 2 is not less than or equal to 1</span></span><br></pre></td></tr></table></figure></li>
<li>比较运算符常用语<code>if</code>中<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="keyword">if</span> name == <span class="string">&quot;world&quot;</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I&#x27;m sorry \(name), but I don&#x27;t recognize you&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;hello, world&quot;, because name is indeed equal to &quot;world&quot;.</span></span><br></pre></td></tr></table></figure></li>
<li>可以直接比较tuple的值<ul>
<li>swift标准库提供的比较支持元组长度&lt;7(当被比较的元组长度&gt;=7时,需要自己实现比较操作符)</li>
<li>被比较的元组必须元素个数相同</li>
<li>不同元组相同索引的元素类型要相同<ul>
<li>整数可以直接与浮点数做比较</li>
</ul>
</li>
<li>所有元组元素必须都可以被比较运算符操作才可以<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">(<span class="string">&quot;blue&quot;</span>, -<span class="number">1</span>) &lt; (<span class="string">&quot;purple&quot;</span>, <span class="number">1</span>)        <span class="comment">// OK, evaluates to true</span></span><br><span class="line">(<span class="string">&quot;blue&quot;</span>, <span class="literal">false</span>) &lt; (<span class="string">&quot;purple&quot;</span>, <span class="literal">true</span>)  <span class="comment">// Error because &lt; can&#x27;t compare Boolean values</span></span><br></pre></td></tr></table></figure></li>
<li>比较方法<ul>
<li>按照元组索引依次比较</li>
<li>相同则向后比较</li>
<li>不同则不继续向后比较,直接返回当前的比较结果<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="string">&quot;zebra&quot;</span>) &lt; (<span class="number">2</span>, <span class="string">&quot;apple&quot;</span>)   <span class="comment">// true because 1 is less than 2; &quot;zebra&quot; and &quot;apple&quot; are not compared</span></span><br><span class="line">(<span class="number">3</span>, <span class="string">&quot;apple&quot;</span>) &lt; (<span class="number">3</span>, <span class="string">&quot;bird&quot;</span>)    <span class="comment">// true because 3 is equal to 3, and &quot;apple&quot; is less than &quot;bird&quot;</span></span><br><span class="line">(<span class="number">4</span>, <span class="string">&quot;dog&quot;</span>) == (<span class="number">4</span>, <span class="string">&quot;dog&quot;</span>)      <span class="comment">// true because 4 is equal to 4, and &quot;dog&quot; is equal to &quot;dog&quot;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="三目表达式"><a href="#三目表达式" class="headerlink" title="三目表达式"></a>三目表达式</h2><ul>
<li>就是标准的三目表达式<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> contentHeight = <span class="number">40</span></span><br><span class="line"><span class="keyword">let</span> hasHeader = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> rowHeight = contentHeight + (hasHeader ? <span class="number">50</span> : <span class="number">20</span>)</span><br><span class="line"><span class="comment">// rowHeight is equal to 90</span></span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> contentHeight = <span class="number">40</span></span><br><span class="line"><span class="keyword">let</span> hasHeader = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> rowHeight: <span class="type">Int</span></span><br><span class="line"><span class="keyword">if</span> hasHeader &#123;</span><br><span class="line">    rowHeight = contentHeight + <span class="number">50</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    rowHeight = contentHeight + <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// rowHeight is equal to 90</span></span><br></pre></td></tr></table></figure></li>
<li>尽量不要组合使用三目表达式,防止代码难以阅读理解</li>
</ul>
<h2 id="Nil-Coalescing-Operator"><a href="#Nil-Coalescing-Operator" class="headerlink" title="Nil-Coalescing Operator"></a>Nil-Coalescing Operator</h2><ul>
<li>就是操作符<code>a ?? b</code><ul>
<li>其中,a是可选参数</li>
<li>如果a是nil,则返回b</li>
<li>否则返回a的解包值</li>
<li>b和a的解包值的类型必须一致</li>
<li>意思同<code>a != nil ? a! : b</code>一样</li>
<li>如果a不是nil,则b的值不会计算(代码不会运行,就像or前面的条件是真一样)<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> defaultColorName = <span class="string">&quot;red&quot;</span></span><br><span class="line"><span class="keyword">var</span> userDefinedColorName: <span class="type">String?</span>   <span class="comment">// defaults to nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colorNameToUse = userDefinedColorName ?? defaultColorName</span><br><span class="line"><span class="comment">// userDefinedColorName is nil, so colorNameToUse is set to the default of &quot;red&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><code>??</code>只能用在可选参数的后面</li>
</ul>
</li>
</ul>
<h2 id="范围操作符"><a href="#范围操作符" class="headerlink" title="范围操作符"></a>范围操作符</h2><ul>
<li><code>..&lt;</code>,不包含最后的值</li>
<li><code>...</code>,包含最后的值<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;<span class="number">5</span> &#123; <span class="comment">// 1, 2, 3, 4</span></span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span> &#123; <span class="comment">// 1, 2, 3, 4, 5</span></span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="单边范围"><a href="#单边范围" class="headerlink" title="单边范围"></a>单边范围</h3><ul>
<li>在遍历的时候可以使用单边范围,没有指定的一边为容器的上/下界限<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">&quot;Anna&quot;</span>, <span class="string">&quot;Alex&quot;</span>, <span class="string">&quot;Brian&quot;</span>, <span class="string">&quot;Jack&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names[<span class="number">2</span>...] &#123;</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Brian</span></span><br><span class="line"><span class="comment">// Jack</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names[...<span class="number">2</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Anna</span></span><br><span class="line"><span class="comment">// Alex</span></span><br><span class="line"><span class="comment">// Brian</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names[..&lt;<span class="number">2</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Anna</span></span><br><span class="line"><span class="comment">// Alex</span></span><br></pre></td></tr></table></figure></li>
<li>单边范围还可以表示无限的内容<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> range = ...<span class="number">5</span> <span class="comment">// 表示从负无穷到5(包含5)</span></span><br><span class="line"><span class="built_in">print</span>(range.<span class="built_in">contains</span>(<span class="number">7</span>))</span><br><span class="line"><span class="built_in">print</span>(range.<span class="built_in">contains</span>(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(range.<span class="built_in">contains</span>(-<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(range.<span class="built_in">contains</span>(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><ul>
<li><code>&amp;&amp;</code>,与</li>
<li><code>||</code>,或</li>
<li><code>!</code>,非</li>
<li>行为同C语言一直<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> enteredDoorCode = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> passedRetinaScan = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> enteredDoorCode &amp;&amp; passedRetinaScan &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Welcome!&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ACCESS DENIED&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;ACCESS DENIED&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> hasDoorKey = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> knowsOverridePassword = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> hasDoorKey || knowsOverridePassword &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Welcome!&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ACCESS DENIED&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;Welcome!&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>范例中的一个写法(个人不喜欢)<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> enteredDoorCode &amp;&amp; passedRetinaScan || hasDoorKey || knowsOverridePassword &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Welcome!&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ACCESS DENIED&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;Welcome!&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>swift中逻辑运算符是优先按照最左边的内容开始运算的</li>
<li>这里可以看出and和or是平级的,但是不知道not的优先级</li>
<li>个人感想:记优先级极为蛋疼,正常人都用括号保证安全</li>
<li>正常人的写法<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (enteredDoorCode &amp;&amp; passedRetinaScan) || hasDoorKey || knowsOverridePassword &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Welcome!&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ACCESS DENIED&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;Welcome!&quot;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift基础</title>
    <url>/2018/09/12/swift-basics/</url>
    <content><![CDATA[<p><strong>本文是根据官方文档整理出来的阅读笔记,<a href="https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html">原文地址</a></strong></p>
<h2 id="变量-常量"><a href="#变量-常量" class="headerlink" title="变量/常量"></a>变量/常量</h2><ul>
<li>常量<ul>
<li><code>let</code></li>
</ul>
</li>
<li>变量<ul>
<li><code>var</code></li>
</ul>
</li>
</ul>
<p><strong>注:可在一行内生命多个变量/常量</strong><br><code>var a = 1, b = 2, c = 3</code></p>
<h2 id="类型限定"><a href="#类型限定" class="headerlink" title="类型限定"></a>类型限定</h2><ul>
<li>可在变量/常量后追加类型限定<ul>
<li><code>var a : 类型</code></li>
</ul>
</li>
<li>默认可以根据初次赋值内容推断类型</li>
<li><strong>没有在声明时直接赋值的变量/常量必须要限定类型</strong></li>
<li>相同类型的可以定义在同一行(变量/常量)<br>  <code>var a, b, c : Int</code>中,<code>a</code>,<code>b</code>,<code>c</code>都是<code>Int</code>类型</li>
</ul>
<h2 id="变量-常量民命规则"><a href="#变量-常量民命规则" class="headerlink" title="变量/常量民命规则"></a>变量/常量民命规则</h2><ul>
<li>不能有空格,运算符,箭头</li>
<li>不能以数字开头</li>
<li>几乎可以使用任何字符<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> π = <span class="number">3.14159</span></span><br><span class="line"><span class="keyword">let</span> 你好 = <span class="string">&quot;你好世界&quot;</span></span><br><span class="line"><span class="keyword">let</span> 🐶🐮 = <span class="string">&quot;dogcow&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>一旦定义好一个名称为变量或常量,则不能更改变量/常量类型,不能更改存储数据的类型<br>(可以但不推荐使用关键字命名,使用关键字命名需要使用```来将名称括起来)</li>
</ul>
<a id="more"></a>
<h2 id="打印变量-常量"><a href="#打印变量-常量" class="headerlink" title="打印变量/常量"></a>打印变量/常量</h2><ul>
<li>使用<code>print(\_:separator:terminator:)</code>函数</li>
<li>打印不换行<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;abc&quot;</span>, terminator:<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;def&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li>在字符串中,使用<code>\\(变量/常量名)</code>来插入字符串<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;def&quot;</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&quot;abc\(a)ghi&quot;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul>
<li>基本和c语言一样</li>
<li>单行注释<ul>
<li><code>//</code></li>
</ul>
</li>
<li>多行注释<ul>
<li><code>/*...*/</code></li>
<li>多行注释可以嵌套(和c不同的地方),方便快速注释大段内容<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This is the start of the first multiline comment.</span></span><br><span class="line"><span class="comment"> <span class="comment">/* This is the second, nested multiline comment. */</span></span></span><br><span class="line"><span class="comment">This is the end of the first multiline comment. */</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h2><ul>
<li>在一行结尾的分号,可写,可不写</li>
<li>一行内有多条语句,则需要在每条语句中间插入分号<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cat = <span class="string">&quot;🐱&quot;</span>; <span class="built_in">print</span>(cat)</span><br><span class="line"><span class="comment">// Prints &quot;🐱&quot;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><ul>
<li>推荐使用Int,只有在没有办法真正需要的时候才使用其他类型<ul>
<li>可移植性</li>
<li>类型转换</li>
</ul>
</li>
</ul>
<h3 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h3><ul>
<li>可以使用<code>类型.min</code>/<code>类型.max</code>来访问类型边界的最大,最小值<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> minValue = <span class="type">UInt8</span>.<span class="built_in">min</span>  <span class="comment">// minValue is equal to 0, and is of type UInt8</span></span><br><span class="line"><span class="keyword">let</span> maxValue = <span class="type">UInt8</span>.<span class="built_in">max</span>  <span class="comment">// maxValue is equal to 255, and is of type UInt8</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Int"><a href="#Int" class="headerlink" title="Int"></a>Int</h3><ul>
<li>大多数情况下不需要手动指定所使用的整数的长度</li>
<li>swift会根据平台来决定Int对应的类型<ul>
<li>32-bit平台,Int就是Int32</li>
<li>64-bit平台,Int就是Int64</li>
</ul>
</li>
</ul>
<h3 id="UInt"><a href="#UInt" class="headerlink" title="UInt"></a>UInt</h3><ul>
<li>和Int一样,只是将负数字段移动到整数字段了</li>
<li>swift会根据平台来决定UInt对应的类型<ul>
<li>32-bit平台,Int就是UInt32</li>
<li>64-bit平台,Int就是UInt64</li>
</ul>
</li>
</ul>
<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><ul>
<li>Double,表示64-bit浮点数,精度15</li>
<li>Float,表示32-bit浮点数,精度6</li>
<li>都是有符号的</li>
<li><strong>自动推断类型默认为Double</strong></li>
</ul>
<h2 id="类型安全与推断"><a href="#类型安全与推断" class="headerlink" title="类型安全与推断"></a>类型安全与推断</h2><ul>
<li>swift是类型安全的,类型必须显示转换,被定义后的类型不能改变</li>
<li>推断类型<ul>
<li>Int</li>
<li>Double</li>
<li>Int + Double = Double</li>
</ul>
</li>
</ul>
<h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><ul>
<li>十进制:无前缀</li>
<li>二进制:<code>0b</code>前缀</li>
<li>八进制:<code>0o</code>前缀</li>
<li>十六进制:<code>0x</code>前缀<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> decimalInteger = <span class="number">17</span></span><br><span class="line"><span class="keyword">let</span> binaryInteger = <span class="number">0b10001</span>       <span class="comment">// 17 in binary notation</span></span><br><span class="line"><span class="keyword">let</span> octalInteger = <span class="number">0o21</span>           <span class="comment">// 17 in octal notation</span></span><br><span class="line"><span class="keyword">let</span> hexadecimalInteger = <span class="number">0x11</span>     <span class="comment">// 17 in hexadecimal notation</span></span><br></pre></td></tr></table></figure></li>
<li>十进制小数<ul>
<li>1.25e2 means 1.25 x 102, or 125.0.</li>
<li>1.25e-2 means 1.25 x 10-2, or 0.0125.</li>
</ul>
</li>
<li>十六进制小数<ul>
<li>0xFp2 means 15 x 22, or 60.0.</li>
<li>0xFp-2 means 15 x 2-2, or 3.75.<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 12.1875</span></span><br><span class="line"><span class="keyword">let</span> decimalDouble = <span class="number">12.1875</span></span><br><span class="line"><span class="keyword">let</span> exponentDouble = <span class="number">1.21875e1</span></span><br><span class="line"><span class="keyword">let</span> hexadecimalDouble = <span class="number">0xC.3p0</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>数字都可以在前面加0或者在中间增加<code>\_</code>来增加可读性<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> paddedDouble = <span class="number">000123.456</span></span><br><span class="line"><span class="keyword">let</span> oneMillion = <span class="number">1_000_000</span></span><br><span class="line"><span class="keyword">let</span> justOverOneMillion = <span class="number">1_000_000.000_000_1</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="数字类型转换"><a href="#数字类型转换" class="headerlink" title="数字类型转换"></a>数字类型转换</h2><ul>
<li>不同类型的数字不能直接运算</li>
<li>需要转化为相同类型才能运算</li>
<li>运算结果为最终统一的类型<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> twoThousand: <span class="type">UInt16</span> = <span class="number">2_000</span></span><br><span class="line"><span class="keyword">let</span> one: <span class="type">UInt8</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> twoThousandAndOne = twoThousand + <span class="type">UInt16</span>(one)</span><br></pre></td></tr></table></figure></li>
<li>浮点数转为整数是直接去掉小数点后的内容(4.75-&gt;4,-3.9-&gt;3)<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> three = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> pointOneFourOneFiveNine = <span class="number">0.14159</span></span><br><span class="line"><span class="keyword">let</span> pi = <span class="type">Double</span>(three) + pointOneFourOneFiveNine</span><br><span class="line"><span class="comment">// pi equals 3.14159, and is inferred to be of type Double</span></span><br><span class="line"><span class="keyword">let</span> integerPi = <span class="type">Int</span>(pi)</span><br><span class="line"><span class="comment">// integerPi equals 3, and is inferred to be of type Int</span></span><br></pre></td></tr></table></figure></li>
<li>数字字面值的运算不需要转换<code>3+0.14159</code>的操作是可以的,因为字面值没有显示的类型,会被自动转为推断的合理类型</li>
</ul>
<h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><ul>
<li><code>typealias</code>,为已有类型定义别名<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">AudioSample</span> = <span class="type">UInt16</span></span><br><span class="line"><span class="keyword">var</span> maxAmplitudeFound = <span class="type">AudioSample</span>.<span class="built_in">min</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><ul>
<li><code>Bool</code></li>
<li><code>true</code>/<code>false</code><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> orangesAreOrange = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> turnipsAreDelicious = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> turnipsAreDelicious &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Mmm, tasty turnips!&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Eww, turnips are horrible.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;Eww, turnips are horrible.&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>不支持非0隐式转bool判断<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> i &#123;</span><br><span class="line">    <span class="comment">// this example will not compile, and will report an error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> i == <span class="number">1</span> &#123;</span><br><span class="line">    <span class="comment">// this example will compile successfully</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><ul>
<li>就是一个任意类型的元素的组合</li>
<li>使用<code>()</code>包围</li>
<li>可以直接给返回值的元组命名并使用<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> http404Error = (<span class="number">404</span>, <span class="string">&quot;Not Found&quot;</span>)</span><br><span class="line"><span class="comment">// http404Error is of type (Int, String), and equals (404, &quot;Not Found&quot;)</span></span><br><span class="line"><span class="keyword">let</span> (statusCode, statusMessage) = http404Error</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The status code is \(statusCode)&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;The status code is 404&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The status message is \(statusMessage)&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;The status message is Not Found&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>可以使用<code>\_</code>来忽略部分不需要关注的参数<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> (justTheStatusCode, <span class="number">_</span>) = http404Error</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The status code is \(justTheStatusCode)&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;The status code is 404&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>可以按照索引获取元组的元素,索引初始值为<code>0</code><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The status code is \(http404Error.0)&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;The status code is 404&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The status message is \(http404Error.1)&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;The status message is Not Found&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>可以直接为元组的元素命名,并使用<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> http200Status = (statusCode: <span class="number">200</span>, description: <span class="string">&quot;OK&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The status code is \(http200Status.statusCode)&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;The status code is 200&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The status message is \(http200Status.description)&quot;</span>)</span><br><span class="line"><span class="comment">// Prints &quot;The status message is OK&quot;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="可选数据"><a href="#可选数据" class="headerlink" title="可选数据"></a>可选数据</h2><ul>
<li>可选数据类型不是原始数据类型</li>
<li>是在原始基本类型上的封装,类似指针</li>
<li>可选数据类型可以为原始类型的值或者为nil</li>
<li>所有的原始类型都不能为nil<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a:<span class="type">Int?</span></span><br><span class="line"><span class="keyword">if</span> a != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> a != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">a = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> a != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 1 2</span></span><br></pre></td></tr></table></figure></li>
<li>当确定可选数据不是nil的时候,可以使用<code>!</code>获取参数内部包含值<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> a != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(a!)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在nil值上使用<code>!</code>获取数据会产生运行时错误,产生core文件</li>
<li>可选数据绑定<ul>
<li>可以直接在<code>if</code>,<code>while</code>中绑定可选参数,将其转为常规类型值<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a:<span class="type">Int?</span> = <span class="literal">nil</span></span><br><span class="line">a = <span class="number">199</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> b = a &#123;</span><br><span class="line">        <span class="built_in">print</span>(b)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>可选绑定不是引用绑定,改变绑定后的值并不会影响可选数据<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a:<span class="type">Int?</span> = <span class="literal">nil</span></span><br><span class="line">a = <span class="number">199</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">var</span> b = a &#123;</span><br><span class="line">        <span class="built_in">print</span>(b) <span class="comment">// 199</span></span><br><span class="line">        b = <span class="number">998</span></span><br><span class="line">        <span class="built_in">print</span>(b) <span class="comment">// 998</span></span><br><span class="line">        <span class="built_in">print</span>(a) <span class="comment">// 199</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>if</code>中可以使用<code>,</code>作为条件分隔,表示并列的关系,只有当所有条件都满足时,才会执行<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstNumber = <span class="type">Int</span>(<span class="string">&quot;4&quot;</span>), <span class="keyword">let</span> secondNumber = <span class="type">Int</span>(<span class="string">&quot;42&quot;</span>), firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; <span class="number">100</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\(firstNumber) &lt; \(secondNumber) &lt; 100&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;4 &lt; 42 &lt; 100&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstNumber = <span class="type">Int</span>(<span class="string">&quot;4&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> secondNumber = <span class="type">Int</span>(<span class="string">&quot;42&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\(firstNumber) &lt; \(secondNumber) &lt; 100&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints &quot;4 &lt; 42 &lt; 100&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><code>if</code>的条件语句中定义的变量只能在<code>if</code>中使用,即时是在<code>else</code>中也是用不了的<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> a = <span class="type">Int</span>(<span class="string">&quot;10&quot;</span>), a &lt; <span class="number">10</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">1</span>, a) <span class="comment">// 可以使用a</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">2</span>) <span class="comment">// 不可以使用a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Implicitly Unwrapped Optional Properties<ul>
<li>就是当一个可选类型的值必定存在时,可以将它设置为这个类型</li>
<li>如果可选类型为nil,使用这个类型同样会报错</li>
<li><strong>现在完全不明白这个东西的意义</strong><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> possibleString: <span class="type">String?</span> = <span class="string">&quot;An optional string.&quot;</span></span><br><span class="line"><span class="keyword">let</span> forcedString: <span class="type">String</span> = possibleString! <span class="comment">// requires an exclamation mark</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> assumedString: <span class="type">String!</span> = <span class="string">&quot;An implicitly unwrapped optional string.&quot;</span></span><br><span class="line"><span class="keyword">let</span> implicitString: <span class="type">String</span> = assumedString <span class="comment">// no need for an exclamation mark</span></span><br></pre></td></tr></table></figure></li>
<li>使用可以和可选类型一样<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> possibleString: <span class="type">String?</span> = <span class="literal">nil</span></span><br><span class="line"><span class="comment">//let forcedString: String = possibleString! // requires an exclamation mark // 运行时错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> assumedString: <span class="type">String!</span> = possibleString</span><br><span class="line"><span class="comment">//let implicitString: String = assumedString // no need for an exclamation mark // 运行时错误</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> a = assumedString &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">1</span>, a)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ul>
<li>函数可以抛出异常<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canThrowAnError</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">	<span class="comment">// this function may or may not throw an error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>异常会在被捕获前不断向上抛出<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> canThrowAnError()</span><br><span class="line">    <span class="comment">// no error was thrown</span></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="comment">// an error was thrown</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>可以有多个catch<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeASandwich</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> makeASandwich()</span><br><span class="line">    eatASandwich()</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">SandwichError</span>.outOfCleanDishes &#123;</span><br><span class="line">    washDishes()</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">SandwichError</span>.missingIngredients(<span class="keyword">let</span> ingredients) &#123;</span><br><span class="line">    buyGroceries(ingredients)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="断言和预判断-assertions-amp-preconditions"><a href="#断言和预判断-assertions-amp-preconditions" class="headerlink" title="断言和预判断(assertions &amp; preconditions)"></a>断言和预判断(assertions &amp; preconditions)</h2><ul>
<li>会产生<code>core</code>文件</li>
<li>和错误处理不同,断言和预判断报错,都表明当前程序的运行状态是错误的,是没有办法做错误处理的</li>
<li>更容易找到错误的问题</li>
<li>断言和预判断的不同<ul>
<li>断言只在debug编译模式中有效(所以使用很多断言并不会有性能影响)</li>
<li>预判断在debug和production版本都有效</li>
</ul>
</li>
</ul>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><ul>
<li>函数原型:<code>assert(_:_:file:line:)</code><ul>
<li>参数:<ul>
<li><code>Bool</code>,触发条件,<code>true</code>不会触发,<code>false</code>触发断言</li>
<li><code>String</code>,说明字符串,当触发断言时显示的字符串说明<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = -<span class="number">3</span></span><br><span class="line"><span class="built_in">assert</span>(age &gt;= <span class="number">0</span>, <span class="string">&quot;A person&#x27;s age can&#x27;t be less than zero.&quot;</span>)</span><br><span class="line"><span class="comment">// This assertion fails because -3 is not &gt;= 0.</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>当正常条件已经在其他语句中判断过了的时候,可以直接使用:<code>assertionFailure(_:file:line:)</code>来进行断言报错<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> age &gt; <span class="number">10</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;You can ride the roller-coaster or the ferris wheel.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> age &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;You can ride the ferris wheel.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">assertionFailure</span>(<span class="string">&quot;A person&#x27;s age can&#x27;t be less than zero.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="强制的预判断"><a href="#强制的预判断" class="headerlink" title="强制的预判断"></a>强制的预判断</h3><ul>
<li>当条件可能为假,但是要程序继续运行下去必须为真的情况下使用</li>
<li>函数原型:<code>precondition(_:_:file:line:)</code><ul>
<li>参数:同<code>assert</code><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> index = -<span class="number">1</span></span><br><span class="line"><span class="built_in">precondition</span>(index &gt; <span class="number">0</span>, <span class="string">&quot;Index must be greater than zero.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(index)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>同理,还有<code>preconditionFailure(_:file:line:)</code>来直接触发<code>core</code>dump</li>
<li><strong>当编译选项开启”unchecked”选项时,编译器会忽略所有的preconditions内容,对代码进行优化</strong>,导致preconditions无效,而<code>fatalError(_:file:line:)</code>函数无论是否有该编译选项,都会终止程序的继续执行</li>
<li>可以使用<code>fatalError(&quot;Unimplemented&quot;)</code>这样的代码表示程序功能还没有实现,用于记录功能的实现程度</li>
</ul>
]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title>a</title>
    <url>/2018/03/27/test/</url>
    <content><![CDATA[<h1 id="Test1"><a href="#Test1" class="headerlink" title="Test1"></a>Test1</h1><h2 id="a"><a href="#a" class="headerlink" title="a"></a>a</h2><ul>
<li>b</li>
<li>c</li>
<li>d</li>
</ul>
<a id="more"></a>

<h2 id="e"><a href="#e" class="headerlink" title="e"></a>e</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="number">10</span></span><br><span class="line">fmt.Println(a)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>线程,信号示例</title>
    <url>/2018/06/08/thread-signal/</url>
    <content><![CDATA[<p>简单的c++11线程使用<br>简单的信号处理</p>
<a id="more"></a>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execinfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (flag)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		this_thread::sleep_for(chrono::seconds(<span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SignalHandler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 还原信号的处理方式</span></span><br><span class="line">	signal(sig, SIG_DFL);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 输出下堆栈</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> maxFrames = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">void</span>* frames[maxFrames];</span><br><span class="line">	<span class="built_in">string</span> result;</span><br><span class="line">	<span class="keyword">int</span> numFrames = backtrace(frames, maxFrames);</span><br><span class="line">	<span class="keyword">char</span>** symbols = backtrace_symbols(frames, numFrames);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numFrames; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; frames[i] &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; symbols[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 停止运行</span></span><br><span class="line">	flag = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RegistSignalHandler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 注册监听的信号handler函数</span></span><br><span class="line">	signal(SIGINT, SignalHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;开始&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	RegistSignalHandler();</span><br><span class="line"></span><br><span class="line">	<span class="function">thread <span class="title">td</span><span class="params">(&amp;test)</span></span>;</span><br><span class="line"></span><br><span class="line">	td.join();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;结束&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>thread</tag>
        <tag>signal</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis算法 LRU</title>
    <url>/2018/05/22/redis-algorithmic-lru/</url>
    <content><![CDATA[<p>LRU(Least Recently Used)最近最少使用统计算法</p>
<p>当Redis使用的内存超出设置的可以最大使用内存后<br>Redis会通过LRU的配置来回收内存<br>Redis对象的lru是用1&lt;&lt;24 - 1长度的字节表示的<br>可以连续标识194天的数据</p>
<p>Redis这里的LRU算法是近似算法<br>不是完全精确地获取到最合理的答案<br>而是按照采样结果查找到一个比较近似的结果<br>这个结果可能不是最合理的<br>但肯定不是最坏的</p>
<a id="more"></a>

<h2 id="经典LRU算法"><a href="#经典LRU算法" class="headerlink" title="经典LRU算法"></a>经典LRU算法</h2><p>通过dict和linkedlist两个数据结构处理<br>dict记录实际数据<br>linkedlist记录元素的变动状态<br>最老的数据排在链表前面<br>当需要删除时<br>只需要按照链表顺序删除即可</p>
<h2 id="LRU基本流程"><a href="#LRU基本流程" class="headerlink" title="LRU基本流程"></a>LRU基本流程</h2><img src="/2018/05/22/redis-algorithmic-lru/lru_describe.png" class="" title="lru describe">

<h2 id="Redis中LRU处理步骤"><a href="#Redis中LRU处理步骤" class="headerlink" title="Redis中LRU处理步骤"></a>Redis中LRU处理步骤</h2><p>Redis的算法省去了链表的记录<br>而是每个对象记录了一个时间戳<br>通过不精确的采样获取到可删除的元素进行删除</p>
<p><strong>这里是摘抄</strong><br><a href="http://blog.chinaunix.net/uid-20708886-id-5753422.html">原文</a></p>
<ol>
<li>获取redis server当前已经使用的内存mem_reported。</li>
<li>如果mem_reported &lt; server.maxmemory ,则返回ok。否则mem_used=mem_reported，进入步骤3。</li>
<li>遍历该redis的所slaves，mem_used减去所有slave占用的ClientOutputBuffer。</li>
<li>如果配置了AOF，mem_used减去AOF占用的空间。sdslen(server.aof_buf)+aofRewriteBufferSize()。</li>
<li>如果mem_used &lt; server.maxmemory,返回ok。否则进入步骤6。</li>
<li>如果内存策略配置为noeviction，返回错误。否则进入7。 </li>
<li>如果是LRU策略,如果是VOLATILE的LRU，则每次从可失效的数据集中，每次随机采样maxmemory_samples(默认为5)个key,从中选取idletime最大的key进行淘汰。否则，如果是ALLKEYS_LRU则从全局数据中进行采样，每次随机采样maxmemory_samples(默认为5)个key，并从中选择idletime最大的key进行淘汰。</li>
<li>如果释放内存之后，还是超过了server.maxmemory,则继续淘汰，只到释放后剩下的内存小于server.maxmemory为止。<br> 被动淘汰 – 每次访问相关的key，如果发现key过期，直接释放掉该key相关的内存:<br> 每次访问key，都会调用expireIfNeeded来判断key是否过期，如果过期，则释放掉，并返回null，否则返回key的值。</li>
</ol>
<h2 id="Redis中LRU配置"><a href="#Redis中LRU配置" class="headerlink" title="Redis中LRU配置"></a>Redis中LRU配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># maxmemory &lt;bytes&gt; # 只有配置了最大使用内存,LRU才会生效,不限制内存就不需要回收了</span><br><span class="line"></span><br><span class="line"># MAXMEMORY POLICY: how Redis will select what to remove when maxmemory</span><br><span class="line"># is reached. You can select among five behaviors:</span><br><span class="line">#</span><br><span class="line"># volatile-lru -&gt; remove the key with an expire set using an LRU algorithm # 有过期时间的键按照LRU算法回收</span><br><span class="line"># allkeys-lru -&gt; remove any key according to the LRU algorithm # 所有键按照LRU算法回收</span><br><span class="line"># volatile-random -&gt; remove a random key with an expire set # 有过期时间的键随机回收</span><br><span class="line"># allkeys-random -&gt; remove a random key, any key # 所有键随机回收</span><br><span class="line"># volatile-ttl -&gt; remove the key with the nearest expire time (minor TTL) # 按照过期时间最近的顺序回收</span><br><span class="line"># noeviction -&gt; don&#39;t expire at all, just return an error on write operations # 不回收,所有写操作返回失败</span><br><span class="line">#</span><br><span class="line"># Note: with any of the above policies, Redis will return an error on write</span><br><span class="line">#       operations, when there are no suitable keys for eviction.</span><br><span class="line">#</span><br><span class="line">#       At the date of writing these commands are: set setnx setex append</span><br><span class="line">#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</span><br><span class="line">#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</span><br><span class="line">#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</span><br><span class="line">#       getset mset msetnx exec sort</span><br><span class="line">#</span><br><span class="line"># The default is:</span><br><span class="line">#</span><br><span class="line"># maxmemory-policy noeviction # 默认LRU处理方式</span><br><span class="line"></span><br><span class="line"># LRU and minimal TTL algorithms are not precise algorithms but approximated</span><br><span class="line"># algorithms (in order to save memory), so you can tune it for speed or</span><br><span class="line"># accuracy. For default Redis will check five keys and pick the one that was</span><br><span class="line"># used less recently, you can change the sample size using the following</span><br><span class="line"># configuration directive.</span><br><span class="line">#</span><br><span class="line"># The default of 5 produces good enough results. 10 Approximates very closely</span><br><span class="line"># true LRU but costs a bit more CPU. 3 is very fast but not very accurate.</span><br><span class="line">#</span><br><span class="line"># maxmemory-samples 5 # 默认采样数量</span><br></pre></td></tr></table></figure>

<h2 id="LRU标记代码"><a href="#LRU标记代码" class="headerlink" title="LRU标记代码"></a>LRU标记代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The actual Redis Object */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_BITS 24</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_CLOCK_MAX ((1<span class="meta-string">&lt;&lt;LRU_BITS)-1) /* Max value of obj-&gt;lru */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_CLOCK_RESOLUTION 1000 <span class="comment">/* LRU clock resolution in ms */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象,所有对象robj都有lru值</span></span><br><span class="line"><span class="function">robj *<span class="title">createObject</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(*o));</span><br><span class="line">    o-&gt;type = type;</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_RAW;</span><br><span class="line">    o-&gt;ptr = ptr;</span><br><span class="line">    o-&gt;refcount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the LRU to the current lruclock (minutes resolution). */</span></span><br><span class="line">    o-&gt;lru = LRU_CLOCK();</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// server.lruclock是在serverCron中更新的,当频率不足LRU_CLOCK_RESOLUTION时,直接使用server.lruclock而无需再次运算</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_CLOCK() ((1000/server.hz &lt;= LRU_CLOCK_RESOLUTION) ? server.lruclock : getLRUClock())</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getLRUClock</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mstime()/LRU_CLOCK_RESOLUTION) &amp; LRU_CLOCK_MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找键会更新对象的LRU</span></span><br><span class="line"><span class="comment">/* Low level key lookup API, not actually called directly from commands</span></span><br><span class="line"><span class="comment"> * implementations that should instead rely on lookupKeyRead(),</span></span><br><span class="line"><span class="comment"> * lookupKeyWrite() and lookupKeyReadWithFlags(). */</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKey</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    dictEntry *de = dictFind(db-&gt;dict,key-&gt;ptr);</span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        robj *val = dictGetVal(de);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update the access time for the ageing algorithm.</span></span><br><span class="line"><span class="comment">         * Don&#x27;t do it if we have a saving child, as this will trigger</span></span><br><span class="line"><span class="comment">         * a copy on write madness. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.rdb_child_pid == <span class="number">-1</span> &amp;&amp;</span><br><span class="line">            server.aof_child_pid == <span class="number">-1</span> &amp;&amp;</span><br><span class="line">            !(flags &amp; LOOKUP_NOTOUCH))</span><br><span class="line">        &#123;</span><br><span class="line">            val-&gt;lru = LRU_CLOCK();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="回收代码"><a href="#回收代码" class="headerlink" title="回收代码"></a>回收代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内存回收函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">freeMemoryIfNeeded</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> mem_used, mem_tofree, mem_freed;</span><br><span class="line">    <span class="keyword">int</span> slaves = listLength(server.slaves);</span><br><span class="line">    <span class="keyword">mstime_t</span> latency, eviction_latency;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When clients are paused the dataset should be static not just from the</span></span><br><span class="line"><span class="comment">     * POV of clients not being able to write, but also from the POV of</span></span><br><span class="line"><span class="comment">     * expires and evictions of keys not being performed. */</span></span><br><span class="line">    <span class="keyword">if</span> (clientsArePaused()) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Remove the size of slaves output buffers and AOF buffer from the</span></span><br><span class="line"><span class="comment">     * count of used memory. */</span></span><br><span class="line">    mem_used = zmalloc_used_memory();</span><br><span class="line">    <span class="keyword">if</span> (slaves) &#123;</span><br><span class="line">        listIter li;</span><br><span class="line">        listNode *ln;</span><br><span class="line"></span><br><span class="line">        listRewind(server.slaves,&amp;li);</span><br><span class="line">        <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">            client *slave = listNodeValue(ln);</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> obuf_bytes = getClientOutputBufferMemoryUsage(slave);</span><br><span class="line">            <span class="keyword">if</span> (obuf_bytes &gt; mem_used)</span><br><span class="line">                mem_used = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mem_used -= obuf_bytes;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (server.aof_state != AOF_OFF) &#123;</span><br><span class="line">        mem_used -= sdslen(server.aof_buf);</span><br><span class="line">        mem_used -= aofRewriteBufferSize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we are over the memory limit. */</span></span><br><span class="line">    <span class="keyword">if</span> (mem_used &lt;= server.maxmemory) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_NO_EVICTION)</span><br><span class="line">        <span class="keyword">return</span> C_ERR; <span class="comment">/* We need to free memory, but policy forbids. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Compute how much memory we need to free. */</span></span><br><span class="line">    mem_tofree = mem_used - server.maxmemory;</span><br><span class="line">    mem_freed = <span class="number">0</span>;</span><br><span class="line">    latencyStartMonitor(latency);</span><br><span class="line">    <span class="keyword">while</span> (mem_freed &lt; mem_tofree) &#123;</span><br><span class="line">        <span class="keyword">int</span> j, k, keys_freed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</span><br><span class="line">            <span class="keyword">long</span> bestval = <span class="number">0</span>; <span class="comment">/* just to prevent warning */</span></span><br><span class="line">            sds bestkey = <span class="literal">NULL</span>;</span><br><span class="line">            dictEntry *de;</span><br><span class="line">            redisDb *db = server.db+j;</span><br><span class="line">            dict *dict;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_ALLKEYS_LRU ||</span><br><span class="line">                server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM)</span><br><span class="line">            &#123;</span><br><span class="line">                dict = server.db[j].dict;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dict = server.db[j].expires;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dictSize(dict) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* volatile-random and allkeys-random policy */</span></span><br><span class="line">            <span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM ||</span><br><span class="line">                server.maxmemory_policy == MAXMEMORY_VOLATILE_RANDOM)</span><br><span class="line">            &#123;</span><br><span class="line">                de = dictGetRandomKey(dict);</span><br><span class="line">                bestkey = dictGetKey(de);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* volatile-lru and allkeys-lru policy */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_ALLKEYS_LRU ||</span><br><span class="line">                server.maxmemory_policy == MAXMEMORY_VOLATILE_LRU)</span><br><span class="line">            &#123;</span><br><span class="line">                struct evictionPoolEntry *pool = db-&gt;eviction_pool;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(bestkey == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    evictionPoolPopulate(dict, db-&gt;dict, db-&gt;eviction_pool);</span><br><span class="line">                    <span class="comment">/* Go backward from best to worst element to evict. */</span></span><br><span class="line">                    <span class="keyword">for</span> (k = MAXMEMORY_EVICTION_POOL_SIZE<span class="number">-1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (pool[k].key == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">                        de = dictFind(dict,pool[k].key);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* Remove the entry from the pool. */</span></span><br><span class="line">                        sdsfree(pool[k].key);</span><br><span class="line">                        <span class="comment">/* Shift all elements on its right to left. */</span></span><br><span class="line">                        memmove(pool+k,pool+k+<span class="number">1</span>,</span><br><span class="line">                            <span class="keyword">sizeof</span>(pool[<span class="number">0</span>])*(MAXMEMORY_EVICTION_POOL_SIZE-k<span class="number">-1</span>));</span><br><span class="line">                        <span class="comment">/* Clear the element on the right which is empty</span></span><br><span class="line"><span class="comment">                         * since we shifted one position to the left.  */</span></span><br><span class="line">                        pool[MAXMEMORY_EVICTION_POOL_SIZE<span class="number">-1</span>].key = <span class="literal">NULL</span>;</span><br><span class="line">                        pool[MAXMEMORY_EVICTION_POOL_SIZE<span class="number">-1</span>].idle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* If the key exists, is our pick. Otherwise it is</span></span><br><span class="line"><span class="comment">                         * a ghost and we need to try the next element. */</span></span><br><span class="line">                        <span class="keyword">if</span> (de) &#123;</span><br><span class="line">                            bestkey = dictGetKey(de);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">/* Ghost... */</span></span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* volatile-ttl */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_VOLATILE_TTL) &#123;</span><br><span class="line">                <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; server.maxmemory_samples; k++) &#123;</span><br><span class="line">                    sds thiskey;</span><br><span class="line">                    <span class="keyword">long</span> thisval;</span><br><span class="line"></span><br><span class="line">                    de = dictGetRandomKey(dict);</span><br><span class="line">                    thiskey = dictGetKey(de);</span><br><span class="line">                    thisval = (<span class="keyword">long</span>) dictGetVal(de);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Expire sooner (minor expire unix timestamp) is better</span></span><br><span class="line"><span class="comment">                     * candidate for deletion */</span></span><br><span class="line">                    <span class="keyword">if</span> (bestkey == <span class="literal">NULL</span> || thisval &lt; bestval) &#123;</span><br><span class="line">                        bestkey = thiskey;</span><br><span class="line">                        bestval = thisval;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Finally remove the selected key. */</span></span><br><span class="line">            <span class="keyword">if</span> (bestkey) &#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> delta;</span><br><span class="line"></span><br><span class="line">                robj *keyobj = createStringObject(bestkey,sdslen(bestkey));</span><br><span class="line">                propagateExpire(db,keyobj);</span><br><span class="line">                <span class="comment">/* We compute the amount of memory freed by dbDelete() alone.</span></span><br><span class="line"><span class="comment">                 * It is possible that actually the memory needed to propagate</span></span><br><span class="line"><span class="comment">                 * the DEL in AOF and replication link is greater than the one</span></span><br><span class="line"><span class="comment">                 * we are freeing removing the key, but we can&#x27;t account for</span></span><br><span class="line"><span class="comment">                 * that otherwise we would never exit the loop.</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * AOF and Output buffer memory will be freed eventually so</span></span><br><span class="line"><span class="comment">                 * we only care about memory used by the key space. */</span></span><br><span class="line">                delta = (<span class="keyword">long</span> <span class="keyword">long</span>) zmalloc_used_memory();</span><br><span class="line">                latencyStartMonitor(eviction_latency);</span><br><span class="line">                dbDelete(db,keyobj);</span><br><span class="line">                latencyEndMonitor(eviction_latency);</span><br><span class="line">                latencyAddSampleIfNeeded(<span class="string">&quot;eviction-del&quot;</span>,eviction_latency);</span><br><span class="line">                latencyRemoveNestedEvent(latency,eviction_latency);</span><br><span class="line">                delta -= (<span class="keyword">long</span> <span class="keyword">long</span>) zmalloc_used_memory();</span><br><span class="line">                mem_freed += delta;</span><br><span class="line">                server.stat_evictedkeys++;</span><br><span class="line">                notifyKeyspaceEvent(NOTIFY_EVICTED, <span class="string">&quot;evicted&quot;</span>,</span><br><span class="line">                    keyobj, db-&gt;id);</span><br><span class="line">                decrRefCount(keyobj);</span><br><span class="line">                keys_freed++;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* When the memory to free starts to be big enough, we may</span></span><br><span class="line"><span class="comment">                 * start spending so much time here that is impossible to</span></span><br><span class="line"><span class="comment">                 * deliver data to the slaves fast enough, so we force the</span></span><br><span class="line"><span class="comment">                 * transmission here inside the loop. */</span></span><br><span class="line">                <span class="keyword">if</span> (slaves) flushSlavesOutputBuffers();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!keys_freed) &#123;</span><br><span class="line">            latencyEndMonitor(latency);</span><br><span class="line">            latencyAddSampleIfNeeded(<span class="string">&quot;eviction-cycle&quot;</span>,latency);</span><br><span class="line">            <span class="keyword">return</span> C_ERR; <span class="comment">/* nothing to free... */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    latencyEndMonitor(latency);</span><br><span class="line">    latencyAddSampleIfNeeded(<span class="string">&quot;eviction-cycle&quot;</span>,latency);</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 筛选出可以回收的键</span></span><br><span class="line"><span class="comment">/* This is an helper function for freeMemoryIfNeeded(), it is used in order</span></span><br><span class="line"><span class="comment"> * to populate the evictionPool with a few entries every time we want to</span></span><br><span class="line"><span class="comment"> * expire a key. Keys with idle time smaller than one of the current</span></span><br><span class="line"><span class="comment"> * keys are added. Keys are always added if there are free entries.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We insert keys on place in ascending order, so keys with the smaller</span></span><br><span class="line"><span class="comment"> * idle time are on the left, and keys with the higher idle time on the</span></span><br><span class="line"><span class="comment"> * right. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVICTION_SAMPLES_ARRAY_SIZE 16</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evictionPoolPopulate</span><span class="params">(dict *sampledict, dict *keydict, struct evictionPoolEntry *pool)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, k, count;</span><br><span class="line">    dictEntry *_samples[EVICTION_SAMPLES_ARRAY_SIZE];</span><br><span class="line">    dictEntry **samples;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Try to use a static buffer: this function is a big hit...</span></span><br><span class="line"><span class="comment">     * Note: it was actually measured that this helps. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory_samples &lt;= EVICTION_SAMPLES_ARRAY_SIZE) &#123;</span><br><span class="line">        samples = _samples;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        samples = zmalloc(<span class="keyword">sizeof</span>(samples[<span class="number">0</span>])*server.maxmemory_samples);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    count = dictGetSomeKeys(sampledict,samples,server.maxmemory_samples);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> idle;</span><br><span class="line">        sds key;</span><br><span class="line">        robj *o;</span><br><span class="line">        dictEntry *de;</span><br><span class="line"></span><br><span class="line">        de = samples[j];</span><br><span class="line">        key = dictGetKey(de);</span><br><span class="line">        <span class="comment">/* If the dictionary we are sampling from is not the main</span></span><br><span class="line"><span class="comment">         * dictionary (but the expires one) we need to lookup the key</span></span><br><span class="line"><span class="comment">         * again in the key dictionary to obtain the value object. */</span></span><br><span class="line">        <span class="keyword">if</span> (sampledict != keydict) de = dictFind(keydict, key);</span><br><span class="line">        o = dictGetVal(de);</span><br><span class="line">        idle = estimateObjectIdleTime(o);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Insert the element inside the pool.</span></span><br><span class="line"><span class="comment">         * First, find the first empty bucket or the first populated</span></span><br><span class="line"><span class="comment">         * bucket that has an idle time smaller than our idle time. */</span></span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; MAXMEMORY_EVICTION_POOL_SIZE &amp;&amp;</span><br><span class="line">               pool[k].key &amp;&amp;</span><br><span class="line">               pool[k].idle &lt; idle) k++;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> &amp;&amp; pool[MAXMEMORY_EVICTION_POOL_SIZE<span class="number">-1</span>].key != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Can&#x27;t insert if the element is &lt; the worst element we have</span></span><br><span class="line"><span class="comment">             * and there are no empty buckets. */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; MAXMEMORY_EVICTION_POOL_SIZE &amp;&amp; pool[k].key == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Inserting into empty position. No setup needed before insert. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Inserting in the middle. Now k points to the first element</span></span><br><span class="line"><span class="comment">             * greater than the element to insert.  */</span></span><br><span class="line">            <span class="keyword">if</span> (pool[MAXMEMORY_EVICTION_POOL_SIZE<span class="number">-1</span>].key == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">/* Free space on the right? Insert at k shifting</span></span><br><span class="line"><span class="comment">                 * all the elements from k to end to the right. */</span></span><br><span class="line">                memmove(pool+k+<span class="number">1</span>,pool+k,</span><br><span class="line">                    <span class="keyword">sizeof</span>(pool[<span class="number">0</span>])*(MAXMEMORY_EVICTION_POOL_SIZE-k<span class="number">-1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* No free space on right? Insert at k-1 */</span></span><br><span class="line">                k--;</span><br><span class="line">                <span class="comment">/* Shift all elements on the left of k (included) to the</span></span><br><span class="line"><span class="comment">                 * left, so we discard the element with smaller idle time. */</span></span><br><span class="line">                sdsfree(pool[<span class="number">0</span>].key);</span><br><span class="line">                memmove(pool,pool+<span class="number">1</span>,<span class="keyword">sizeof</span>(pool[<span class="number">0</span>])*k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pool[k].key = sdsdup(key);</span><br><span class="line">        pool[k].idle = idle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (samples != _samples) zfree(samples);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>algorithmic</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 源码分析-quicklist</title>
    <url>/2018/05/09/redis-source-quicklist/</url>
    <content><![CDATA[<p><strong>这个数据结构分析的比较粗糙,因为实际使用的是redis2.8没有用这个结构.时间不够用了,先把代码粘过来</strong><br>Redis3.2版本新增数据结构<br>代替原有的list的功能<br>本质是一个双向链表,<br>链表的节点是ziplist,<br>而不是具体的值<br>同时增加了压缩选项<br>可已将ziplist数据进行压缩<br>压缩算法为lzf算法<br>与原始链表对比<br>    - 原始链表定位特定元素时耗时较大<br>    - 原始链表元素分散,容易产生较多内存碎片<br>基本操作原理<br>向ql插入数据时<br>先获得头/尾的zl<br>当zl数量没有超过指定的zl元素数上限时<br>直接在zl中插入数据,<br>否则新建节点和空的zl,<br>然后再插入数据</p>
<h2 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h2><ul>
<li>quicklist.h</li>
<li>quicklist.c<a id="more"></a>

</li>
</ul>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul>
<li>likely/unlikely 分支预测<br>  简单说就是从内存取指令很慢,cpu要等待这个过程<br>  如果能提前预测可能执行的指令,就提前从内存把指令读到cache<br>  由于cache的访问速度较内存快.cpu要执行时就不用等很长时间了<br>  如果开发人员可以告诉编译器,<br>  哪个分支更有可能发生(likely)或者非常不可能发生(unlikely),<br>  可以帮助编译器进行代码编译</li>
<li>数据的一般长度<br>  和系统位数,编译器有关,这里只是一般的情况(x64)<br>  类型 | 位数<br>  -|<br>  int | 4<br>  long | 8<br>  char* | 8</li>
<li>数据对齐  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">a</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> a:<span class="number">8</span>;</span><br><span class="line">	<span class="keyword">int</span> b:<span class="number">8</span>;</span><br><span class="line">	<span class="keyword">int</span> c:<span class="number">16</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  中<code>sizeof(struct a)</code>的长度实际就是一个<code>sizeof(int)</code>的长度<br>  其中<code>a.a</code>的范围是-128<del>127,<code>a.c</code>的范围是-2^15</del>2^15-1</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Node, quicklist, and Iterator are the only data structures used currently. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* quicklistNode is a 32 byte struct describing a ziplist for a quicklist.</span></span><br><span class="line"><span class="comment"> * We use bit fields keep the quicklistNode at 32 bytes.</span></span><br><span class="line"><span class="comment"> * count: 16 bits, max 65536 (max zl bytes is 65k, so max count actually &lt; 32k).</span></span><br><span class="line"><span class="comment"> * encoding: 2 bits, RAW=1, LZF=2.</span></span><br><span class="line"><span class="comment"> * container: 2 bits, NONE=1, ZIPLIST=2.</span></span><br><span class="line"><span class="comment"> * recompress: 1 bit, bool, true if node is temporarry decompressed for usage.</span></span><br><span class="line"><span class="comment"> * attempted_compress: 1 bit, boolean, used for verifying during testing.</span></span><br><span class="line"><span class="comment"> * extra: 12 bits, free for future use; pads out the remainder of 32 bits */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span> <span class="comment">// 节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span> <span class="comment">// 前一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span> <span class="comment">// 后一个节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl; <span class="comment">// ziplist列表(压缩后是lzf数据)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz;             <span class="comment">/* ziplist size in bytes */</span> <span class="comment">// ziplist的字节数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count : <span class="number">16</span>;     <span class="comment">/* count of items in ziplist */</span> <span class="comment">// ziplist的元素个数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> encoding : <span class="number">2</span>;   <span class="comment">/* RAW==1 or LZF==2 */</span> <span class="comment">// zl的编码,是原始的ziplist还是lzf压缩后的数据</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> container : <span class="number">2</span>;  <span class="comment">/* NONE==1 or ZIPLIST==2 */</span> <span class="comment">// 数据存储方式,当前实际只有ziplist方式</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> recompress : <span class="number">1</span>; <span class="comment">/* was this node previous compressed? */</span> <span class="comment">// 解压标记,读取已压缩数据时需要先解压,读取,然后在恢复压缩</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* node can&#x27;t compress; too small */</span> <span class="comment">// 尝试压缩,测试用</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> extra : <span class="number">10</span>; <span class="comment">/* more bits to steal for future usage */</span> <span class="comment">// 预留数据</span></span><br><span class="line">&#125; quicklistNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* quicklistLZF is a 4+N byte struct holding &#x27;sz&#x27; followed by &#x27;compressed&#x27;.</span></span><br><span class="line"><span class="comment"> * &#x27;sz&#x27; is byte length of &#x27;compressed&#x27; field.</span></span><br><span class="line"><span class="comment"> * &#x27;compressed&#x27; is LZF data with total (compressed) length &#x27;sz&#x27;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> uncompressed length is stored in quicklistNode-&gt;sz.</span></span><br><span class="line"><span class="comment"> * When quicklistNode-&gt;zl is compressed, node-&gt;zl points to a quicklistLZF */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistLZF</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz; <span class="comment">/* LZF size in bytes*/</span> <span class="comment">// 压缩后的字节数</span></span><br><span class="line">    <span class="keyword">char</span> compressed[]; <span class="comment">// 压缩数据</span></span><br><span class="line">&#125; quicklistLZF;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* quicklist is a 32 byte struct (on 64-bit systems) describing a quicklist.</span></span><br><span class="line"><span class="comment"> * &#x27;count&#x27; is the number of total entries.</span></span><br><span class="line"><span class="comment"> * &#x27;len&#x27; is the number of quicklist nodes.</span></span><br><span class="line"><span class="comment"> * &#x27;compress&#x27; is: -1 if compression disabled, otherwise it&#x27;s the number</span></span><br><span class="line"><span class="comment"> *                of quicklistNodes to leave uncompressed at ends of quicklist.</span></span><br><span class="line"><span class="comment"> * &#x27;fill&#x27; is the user-requested (or default) fill factor. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    quicklistNode *head; <span class="comment">// 头元素</span></span><br><span class="line">    quicklistNode *tail; <span class="comment">// 尾元素</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> count;        <span class="comment">/* total count of all entries in all ziplists */</span> <span class="comment">// 所有ziplist的总共元素个数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;           <span class="comment">/* number of quicklistNodes */</span> <span class="comment">// ziplist的数量</span></span><br><span class="line">    <span class="keyword">int</span> fill : <span class="number">16</span>;              <span class="comment">/* fill factor for individual nodes */</span> <span class="comment">// 每个ziplist可以存放的元素数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> compress : <span class="number">16</span>; <span class="comment">/* depth of end nodes not to compress;0=off */</span> <span class="comment">// 链表头尾的前X个节点不进行lzf压缩,中间的节点的ziplist都进行压缩.0:关闭压缩功能</span></span><br><span class="line">&#125; quicklist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistIter</span> &#123;</span> <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="keyword">const</span> quicklist *quicklist; <span class="comment">// 迭代的quicklist</span></span><br><span class="line">    quicklistNode *current; <span class="comment">// 当前迭代的节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zi; <span class="comment">// 当前迭代的数据节点起始指针</span></span><br><span class="line">    <span class="keyword">long</span> offset; <span class="comment">/* offset in current ziplist */</span> <span class="comment">// 当前迭代的ziplist的偏移</span></span><br><span class="line">    <span class="keyword">int</span> direction; <span class="comment">// 方向</span></span><br><span class="line">&#125; quicklistIter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistEntry</span> &#123;</span> <span class="comment">// quicklist节点</span></span><br><span class="line">    <span class="keyword">const</span> quicklist *quicklist; <span class="comment">// 所在的quicklist</span></span><br><span class="line">    quicklistNode *node; <span class="comment">// 所在的节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zi; <span class="comment">// 所在的ziplistEntry</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *value; <span class="comment">// 值,字符串</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> longval; <span class="comment">// 值,数字</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz; <span class="comment">// 所在的节点的字节大小</span></span><br><span class="line">    <span class="keyword">int</span> offset; <span class="comment">// 所在节点在ziplist的偏移</span></span><br><span class="line">&#125; quicklistEntry;</span><br></pre></td></tr></table></figure>

<h2 id="主要宏"><a href="#主要宏" class="headerlink" title="主要宏"></a>主要宏</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUICKLIST_HEAD 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUICKLIST_TAIL -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* quicklist node encodings */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUICKLIST_NODE_ENCODING_RAW 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUICKLIST_NODE_ENCODING_LZF 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* quicklist compression disable */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUICKLIST_NOCOMPRESS 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* quicklist container formats */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUICKLIST_NODE_CONTAINER_NONE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUICKLIST_NODE_CONTAINER_ZIPLIST 2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> quicklistNodeIsCompressed(node)                                        \</span></span><br><span class="line">    ((node)-&gt;encoding == QUICKLIST_NODE_ENCODING_LZF)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Maximum size in bytes of any multi-element ziplist.</span></span><br><span class="line"><span class="comment"> * Larger values will live in their own isolated ziplists. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_SAFETY_LIMIT 8192</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Minimum ziplist size in bytes for attempting compression. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_COMPRESS_BYTES 48</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Minimum size reduction in bytes to store compressed quicklistNode data.</span></span><br><span class="line"><span class="comment"> * This also prevents us from storing compression if the compression</span></span><br><span class="line"><span class="comment"> * resulted in a larger size than the original data. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_COMPRESS_IMPROVE 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Simple way to give quicklistEntry structs default values with one call. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> initEntry(e)                                                           \</span></span><br><span class="line">    <span class="keyword">do</span> &#123;                                                                       \</span><br><span class="line">        (e)-&gt;zi = (e)-&gt;value = <span class="literal">NULL</span>;                                           \</span><br><span class="line">        (e)-&gt;longval = <span class="number">-123456789</span>;                                             \</span><br><span class="line">        (e)-&gt;quicklist = <span class="literal">NULL</span>;                                                 \</span><br><span class="line">        (e)-&gt;node = <span class="literal">NULL</span>;                                                      \</span><br><span class="line">        (e)-&gt;offset = <span class="number">123456789</span>;                                               \</span><br><span class="line">        (e)-&gt;sz = <span class="number">0</span>;                                                           \</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h2><h3 id="quicklist-quicklistCreate-void"><a href="#quicklist-quicklistCreate-void" class="headerlink" title="quicklist *quicklistCreate(void);"></a><code>quicklist *quicklistCreate(void);</code></h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>创建一个空的quicklist</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create a new quicklist.</span></span><br><span class="line"><span class="comment"> * Free with quicklistRelease(). */</span></span><br><span class="line"><span class="function">quicklist *<span class="title">quicklistCreate</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> *<span class="title">quicklist</span>;</span></span><br><span class="line"></span><br><span class="line">    quicklist = zmalloc(<span class="keyword">sizeof</span>(*quicklist));</span><br><span class="line">    quicklist-&gt;head = quicklist-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    quicklist-&gt;len = <span class="number">0</span>;</span><br><span class="line">    quicklist-&gt;count = <span class="number">0</span>;</span><br><span class="line">    quicklist-&gt;compress = <span class="number">0</span>;</span><br><span class="line">    quicklist-&gt;fill = <span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">return</span> quicklist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="REDIS-STATIC-quicklistNode-quicklistCreateNode-void"><a href="#REDIS-STATIC-quicklistNode-quicklistCreateNode-void" class="headerlink" title="REDIS_STATIC quicklistNode *quicklistCreateNode(void);"></a><code>REDIS_STATIC quicklistNode *quicklistCreateNode(void);</code></h3><h4 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h4><p>创建一个空的quicklist节点</p>
<h4 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">REDIS_STATIC quicklistNode *<span class="title">quicklistCreateNode</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    quicklistNode *node;</span><br><span class="line">    node = zmalloc(<span class="keyword">sizeof</span>(*node));</span><br><span class="line">    node-&gt;zl = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;count = <span class="number">0</span>;</span><br><span class="line">    node-&gt;sz = <span class="number">0</span>;</span><br><span class="line">    node-&gt;next = node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;encoding = QUICKLIST_NODE_ENCODING_RAW;</span><br><span class="line">    node-&gt;container = QUICKLIST_NODE_CONTAINER_ZIPLIST;</span><br><span class="line">    node-&gt;recompress = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void-quicklistRelease-quicklist-quicklist"><a href="#void-quicklistRelease-quicklist-quicklist" class="headerlink" title="void quicklistRelease(quicklist *quicklist);"></a><code>void quicklistRelease(quicklist *quicklist);</code></h3><h4 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h4><p>释放完整的quicklist</p>
<h4 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Free entire quicklist. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistRelease</span><span class="params">(quicklist *quicklist)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    quicklistNode *current, *next;</span><br><span class="line"></span><br><span class="line">    current = quicklist-&gt;head;</span><br><span class="line">    len = quicklist-&gt;len;</span><br><span class="line">    <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">        next = current-&gt;next;</span><br><span class="line"></span><br><span class="line">        zfree(current-&gt;zl);</span><br><span class="line">        quicklist-&gt;count -= current-&gt;count;</span><br><span class="line"></span><br><span class="line">        zfree(current);</span><br><span class="line"></span><br><span class="line">        quicklist-&gt;len--;</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    zfree(quicklist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="REDIS-STATIC-void-quicklistInsertNode-quicklist-quicklist-quicklistNode-old-node-quicklistNode-new-node-int-after"><a href="#REDIS-STATIC-void-quicklistInsertNode-quicklist-quicklist-quicklistNode-old-node-quicklistNode-new-node-int-after" class="headerlink" title="REDIS_STATIC void __quicklistInsertNode(quicklist *quicklist, quicklistNode *old_node, quicklistNode *new_node, int after);"></a><code>REDIS_STATIC void __quicklistInsertNode(quicklist *quicklist, quicklistNode *old_node, quicklistNode *new_node, int after);</code></h3><h4 id="功能-3"><a href="#功能-3" class="headerlink" title="功能"></a>功能</h4><p>quick在指定节点的前/后插入新的节点</p>
<h4 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Insert &#x27;new_node&#x27; after &#x27;old_node&#x27; if &#x27;after&#x27; is 1.</span></span><br><span class="line"><span class="comment"> * Insert &#x27;new_node&#x27; before &#x27;old_node&#x27; if &#x27;after&#x27; is 0.</span></span><br><span class="line"><span class="comment"> * Note: &#x27;new_node&#x27; is *always* uncompressed, so if we assign it to</span></span><br><span class="line"><span class="comment"> *       head or tail, we do not need to uncompress it. */</span></span><br><span class="line">REDIS_STATIC <span class="keyword">void</span> __quicklistInsertNode(quicklist *quicklist,</span><br><span class="line">                                        quicklistNode *old_node,</span><br><span class="line">                                        quicklistNode *new_node, <span class="keyword">int</span> after) &#123;</span><br><span class="line">    <span class="keyword">if</span> (after) &#123;</span><br><span class="line">        new_node-&gt;prev = old_node;</span><br><span class="line">        <span class="keyword">if</span> (old_node) &#123;</span><br><span class="line">            new_node-&gt;next = old_node-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (old_node-&gt;next)</span><br><span class="line">                old_node-&gt;next-&gt;prev = new_node;</span><br><span class="line">            old_node-&gt;next = new_node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (quicklist-&gt;tail == old_node)</span><br><span class="line">            quicklist-&gt;tail = new_node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        new_node-&gt;next = old_node;</span><br><span class="line">        <span class="keyword">if</span> (old_node) &#123;</span><br><span class="line">            new_node-&gt;prev = old_node-&gt;prev;</span><br><span class="line">            <span class="keyword">if</span> (old_node-&gt;prev)</span><br><span class="line">                old_node-&gt;prev-&gt;next = new_node;</span><br><span class="line">            old_node-&gt;prev = new_node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (quicklist-&gt;head == old_node)</span><br><span class="line">            quicklist-&gt;head = new_node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* If this insert creates the only element so far, initialize head/tail. */</span></span><br><span class="line">    <span class="keyword">if</span> (quicklist-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">        quicklist-&gt;head = quicklist-&gt;tail = new_node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (old_node)</span><br><span class="line">        quicklistCompress(quicklist, old_node);</span><br><span class="line"></span><br><span class="line">    quicklist-&gt;len++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="REDIS-STATIC-int-quicklistNodeAllowInsert-const-quicklistNode-node-const-int-fill-const-size-t-sz"><a href="#REDIS-STATIC-int-quicklistNodeAllowInsert-const-quicklistNode-node-const-int-fill-const-size-t-sz" class="headerlink" title="REDIS_STATIC int _quicklistNodeAllowInsert(const quicklistNode *node, const int fill, const size_t sz);"></a><code>REDIS_STATIC int _quicklistNodeAllowInsert(const quicklistNode *node, const int fill, const size_t sz);</code></h3><h4 id="功能-4"><a href="#功能-4" class="headerlink" title="功能"></a>功能</h4><p>节点中的ziplist是否还可以插入数据</p>
<h4 id="源码-4"><a href="#源码-4" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_SAFETY_LIMIT 8192</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sizeMeetsSafetyLimit(sz) ((sz) &lt;= SIZE_SAFETY_LIMIT)</span></span><br><span class="line"></span><br><span class="line">REDIS_STATIC <span class="keyword">int</span> _quicklistNodeAllowInsert(<span class="keyword">const</span> quicklistNode *node,</span><br><span class="line">                                           <span class="keyword">const</span> <span class="keyword">int</span> fill, <span class="keyword">const</span> <span class="keyword">size_t</span> sz) &#123;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!node))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ziplist_overhead;</span><br><span class="line">    <span class="comment">/* size of previous offset */</span></span><br><span class="line">    <span class="keyword">if</span> (sz &lt; <span class="number">254</span>)</span><br><span class="line">        ziplist_overhead = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ziplist_overhead = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* size of forward offset */</span></span><br><span class="line">    <span class="keyword">if</span> (sz &lt; <span class="number">64</span>)</span><br><span class="line">        ziplist_overhead += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (likely(sz &lt; <span class="number">16384</span>))</span><br><span class="line">        ziplist_overhead += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ziplist_overhead += <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* new_sz overestimates if &#x27;sz&#x27; encodes to an integer type */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> new_sz = node-&gt;sz + sz + ziplist_overhead;</span><br><span class="line">    <span class="keyword">if</span> (likely(_quicklistNodeSizeMeetsOptimizationRequirement(new_sz, fill)))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!sizeMeetsSafetyLimit(new_sz))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">int</span>)node-&gt;count &lt; fill)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int-quicklistPushHead-quicklist-quicklist-void-value-size-t-sz"><a href="#int-quicklistPushHead-quicklist-quicklist-void-value-size-t-sz" class="headerlink" title="int quicklistPushHead(quicklist *quicklist, void *value, size_t sz);"></a><code>int quicklistPushHead(quicklist *quicklist, void *value, size_t sz);</code></h3><h4 id="功能-5"><a href="#功能-5" class="headerlink" title="功能"></a>功能</h4><p>在前面插入新的数据</p>
<h4 id="源码-5"><a href="#源码-5" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Add new entry to head node of quicklist.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns 0 if used existing head.</span></span><br><span class="line"><span class="comment"> * Returns 1 if new head created. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPushHead</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">size_t</span> sz)</span> </span>&#123;</span><br><span class="line">    quicklistNode *orig_head = quicklist-&gt;head;</span><br><span class="line">    <span class="keyword">if</span> (likely(</span><br><span class="line">            _quicklistNodeAllowInsert(quicklist-&gt;head, quicklist-&gt;fill, sz))) &#123;</span><br><span class="line">        quicklist-&gt;head-&gt;zl =</span><br><span class="line">            ziplistPush(quicklist-&gt;head-&gt;zl, value, sz, ZIPLIST_HEAD);</span><br><span class="line">        quicklistNodeUpdateSz(quicklist-&gt;head);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        quicklistNode *node = quicklistCreateNode();</span><br><span class="line">        node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);</span><br><span class="line"></span><br><span class="line">        quicklistNodeUpdateSz(node);</span><br><span class="line">        _quicklistInsertNodeBefore(quicklist, quicklist-&gt;head, node);</span><br><span class="line">    &#125;</span><br><span class="line">    quicklist-&gt;count++;</span><br><span class="line">    quicklist-&gt;head-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> (orig_head != quicklist-&gt;head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int-quicklistPushTail-quicklist-quicklist-void-value-size-t-sz"><a href="#int-quicklistPushTail-quicklist-quicklist-void-value-size-t-sz" class="headerlink" title="int quicklistPushTail(quicklist *quicklist, void *value, size_t sz);"></a><code>int quicklistPushTail(quicklist *quicklist, void *value, size_t sz);</code></h3><h4 id="功能-6"><a href="#功能-6" class="headerlink" title="功能"></a>功能</h4><p>在结尾插入新的数据</p>
<h4 id="源码-6"><a href="#源码-6" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Add new entry to tail node of quicklist.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns 0 if used existing tail.</span></span><br><span class="line"><span class="comment"> * Returns 1 if new tail created. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPushTail</span><span class="params">(quicklist *quicklist, <span class="keyword">void</span> *value, <span class="keyword">size_t</span> sz)</span> </span>&#123;</span><br><span class="line">    quicklistNode *orig_tail = quicklist-&gt;tail;</span><br><span class="line">    <span class="keyword">if</span> (likely(</span><br><span class="line">            _quicklistNodeAllowInsert(quicklist-&gt;tail, quicklist-&gt;fill, sz))) &#123;</span><br><span class="line">        quicklist-&gt;tail-&gt;zl =</span><br><span class="line">            ziplistPush(quicklist-&gt;tail-&gt;zl, value, sz, ZIPLIST_TAIL);</span><br><span class="line">        quicklistNodeUpdateSz(quicklist-&gt;tail);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        quicklistNode *node = quicklistCreateNode();</span><br><span class="line">        node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_TAIL);</span><br><span class="line"></span><br><span class="line">        quicklistNodeUpdateSz(node);</span><br><span class="line">        _quicklistInsertNodeAfter(quicklist, quicklist-&gt;tail, node);</span><br><span class="line">    &#125;</span><br><span class="line">    quicklist-&gt;count++;</span><br><span class="line">    quicklist-&gt;tail-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> (orig_tail != quicklist-&gt;tail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="REDIS-STATIC-void-quicklistDelNode-quicklist-quicklist-quicklistNode-node"><a href="#REDIS-STATIC-void-quicklistDelNode-quicklist-quicklist-quicklistNode-node" class="headerlink" title="REDIS_STATIC void __quicklistDelNode(quicklist *quicklist, quicklistNode *node);"></a><code>REDIS_STATIC void __quicklistDelNode(quicklist *quicklist, quicklistNode *node);</code></h3><h4 id="功能-7"><a href="#功能-7" class="headerlink" title="功能"></a>功能</h4><p>删除节点</p>
<h4 id="源码-7"><a href="#源码-7" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">REDIS_STATIC <span class="keyword">void</span> __quicklistDelNode(quicklist *quicklist,</span><br><span class="line">                                     quicklistNode *node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next)</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;prev)</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node == quicklist-&gt;tail) &#123;</span><br><span class="line">        quicklist-&gt;tail = node-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node == quicklist-&gt;head) &#123;</span><br><span class="line">        quicklist-&gt;head = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we deleted a node within our compress depth, we</span></span><br><span class="line"><span class="comment">     * now have compressed nodes needing to be decompressed. */</span></span><br><span class="line">    __quicklistCompress(quicklist, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    quicklist-&gt;count -= node-&gt;count;</span><br><span class="line"></span><br><span class="line">    zfree(node-&gt;zl);</span><br><span class="line">    zfree(node);</span><br><span class="line">    quicklist-&gt;len--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="REDIS-STATIC-int-quicklistDelIndex-quicklist-quicklist-quicklistNode-node-unsigned-char-p"><a href="#REDIS-STATIC-int-quicklistDelIndex-quicklist-quicklist-quicklistNode-node-unsigned-char-p" class="headerlink" title="REDIS_STATIC int quicklistDelIndex(quicklist *quicklist, quicklistNode *node, unsigned char **p);"></a><code>REDIS_STATIC int quicklistDelIndex(quicklist *quicklist, quicklistNode *node, unsigned char **p);</code></h3><h4 id="功能-8"><a href="#功能-8" class="headerlink" title="功能"></a>功能</h4><p>删除指定节点的元素</p>
<h4 id="源码-8"><a href="#源码-8" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Delete one entry from list given the node for the entry and a pointer</span></span><br><span class="line"><span class="comment"> * to the entry in the node.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: quicklistDelIndex() *requires* uncompressed nodes because you</span></span><br><span class="line"><span class="comment"> *       already had to get *p from an uncompressed node somewhere.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns 1 if the entire node was deleted, 0 if node still exists.</span></span><br><span class="line"><span class="comment"> * Also updates in/out param &#x27;p&#x27; with the next offset in the ziplist. */</span></span><br><span class="line"><span class="function">REDIS_STATIC <span class="keyword">int</span> <span class="title">quicklistDelIndex</span><span class="params">(quicklist *quicklist, quicklistNode *node,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">unsigned</span> <span class="keyword">char</span> **p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gone = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    node-&gt;zl = ziplistDelete(node-&gt;zl, p);</span><br><span class="line">    node-&gt;count--;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;count == <span class="number">0</span>) &#123;</span><br><span class="line">        gone = <span class="number">1</span>;</span><br><span class="line">        __quicklistDelNode(quicklist, node);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        quicklistNodeUpdateSz(node);</span><br><span class="line">    &#125;</span><br><span class="line">    quicklist-&gt;count--;</span><br><span class="line">    <span class="comment">/* If we deleted the node, the original node is no longer valid */</span></span><br><span class="line">    <span class="keyword">return</span> gone ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void-quicklistDelEntry-quicklistIter-iter-quicklistEntry-entry"><a href="#void-quicklistDelEntry-quicklistIter-iter-quicklistEntry-entry" class="headerlink" title="void quicklistDelEntry(quicklistIter *iter, quicklistEntry *entry);"></a><code>void quicklistDelEntry(quicklistIter *iter, quicklistEntry *entry);</code></h3><h4 id="功能-9"><a href="#功能-9" class="headerlink" title="功能"></a>功能</h4><p>删除指定entry</p>
<h4 id="源码-9"><a href="#源码-9" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Delete one element represented by &#x27;entry&#x27;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#x27;entry&#x27; stores enough metadata to delete the proper position in</span></span><br><span class="line"><span class="comment"> * the correct ziplist in the correct quicklist node. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicklistDelEntry</span><span class="params">(quicklistIter *iter, quicklistEntry *entry)</span> </span>&#123;</span><br><span class="line">    quicklistNode *prev = entry-&gt;node-&gt;prev;</span><br><span class="line">    quicklistNode *next = entry-&gt;node-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> deleted_node = quicklistDelIndex((quicklist *)entry-&gt;quicklist,</span><br><span class="line">                                         entry-&gt;node, &amp;entry-&gt;zi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* after delete, the zi is now invalid for any future usage. */</span></span><br><span class="line">    iter-&gt;zi = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If current node is deleted, we must update iterator node and offset. */</span></span><br><span class="line">    <span class="keyword">if</span> (deleted_node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;direction == AL_START_HEAD) &#123;</span><br><span class="line">            iter-&gt;current = next;</span><br><span class="line">            iter-&gt;offset = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iter-&gt;direction == AL_START_TAIL) &#123;</span><br><span class="line">            iter-&gt;current = prev;</span><br><span class="line">            iter-&gt;offset = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* else if (!deleted_node), no changes needed.</span></span><br><span class="line"><span class="comment">     * we already reset iter-&gt;zi above, and the existing iter-&gt;offset</span></span><br><span class="line"><span class="comment">     * doesn&#x27;t move again because:</span></span><br><span class="line"><span class="comment">     *   - [1, 2, 3] =&gt; delete offset 1 =&gt; [1, 3]: next element still offset 1</span></span><br><span class="line"><span class="comment">     *   - [1, 2, 3] =&gt; delete offset 0 =&gt; [2, 3]: next element still offset 0</span></span><br><span class="line"><span class="comment">     *  if we deleted the last element at offet N and now</span></span><br><span class="line"><span class="comment">     *  length of this ziplist is N-1, the next call into</span></span><br><span class="line"><span class="comment">     *  quicklistNext() will jump to the next node. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="REDIS-STATIC-void-quicklistInsert-quicklist-quicklist-quicklistEntry-entry-void-value-const-size-t-sz-int-after"><a href="#REDIS-STATIC-void-quicklistInsert-quicklist-quicklist-quicklistEntry-entry-void-value-const-size-t-sz-int-after" class="headerlink" title="REDIS_STATIC void _quicklistInsert(quicklist *quicklist, quicklistEntry *entry, void *value, const size_t sz, int after);"></a><code>REDIS_STATIC void _quicklistInsert(quicklist *quicklist, quicklistEntry *entry, void *value, const size_t sz, int after);</code></h3><h4 id="功能-10"><a href="#功能-10" class="headerlink" title="功能"></a>功能</h4><p>插入一个新数据</p>
<h4 id="源码-10"><a href="#源码-10" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Insert a new entry before or after existing entry &#x27;entry&#x27;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If after==1, the new value is inserted after &#x27;entry&#x27;, otherwise</span></span><br><span class="line"><span class="comment"> * the new value is inserted before &#x27;entry&#x27;. */</span></span><br><span class="line">REDIS_STATIC <span class="keyword">void</span> _quicklistInsert(quicklist *quicklist, quicklistEntry *entry,</span><br><span class="line">                                   <span class="keyword">void</span> *value, <span class="keyword">const</span> <span class="keyword">size_t</span> sz, <span class="keyword">int</span> after) &#123;</span><br><span class="line">    <span class="keyword">int</span> full = <span class="number">0</span>, at_tail = <span class="number">0</span>, at_head = <span class="number">0</span>, full_next = <span class="number">0</span>, full_prev = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> fill = quicklist-&gt;fill;</span><br><span class="line">    quicklistNode *node = entry-&gt;node;</span><br><span class="line">    quicklistNode *new_node = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">        <span class="comment">/* we have no reference node, so let&#x27;s create only node in the list */</span></span><br><span class="line">        D(<span class="string">&quot;No node given!&quot;</span>);</span><br><span class="line">        new_node = quicklistCreateNode();</span><br><span class="line">        new_node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);</span><br><span class="line">        __quicklistInsertNode(quicklist, <span class="literal">NULL</span>, new_node, after);</span><br><span class="line">        new_node-&gt;count++;</span><br><span class="line">        quicklist-&gt;count++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Populate accounting flags for easier boolean checks later */</span></span><br><span class="line">    <span class="keyword">if</span> (!_quicklistNodeAllowInsert(node, fill, sz)) &#123;</span><br><span class="line">        D(<span class="string">&quot;Current node is full with count %d with requested fill %lu&quot;</span>,</span><br><span class="line">          node-&gt;count, fill);</span><br><span class="line">        full = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (after &amp;&amp; (entry-&gt;offset == node-&gt;count)) &#123;</span><br><span class="line">        D(<span class="string">&quot;At Tail of current ziplist&quot;</span>);</span><br><span class="line">        at_tail = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!_quicklistNodeAllowInsert(node-&gt;next, fill, sz)) &#123;</span><br><span class="line">            D(<span class="string">&quot;Next node is full too.&quot;</span>);</span><br><span class="line">            full_next = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!after &amp;&amp; (entry-&gt;offset == <span class="number">0</span>)) &#123;</span><br><span class="line">        D(<span class="string">&quot;At Head&quot;</span>);</span><br><span class="line">        at_head = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!_quicklistNodeAllowInsert(node-&gt;prev, fill, sz)) &#123;</span><br><span class="line">            D(<span class="string">&quot;Prev node is full too.&quot;</span>);</span><br><span class="line">            full_prev = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now determine where and how to insert the new element */</span></span><br><span class="line">    <span class="keyword">if</span> (!full &amp;&amp; after) &#123;</span><br><span class="line">        D(<span class="string">&quot;Not full, inserting after current position.&quot;</span>);</span><br><span class="line">        quicklistDecompressNodeForUse(node);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *next = ziplistNext(node-&gt;zl, entry-&gt;zi);</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            node-&gt;zl = ziplistPush(node-&gt;zl, value, sz, ZIPLIST_TAIL);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node-&gt;zl = ziplistInsert(node-&gt;zl, next, value, sz);</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;count++;</span><br><span class="line">        quicklistNodeUpdateSz(node);</span><br><span class="line">        quicklistRecompressOnly(quicklist, node);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!full &amp;&amp; !after) &#123;</span><br><span class="line">        D(<span class="string">&quot;Not full, inserting before current position.&quot;</span>);</span><br><span class="line">        quicklistDecompressNodeForUse(node);</span><br><span class="line">        node-&gt;zl = ziplistInsert(node-&gt;zl, entry-&gt;zi, value, sz);</span><br><span class="line">        node-&gt;count++;</span><br><span class="line">        quicklistNodeUpdateSz(node);</span><br><span class="line">        quicklistRecompressOnly(quicklist, node);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (full &amp;&amp; at_tail &amp;&amp; node-&gt;next &amp;&amp; !full_next &amp;&amp; after) &#123;</span><br><span class="line">        <span class="comment">/* If we are: at tail, next has free space, and inserting after:</span></span><br><span class="line"><span class="comment">         *   - insert entry at head of next node. */</span></span><br><span class="line">        D(<span class="string">&quot;Full and tail, but next isn&#x27;t full; inserting next node head&quot;</span>);</span><br><span class="line">        new_node = node-&gt;next;</span><br><span class="line">        quicklistDecompressNodeForUse(new_node);</span><br><span class="line">        new_node-&gt;zl = ziplistPush(new_node-&gt;zl, value, sz, ZIPLIST_HEAD);</span><br><span class="line">        new_node-&gt;count++;</span><br><span class="line">        quicklistNodeUpdateSz(new_node);</span><br><span class="line">        quicklistRecompressOnly(quicklist, new_node);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (full &amp;&amp; at_head &amp;&amp; node-&gt;prev &amp;&amp; !full_prev &amp;&amp; !after) &#123;</span><br><span class="line">        <span class="comment">/* If we are: at head, previous has free space, and inserting before:</span></span><br><span class="line"><span class="comment">         *   - insert entry at tail of previous node. */</span></span><br><span class="line">        D(<span class="string">&quot;Full and head, but prev isn&#x27;t full, inserting prev node tail&quot;</span>);</span><br><span class="line">        new_node = node-&gt;prev;</span><br><span class="line">        quicklistDecompressNodeForUse(new_node);</span><br><span class="line">        new_node-&gt;zl = ziplistPush(new_node-&gt;zl, value, sz, ZIPLIST_TAIL);</span><br><span class="line">        new_node-&gt;count++;</span><br><span class="line">        quicklistNodeUpdateSz(new_node);</span><br><span class="line">        quicklistRecompressOnly(quicklist, new_node);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (full &amp;&amp; ((at_tail &amp;&amp; node-&gt;next &amp;&amp; full_next &amp;&amp; after) ||</span><br><span class="line">                        (at_head &amp;&amp; node-&gt;prev &amp;&amp; full_prev &amp;&amp; !after))) &#123;</span><br><span class="line">        <span class="comment">/* If we are: full, and our prev/next is full, then:</span></span><br><span class="line"><span class="comment">         *   - create new node and attach to quicklist */</span></span><br><span class="line">        D(<span class="string">&quot;\tprovisioning new node...&quot;</span>);</span><br><span class="line">        new_node = quicklistCreateNode();</span><br><span class="line">        new_node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);</span><br><span class="line">        new_node-&gt;count++;</span><br><span class="line">        quicklistNodeUpdateSz(new_node);</span><br><span class="line">        __quicklistInsertNode(quicklist, node, new_node, after);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (full) &#123;</span><br><span class="line">        <span class="comment">/* else, node is full we need to split it. */</span></span><br><span class="line">        <span class="comment">/* covers both after and !after cases */</span></span><br><span class="line">        D(<span class="string">&quot;\tsplitting node...&quot;</span>);</span><br><span class="line">        quicklistDecompressNodeForUse(node);</span><br><span class="line">        new_node = _quicklistSplitNode(node, entry-&gt;offset, after);</span><br><span class="line">        new_node-&gt;zl = ziplistPush(new_node-&gt;zl, value, sz,</span><br><span class="line">                                   after ? ZIPLIST_HEAD : ZIPLIST_TAIL);</span><br><span class="line">        new_node-&gt;count++;</span><br><span class="line">        quicklistNodeUpdateSz(new_node);</span><br><span class="line">        __quicklistInsertNode(quicklist, node, new_node, after);</span><br><span class="line">        _quicklistMergeNodes(quicklist, node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    quicklist-&gt;count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="quicklistIter-quicklistGetIterator-const-quicklist-quicklist-int-direction"><a href="#quicklistIter-quicklistGetIterator-const-quicklist-quicklist-int-direction" class="headerlink" title="quicklistIter *quicklistGetIterator(const quicklist *quicklist, int direction);"></a><code>quicklistIter *quicklistGetIterator(const quicklist *quicklist, int direction);</code></h3><h4 id="功能-11"><a href="#功能-11" class="headerlink" title="功能"></a>功能</h4><p>获取迭代器</p>
<h4 id="源码-11"><a href="#源码-11" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Returns a quicklist iterator &#x27;iter&#x27;. After the initialization every</span></span><br><span class="line"><span class="comment"> * call to quicklistNext() will return the next element of the quicklist. */</span></span><br><span class="line"><span class="function">quicklistIter *<span class="title">quicklistGetIterator</span><span class="params">(<span class="keyword">const</span> quicklist *quicklist, <span class="keyword">int</span> direction)</span> </span>&#123;</span><br><span class="line">    quicklistIter *iter;</span><br><span class="line"></span><br><span class="line">    iter = zmalloc(<span class="keyword">sizeof</span>(*iter));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (direction == AL_START_HEAD) &#123;</span><br><span class="line">        iter-&gt;current = quicklist-&gt;head;</span><br><span class="line">        iter-&gt;offset = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction == AL_START_TAIL) &#123;</span><br><span class="line">        iter-&gt;current = quicklist-&gt;tail;</span><br><span class="line">        iter-&gt;offset = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    iter-&gt;direction = direction;</span><br><span class="line">    iter-&gt;quicklist = quicklist;</span><br><span class="line"></span><br><span class="line">    iter-&gt;zi = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="quicklistIter-quicklistGetIteratorAtIdx-const-quicklist-quicklist-const-int-direction-const-long-long-idx"><a href="#quicklistIter-quicklistGetIteratorAtIdx-const-quicklist-quicklist-const-int-direction-const-long-long-idx" class="headerlink" title="quicklistIter *quicklistGetIteratorAtIdx(const quicklist *quicklist, const int direction, const long long idx);"></a><code>quicklistIter *quicklistGetIteratorAtIdx(const quicklist *quicklist, const int direction, const long long idx);</code></h3><h4 id="功能-12"><a href="#功能-12" class="headerlink" title="功能"></a>功能</h4><p>获取指定位置的迭代器</p>
<h4 id="源码-12"><a href="#源码-12" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Initialize an iterator at a specific offset &#x27;idx&#x27; and make the iterator</span></span><br><span class="line"><span class="comment"> * return nodes in &#x27;direction&#x27; direction. */</span></span><br><span class="line"><span class="function">quicklistIter *<span class="title">quicklistGetIteratorAtIdx</span><span class="params">(<span class="keyword">const</span> quicklist *quicklist,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         <span class="keyword">const</span> <span class="keyword">int</span> direction,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         <span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> idx)</span> </span>&#123;</span><br><span class="line">    quicklistEntry entry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (quicklistIndex(quicklist, idx, &amp;entry)) &#123;</span><br><span class="line">        quicklistIter *base = quicklistGetIterator(quicklist, direction);</span><br><span class="line">        base-&gt;zi = <span class="literal">NULL</span>;</span><br><span class="line">        base-&gt;current = entry.node;</span><br><span class="line">        base-&gt;offset = entry.offset;</span><br><span class="line">        <span class="keyword">return</span> base;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int-quicklistNext-quicklistIter-iter-quicklistEntry-entry"><a href="#int-quicklistNext-quicklistIter-iter-quicklistEntry-entry" class="headerlink" title="int quicklistNext(quicklistIter *iter, quicklistEntry *entry);"></a><code>int quicklistNext(quicklistIter *iter, quicklistEntry *entry);</code></h3><h4 id="功能-13"><a href="#功能-13" class="headerlink" title="功能"></a>功能</h4><p>迭代元素</p>
<h4 id="源码-13"><a href="#源码-13" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Get next element in iterator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: You must NOT insert into the list while iterating over it.</span></span><br><span class="line"><span class="comment"> * You *may* delete from the list while iterating using the</span></span><br><span class="line"><span class="comment"> * quicklistDelEntry() function.</span></span><br><span class="line"><span class="comment"> * If you insert into the quicklist while iterating, you should</span></span><br><span class="line"><span class="comment"> * re-create the iterator after your addition.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * iter = quicklistGetIterator(quicklist,&lt;direction&gt;);</span></span><br><span class="line"><span class="comment"> * quicklistEntry entry;</span></span><br><span class="line"><span class="comment"> * while (quicklistNext(iter, &amp;entry)) &#123;</span></span><br><span class="line"><span class="comment"> *     if (entry.value)</span></span><br><span class="line"><span class="comment"> *          [[ use entry.value with entry.sz ]]</span></span><br><span class="line"><span class="comment"> *     else</span></span><br><span class="line"><span class="comment"> *          [[ use entry.longval ]]</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Populates &#x27;entry&#x27; with values for this iteration.</span></span><br><span class="line"><span class="comment"> * Returns 0 when iteration is complete or if iteration not possible.</span></span><br><span class="line"><span class="comment"> * If return value is 0, the contents of &#x27;entry&#x27; are not valid.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistNext</span><span class="params">(quicklistIter *iter, quicklistEntry *entry)</span> </span>&#123;</span><br><span class="line">    initEntry(entry);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!iter) &#123;</span><br><span class="line">        D(<span class="string">&quot;Returning because no iter!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    entry-&gt;quicklist = iter-&gt;quicklist;</span><br><span class="line">    entry-&gt;node = iter-&gt;current;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!iter-&gt;current) &#123;</span><br><span class="line">        D(<span class="string">&quot;Returning because current node is NULL&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *(*nextFn)(<span class="keyword">unsigned</span> <span class="keyword">char</span> *, <span class="keyword">unsigned</span> <span class="keyword">char</span> *) = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> offset_update = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!iter-&gt;zi) &#123;</span><br><span class="line">        <span class="comment">/* If !zi, use current index. */</span></span><br><span class="line">        quicklistDecompressNodeForUse(iter-&gt;current);</span><br><span class="line">        iter-&gt;zi = ziplistIndex(iter-&gt;current-&gt;zl, iter-&gt;offset);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* else, use existing iterator offset and get prev/next as necessary. */</span></span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;direction == AL_START_HEAD) &#123;</span><br><span class="line">            nextFn = ziplistNext;</span><br><span class="line">            offset_update = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iter-&gt;direction == AL_START_TAIL) &#123;</span><br><span class="line">            nextFn = ziplistPrev;</span><br><span class="line">            offset_update = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        iter-&gt;zi = nextFn(iter-&gt;current-&gt;zl, iter-&gt;zi);</span><br><span class="line">        iter-&gt;offset += offset_update;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    entry-&gt;zi = iter-&gt;zi;</span><br><span class="line">    entry-&gt;offset = iter-&gt;offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iter-&gt;zi) &#123;</span><br><span class="line">        <span class="comment">/* Populate value from existing ziplist position */</span></span><br><span class="line">        ziplistGet(entry-&gt;zi, &amp;entry-&gt;value, &amp;entry-&gt;sz, &amp;entry-&gt;longval);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* We ran out of ziplist entries.</span></span><br><span class="line"><span class="comment">         * Pick next node, update offset, then re-run retrieval. */</span></span><br><span class="line">        quicklistCompress(iter-&gt;quicklist, iter-&gt;current);</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;direction == AL_START_HEAD) &#123;</span><br><span class="line">            <span class="comment">/* Forward traversal */</span></span><br><span class="line">            D(<span class="string">&quot;Jumping to start of next node&quot;</span>);</span><br><span class="line">            iter-&gt;current = iter-&gt;current-&gt;next;</span><br><span class="line">            iter-&gt;offset = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iter-&gt;direction == AL_START_TAIL) &#123;</span><br><span class="line">            <span class="comment">/* Reverse traversal */</span></span><br><span class="line">            D(<span class="string">&quot;Jumping to end of previous node&quot;</span>);</span><br><span class="line">            iter-&gt;current = iter-&gt;current-&gt;prev;</span><br><span class="line">            iter-&gt;offset = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        iter-&gt;zi = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> quicklistNext(iter, entry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="quicklist-quicklistDup-quicklist-orig"><a href="#quicklist-quicklistDup-quicklist-orig" class="headerlink" title="quicklist *quicklistDup(quicklist *orig);"></a><code>quicklist *quicklistDup(quicklist *orig);</code></h3><h4 id="功能-14"><a href="#功能-14" class="headerlink" title="功能"></a>功能</h4><p>复制</p>
<h4 id="源码-14"><a href="#源码-14" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Duplicate the quicklist.</span></span><br><span class="line"><span class="comment"> * On success a copy of the original quicklist is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The original quicklist both on success or error is never modified.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns newly allocated quicklist. */</span></span><br><span class="line"><span class="function">quicklist *<span class="title">quicklistDup</span><span class="params">(quicklist *orig)</span> </span>&#123;</span><br><span class="line">    quicklist *copy;</span><br><span class="line"></span><br><span class="line">    copy = quicklistNew(orig-&gt;fill, orig-&gt;compress);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (quicklistNode *current = orig-&gt;head; current;</span><br><span class="line">         current = current-&gt;next) &#123;</span><br><span class="line">        quicklistNode *node = quicklistCreateNode();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;encoding == QUICKLIST_NODE_ENCODING_LZF) &#123;</span><br><span class="line">            quicklistLZF *lzf = (quicklistLZF *)node-&gt;zl;</span><br><span class="line">            <span class="keyword">size_t</span> lzf_sz = <span class="keyword">sizeof</span>(*lzf) + lzf-&gt;sz;</span><br><span class="line">            node-&gt;zl = zmalloc(lzf_sz);</span><br><span class="line">            <span class="built_in">memcpy</span>(node-&gt;zl, current-&gt;zl, lzf_sz);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;encoding == QUICKLIST_NODE_ENCODING_RAW) &#123;</span><br><span class="line">            node-&gt;zl = zmalloc(current-&gt;sz);</span><br><span class="line">            <span class="built_in">memcpy</span>(node-&gt;zl, current-&gt;zl, current-&gt;sz);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node-&gt;count = current-&gt;count;</span><br><span class="line">        copy-&gt;count += node-&gt;count;</span><br><span class="line">        node-&gt;sz = current-&gt;sz;</span><br><span class="line">        node-&gt;encoding = current-&gt;encoding;</span><br><span class="line"></span><br><span class="line">        _quicklistInsertNodeAfter(copy, copy-&gt;tail, node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* copy-&gt;count must equal orig-&gt;count here */</span></span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int-quicklistPopCustom-quicklist-quicklist-int-where-unsigned-char-data-unsigned-int-sz-long-long-sval-void-saver-unsigned-char-data-unsigned-int-sz"><a href="#int-quicklistPopCustom-quicklist-quicklist-int-where-unsigned-char-data-unsigned-int-sz-long-long-sval-void-saver-unsigned-char-data-unsigned-int-sz" class="headerlink" title="int quicklistPopCustom(quicklist *quicklist, int where, unsigned char **data, unsigned int *sz, long long *sval, void *(*saver)(unsigned char *data, unsigned int sz));"></a><code>int quicklistPopCustom(quicklist *quicklist, int where, unsigned char **data, unsigned int *sz, long long *sval, void *(*saver)(unsigned char *data, unsigned int sz));</code></h3><h4 id="功能-15"><a href="#功能-15" class="headerlink" title="功能"></a>功能</h4><p>取出一个元素并从quicklist中去除</p>
<h4 id="源码-15"><a href="#源码-15" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* pop from quicklist and return result in &#x27;data&#x27; ptr.  Value of &#x27;data&#x27;</span></span><br><span class="line"><span class="comment"> * is the return value of &#x27;saver&#x27; function pointer if the data is NOT a number.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the quicklist element is a long long, then the return value is returned in</span></span><br><span class="line"><span class="comment"> * &#x27;sval&#x27;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return value of 0 means no elements available.</span></span><br><span class="line"><span class="comment"> * Return value of 1 means check &#x27;data&#x27; and &#x27;sval&#x27; for values.</span></span><br><span class="line"><span class="comment"> * If &#x27;data&#x27; is set, use &#x27;data&#x27; and &#x27;sz&#x27;.  Otherwise, use &#x27;sval&#x27;. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPopCustom</span><span class="params">(quicklist *quicklist, <span class="keyword">int</span> where, <span class="keyword">unsigned</span> <span class="keyword">char</span> **data,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">unsigned</span> <span class="keyword">int</span> *sz, <span class="keyword">long</span> <span class="keyword">long</span> *sval,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> *(*saver)(<span class="keyword">unsigned</span> <span class="keyword">char</span> *data, <span class="keyword">unsigned</span> <span class="keyword">int</span> sz))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> vlong;</span><br><span class="line">    <span class="keyword">int</span> pos = (where == QUICKLIST_HEAD) ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (quicklist-&gt;count == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">        *data = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (sz)</span><br><span class="line">        *sz = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sval)</span><br><span class="line">        *sval = <span class="number">-123456789</span>;</span><br><span class="line"></span><br><span class="line">    quicklistNode *node;</span><br><span class="line">    <span class="keyword">if</span> (where == QUICKLIST_HEAD &amp;&amp; quicklist-&gt;head) &#123;</span><br><span class="line">        node = quicklist-&gt;head;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (where == QUICKLIST_TAIL &amp;&amp; quicklist-&gt;tail) &#123;</span><br><span class="line">        node = quicklist-&gt;tail;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = ziplistIndex(node-&gt;zl, pos);</span><br><span class="line">    <span class="keyword">if</span> (ziplistGet(p, &amp;vstr, &amp;vlen, &amp;vlong)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vstr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data)</span><br><span class="line">                *data = saver(vstr, vlen);</span><br><span class="line">            <span class="keyword">if</span> (sz)</span><br><span class="line">                *sz = vlen;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (data)</span><br><span class="line">                *data = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> (sval)</span><br><span class="line">                *sval = vlong;</span><br><span class="line">        &#125;</span><br><span class="line">        quicklistDelIndex(quicklist, node, &amp;p);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int-quicklistPop-quicklist-quicklist-int-where-unsigned-char-data-unsigned-int-sz-long-long-slong"><a href="#int-quicklistPop-quicklist-quicklist-int-where-unsigned-char-data-unsigned-int-sz-long-long-slong" class="headerlink" title="int quicklistPop(quicklist *quicklist, int where, unsigned char **data, unsigned int *sz, long long *slong);"></a><code>int quicklistPop(quicklist *quicklist, int where, unsigned char **data, unsigned int *sz, long long *slong);</code></h3><h4 id="功能-16"><a href="#功能-16" class="headerlink" title="功能"></a>功能</h4><p>pop功能</p>
<h4 id="源码-16"><a href="#源码-16" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Default pop function</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns malloc&#x27;d value from quicklist */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistPop</span><span class="params">(quicklist *quicklist, <span class="keyword">int</span> where, <span class="keyword">unsigned</span> <span class="keyword">char</span> **data,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">unsigned</span> <span class="keyword">int</span> *sz, <span class="keyword">long</span> <span class="keyword">long</span> *slong)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> vlong;</span><br><span class="line">    <span class="keyword">if</span> (quicklist-&gt;count == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = quicklistPopCustom(quicklist, where, &amp;vstr, &amp;vlen, &amp;vlong,</span><br><span class="line">                                 _quicklistSaver);</span><br><span class="line">    <span class="keyword">if</span> (data)</span><br><span class="line">        *data = vstr;</span><br><span class="line">    <span class="keyword">if</span> (slong)</span><br><span class="line">        *slong = vlong;</span><br><span class="line">    <span class="keyword">if</span> (sz)</span><br><span class="line">        *sz = vlen;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>redis</category>
        <category>source</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 源码分析-skiplist</title>
    <url>/2018/05/07/redis-source-skiplist/</url>
    <content><![CDATA[<p>跳表<br>就是分层级的有序链表<br>查询数据快,结构简单<br>跳表所有层级的第一个元素都是header的头元素(空数据)<br>结尾是实际插入的元素<br>跳表的第一个实际插入的元素是回退不到header的<br>代码中<br>forward的处理是遍历循环处理<br>backward的处理是一个if判断<br>是因为forward是层级相关的,所有层级都要处理<br>而backward只是一个值,backward本身只记录0级的数据</p>
<h2 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h2><ul>
<li>server.h</li>
<li>t_zset.c<a id="more"></a>

</li>
</ul>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul>
<li>strtod<br>  原型<code>double strtod(const char *nptr,char **endptr);</code><br>  将字符串转化为double</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ZSETs use a specialized version of Skiplists */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span> <span class="comment">// 跳表节点</span></span><br><span class="line">    robj *obj; <span class="comment">// 数据(redis对象)</span></span><br><span class="line">    <span class="keyword">double</span> score; <span class="comment">// 积分(排序用)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span> <span class="comment">// 前一个节点(后退)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span> <span class="comment">// 层级结构</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span> <span class="comment">// 下一个节点(前进)</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span; <span class="comment">// 跨度(和当前节点间隔了多少元素(包含下一个节点))</span></span><br><span class="line">    &#125; level[]; <span class="comment">// 不同层级的信息</span></span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span> <span class="comment">// 跳表结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span> <span class="comment">// 头(),尾节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length; <span class="comment">// 总元素个数</span></span><br><span class="line">    <span class="keyword">int</span> level; <span class="comment">// 总层级(最大等级+1)</span></span><br><span class="line">&#125; zskiplist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span> <span class="comment">// 有序set结构</span></span><br><span class="line">    dict *dict; <span class="comment">// &lt;值, 分数&gt;</span></span><br><span class="line">    zskiplist *zsl; <span class="comment">// 跳表</span></span><br><span class="line">&#125; zset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Struct to hold a inclusive/exclusive range spec by score comparison. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">// 查找用表示范围的数据结构</span></span><br><span class="line">    <span class="keyword">double</span> min, max; <span class="comment">// 最大最小值</span></span><br><span class="line">    <span class="keyword">int</span> minex, maxex; <span class="comment">/* are min or max exclusive? */</span> <span class="comment">// 标记是否是开区间</span></span><br><span class="line">&#125; zrangespec;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Struct to hold an inclusive/exclusive range spec by lexicographic comparison. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    robj *min, *max;  <span class="comment">/* May be set to shared.(minstring|maxstring) */</span> <span class="comment">// 最大最小值</span></span><br><span class="line">    <span class="keyword">int</span> minex, maxex; <span class="comment">/* are min or max exclusive? */</span> <span class="comment">// 标记是否是开区间</span></span><br><span class="line">&#125; zlexrangespec;</span><br></pre></td></tr></table></figure>

<h2 id="主要宏"><a href="#主要宏" class="headerlink" title="主要宏"></a>主要宏</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_MAXLEVEL 32 <span class="comment">/* Should be enough for 2^32 elements */</span> <span class="comment">// 最大层数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_P 0.25      <span class="comment">/* Skiplist P = 1/4 */</span> <span class="comment">// 元素增加层数的概率</span></span></span><br></pre></td></tr></table></figure>

<h2 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h2><h3 id="zskiplistNode-zslCreateNode-int-level-double-score-robj-obj"><a href="#zskiplistNode-zslCreateNode-int-level-double-score-robj-obj" class="headerlink" title="zskiplistNode *zslCreateNode(int level, double score, robj *obj);"></a><code>zskiplistNode *zslCreateNode(int level, double score, robj *obj);</code></h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>创建一个跳表节点<br>一个节点,一旦创建出来就已经决定了它自身的层级<br>所以它的数组内存是固定的<br>不需要在后面扩展层级数据信息</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">zskiplistNode *<span class="title">zslCreateNode</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">double</span> score, robj *obj)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *zn = zmalloc(<span class="keyword">sizeof</span>(*zn)+level*<span class="keyword">sizeof</span>(struct zskiplistLevel)); <span class="comment">// 内存申请</span></span><br><span class="line">    zn-&gt;score = score; <span class="comment">// 记录积分</span></span><br><span class="line">    zn-&gt;obj = obj; <span class="comment">// 记录数据</span></span><br><span class="line">    <span class="keyword">return</span> zn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="zskiplist-zslCreate-void"><a href="#zskiplist-zslCreate-void" class="headerlink" title="zskiplist *zslCreate(void);"></a><code>zskiplist *zslCreate(void);</code></h3><h4 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h4><p>创建跳表</p>
<h4 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">zskiplist *<span class="title">zslCreate</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line"></span><br><span class="line">    zsl = zmalloc(<span class="keyword">sizeof</span>(*zsl)); <span class="comment">// 申请内存</span></span><br><span class="line">    zsl-&gt;level = <span class="number">1</span>; <span class="comment">// 初始等级为1</span></span><br><span class="line">    zsl-&gt;length = <span class="number">0</span>; <span class="comment">// 没有元素</span></span><br><span class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,<span class="number">0</span>,<span class="literal">NULL</span>); <span class="comment">// 创建一个头,包含所有层级,数据为空,0分</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123; <span class="comment">// 初始化头数据</span></span><br><span class="line">        zsl-&gt;header-&gt;level[j].forward = <span class="literal">NULL</span>; <span class="comment">// 没有下一个元素</span></span><br><span class="line">        zsl-&gt;header-&gt;level[j].span = <span class="number">0</span>; <span class="comment">// 间隔元素数量为0</span></span><br><span class="line">    &#125;</span><br><span class="line">    zsl-&gt;header-&gt;backward = <span class="literal">NULL</span>; <span class="comment">// 没有前一个元素</span></span><br><span class="line">    zsl-&gt;tail = <span class="literal">NULL</span>; <span class="comment">// 结尾为空</span></span><br><span class="line">    <span class="keyword">return</span> zsl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void-zslFreeNode-zskiplistNode-node"><a href="#void-zslFreeNode-zskiplistNode-node" class="headerlink" title="void zslFreeNode(zskiplistNode *node);"></a><code>void zslFreeNode(zskiplistNode *node);</code></h3><h4 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h4><p>释放节点内存</p>
<h4 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslFreeNode</span><span class="params">(zskiplistNode *node)</span> </span>&#123;</span><br><span class="line">    decrRefCount(node-&gt;obj); <span class="comment">// 减少obj的引用次数,当次数为1时释放内存</span></span><br><span class="line">    zfree(node); <span class="comment">// 释放节点本身申请的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void-zslFree-zskiplist-zsl"><a href="#void-zslFree-zskiplist-zsl" class="headerlink" title="void zslFree(zskiplist *zsl);"></a><code>void zslFree(zskiplist *zsl);</code></h3><h4 id="功能-3"><a href="#功能-3" class="headerlink" title="功能"></a>功能</h4><p>释放跳表内存</p>
<h4 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslFree</span><span class="params">(zskiplist *zsl)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *node = zsl-&gt;header-&gt;level[<span class="number">0</span>].forward, *next; <span class="comment">// 获取到除头外的第一个元素</span></span><br><span class="line"></span><br><span class="line">    zfree(zsl-&gt;header); <span class="comment">// 释放头元素</span></span><br><span class="line">    <span class="keyword">while</span>(node) &#123; <span class="comment">// 遍历</span></span><br><span class="line">        next = node-&gt;level[<span class="number">0</span>].forward; <span class="comment">// 记录下一个元素</span></span><br><span class="line">        zslFreeNode(node); <span class="comment">// 释放节点元素</span></span><br><span class="line">        node = next; <span class="comment">// 递增</span></span><br><span class="line">    &#125;</span><br><span class="line">    zfree(zsl); <span class="comment">// 释放跳表本身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int-zslRandomLevel-void"><a href="#int-zslRandomLevel-void" class="headerlink" title="int zslRandomLevel(void);"></a><code>int zslRandomLevel(void);</code></h3><h4 id="功能-4"><a href="#功能-4" class="headerlink" title="功能"></a>功能</h4><p>返回一个随机的跳表层级算法</p>
<h4 id="源码-4"><a href="#源码-4" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Returns a random level for the new skiplist node we are going to create.</span></span><br><span class="line"><span class="comment"> * The return value of this function is between 1 and ZSKIPLIST_MAXLEVEL</span></span><br><span class="line"><span class="comment"> * (both inclusive), with a powerlaw-alike distribution where higher</span></span><br><span class="line"><span class="comment"> * levels are less likely to be returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslRandomLevel</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>))</span><br><span class="line">        level += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="zskiplistNode-zslInsert-zskiplist-zsl-double-score-robj-obj"><a href="#zskiplistNode-zslInsert-zskiplist-zsl-double-score-robj-obj" class="headerlink" title="zskiplistNode *zslInsert(zskiplist *zsl, double score, robj *obj);"></a><code>zskiplistNode *zslInsert(zskiplist *zsl, double score, robj *obj);</code></h3><h4 id="功能-5"><a href="#功能-5" class="headerlink" title="功能"></a>功能</h4><p>跳表插入数据<br>这里的跳表没有检测重复数据信息<br>因为redis的跳表是配合dict使用的<br>判断数据是否重复使用dict来判断</p>
<h4 id="源码-5"><a href="#源码-5" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *obj)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x; <span class="comment">// update:记录所有需要变动的元素(新插入的元素在update的元素之后)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rank[ZSKIPLIST_MAXLEVEL]; <span class="comment">// 不同层级,从起始到新插入元素的位置统计,包含的元素的个数</span></span><br><span class="line">    <span class="keyword">int</span> i, level;</span><br><span class="line"></span><br><span class="line">    serverAssert(!isnan(score)); <span class="comment">// 保证score必然有值</span></span><br><span class="line">    x = zsl-&gt;header; <span class="comment">// 记录起始位置</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 倒叙遍历(所有跳表查询数据都是使用倒序)</span></span><br><span class="line">        <span class="comment">/* store rank that is crossed to reach the insert position */</span></span><br><span class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>]; <span class="comment">// 最上层的头数据肯定没有rank值,下面层级的rank值的起始就是上一个层级的值</span></span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; <span class="number">0</span>))) &#123; <span class="comment">// 当前遍历元素比待插入元素小则继续遍历</span></span><br><span class="line">            rank[i] += x-&gt;level[i].span; <span class="comment">// 增加rank</span></span><br><span class="line">            x = x-&gt;level[i].forward; <span class="comment">// 获取下一个元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x; <span class="comment">// 记录最符合条件的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* we assume the key is not already inside, since we allow duplicated</span></span><br><span class="line"><span class="comment">     * scores, and the re-insertion of score and redis object should never</span></span><br><span class="line"><span class="comment">     * happen since the caller of zslInsert() should test in the hash table</span></span><br><span class="line"><span class="comment">     * if the element is already inside or not. */</span></span><br><span class="line">    level = zslRandomLevel(); <span class="comment">// 生成新插入数据的层级</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123; <span class="comment">// 比当前层级高的话</span></span><br><span class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123; <span class="comment">// 初始化所有新层级</span></span><br><span class="line">            rank[i] = <span class="number">0</span>; <span class="comment">// 没有rank值</span></span><br><span class="line">            update[i] = zsl-&gt;header; <span class="comment">// 因为没有其他数据,所以变更的一定都是hader</span></span><br><span class="line">            update[i]-&gt;level[i].span = zsl-&gt;length; <span class="comment">// 初始间隔就是跳表的所有长度</span></span><br><span class="line">        &#125;</span><br><span class="line">        zsl-&gt;level = level; <span class="comment">// 记录当前跳表的等级</span></span><br><span class="line">    &#125;</span><br><span class="line">    x = zslCreateNode(level,score,obj); <span class="comment">// 创建一个新的node</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123; <span class="comment">// 更新所有需要更新的节点</span></span><br><span class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward; <span class="comment">// 新节点插入跳表</span></span><br><span class="line">        update[i]-&gt;level[i].forward = x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* update span covered by update[i] as x is inserted here */</span></span><br><span class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]); <span class="comment">// 记录新节点的span间隔值</span></span><br><span class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>; <span class="comment">// 修改update元节点的间隔值(多了一个新增节点,所以+1)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* increment span for untouched levels */</span></span><br><span class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123; <span class="comment">// 当随机的level&lt;原链表大小时,需要把上层的间隔值做下递增调整,否则会漏数据</span></span><br><span class="line">        update[i]-&gt;level[i].span++; <span class="comment">// 递增</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>]; <span class="comment">// 是否可以回退,元素回退不到头数据</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward) <span class="comment">// 不是结尾</span></span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x; <span class="comment">// 后面的元素记录前面的元素指针</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        zsl-&gt;tail = x; <span class="comment">// 标记结尾</span></span><br><span class="line">    zsl-&gt;length++; <span class="comment">// 递增长度</span></span><br><span class="line">    <span class="keyword">return</span> x; <span class="comment">// 返回新增节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void-zslDeleteNode-zskiplist-zsl-zskiplistNode-x-zskiplistNode-update"><a href="#void-zslDeleteNode-zskiplist-zsl-zskiplistNode-x-zskiplistNode-update" class="headerlink" title="void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update);"></a><code>void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update);</code></h3><h4 id="功能-6"><a href="#功能-6" class="headerlink" title="功能"></a>功能</h4><p>删除节点<br>不是放内存<br>只是整理跳表的元素结构关系<br>update为所有相关的需要处理的节点列表</p>
<h4 id="源码-6"><a href="#源码-6" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Internal function used by zslDelete, zslDeleteByScore and zslDeleteByRank */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zslDeleteNode</span><span class="params">(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; zsl-&gt;level; i++) &#123; <span class="comment">// 遍历跳表</span></span><br><span class="line">        <span class="keyword">if</span> (update[i]-&gt;level[i].forward == x) &#123; <span class="comment">// 下一个是要删除的节点(直接关联)</span></span><br><span class="line">            update[i]-&gt;level[i].span += x-&gt;level[i].span - <span class="number">1</span>; <span class="comment">// 扩展span间隔值</span></span><br><span class="line">            update[i]-&gt;level[i].forward = x-&gt;level[i].forward; <span class="comment">// 链表移除节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不直接关联(上层链表)</span></span><br><span class="line">            update[i]-&gt;level[i].span -= <span class="number">1</span>; <span class="comment">// 减少span间隔值即可</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward) &#123; <span class="comment">// 后面有值的话</span></span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x-&gt;backward; <span class="comment">// 修正下一个节点的后退节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zsl-&gt;tail = x-&gt;backward; <span class="comment">// 修改结尾</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(zsl-&gt;level &gt; <span class="number">1</span> &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level<span class="number">-1</span>].forward == <span class="literal">NULL</span>) <span class="comment">// 当上层链表为空时</span></span><br><span class="line">        zsl-&gt;level--; <span class="comment">// 减少跳表层级</span></span><br><span class="line">    zsl-&gt;length--; <span class="comment">// 修改跳表实际长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int-zslDelete-zskiplist-zsl-double-score-robj-obj"><a href="#int-zslDelete-zskiplist-zsl-double-score-robj-obj" class="headerlink" title="int zslDelete(zskiplist *zsl, double score, robj *obj);"></a><code>int zslDelete(zskiplist *zsl, double score, robj *obj);</code></h3><h4 id="功能-7"><a href="#功能-7" class="headerlink" title="功能"></a>功能</h4><p>根据积分和对象删除跳表节点</p>
<h4 id="源码-7"><a href="#源码-7" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Delete an element with matching score/object from the skiplist. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslDelete</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *obj)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 倒序遍历</span></span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; <span class="number">0</span>)))</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        update[i] = x; <span class="comment">// 查找所有待处理及节点的前置节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We may have multiple elements with the same score, what we need</span></span><br><span class="line"><span class="comment">     * is to find the element with both the right score and object. */</span></span><br><span class="line">    x = x-&gt;level[<span class="number">0</span>].forward; <span class="comment">// 获取到待删除节点本身</span></span><br><span class="line">    <span class="keyword">if</span> (x &amp;&amp; score == x-&gt;score &amp;&amp; equalStringObjects(x-&gt;obj,obj)) &#123; <span class="comment">// 保证是==而不是&gt;</span></span><br><span class="line">        zslDeleteNode(zsl, x, update); <span class="comment">// 删除节点的跳表关系</span></span><br><span class="line">        zslFreeNode(x); <span class="comment">// 释放内存</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 返回成功</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* not found */</span> <span class="comment">// 返回失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="static-int-zslValueGteMin-double-value-zrangespec-spec"><a href="#static-int-zslValueGteMin-double-value-zrangespec-spec" class="headerlink" title="static int zslValueGteMin(double value, zrangespec *spec);"></a><code>static int zslValueGteMin(double value, zrangespec *spec);</code></h3><h4 id="功能-8"><a href="#功能-8" class="headerlink" title="功能"></a>功能</h4><p>判断值是否大于(等于)最小范围</p>
<h4 id="源码-8"><a href="#源码-8" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">zslValueGteMin</span><span class="params">(<span class="keyword">double</span> value, zrangespec *spec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> spec-&gt;minex ? (value &gt; spec-&gt;min) : (value &gt;= spec-&gt;min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int-zslValueLteMax-double-value-zrangespec-spec"><a href="#int-zslValueLteMax-double-value-zrangespec-spec" class="headerlink" title="int zslValueLteMax(double value, zrangespec *spec);"></a><code>int zslValueLteMax(double value, zrangespec *spec);</code></h3><h4 id="功能-9"><a href="#功能-9" class="headerlink" title="功能"></a>功能</h4><p>判断值是否小于(等于)最大范围</p>
<h4 id="源码-9"><a href="#源码-9" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslValueLteMax</span><span class="params">(<span class="keyword">double</span> value, zrangespec *spec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> spec-&gt;maxex ? (value &lt; spec-&gt;max) : (value &lt;= spec-&gt;max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int-zslIsInRange-zskiplist-zsl-zrangespec-range"><a href="#int-zslIsInRange-zskiplist-zsl-zrangespec-range" class="headerlink" title="int zslIsInRange(zskiplist *zsl, zrangespec *range);"></a><code>int zslIsInRange(zskiplist *zsl, zrangespec *range);</code></h3><h4 id="功能-10"><a href="#功能-10" class="headerlink" title="功能"></a>功能</h4><p>判断跳表是否在给定范围内</p>
<h4 id="源码-10"><a href="#源码-10" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Returns if there is a part of the zset is in range. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslIsInRange</span><span class="params">(zskiplist *zsl, zrangespec *range)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Test for ranges that will always be empty. */</span></span><br><span class="line">    <span class="keyword">if</span> (range-&gt;min &gt; range-&gt;max ||</span><br><span class="line">            (range-&gt;min == range-&gt;max &amp;&amp; (range-&gt;minex || range-&gt;maxex))) <span class="comment">// 范围本身就是空,不可能在范围内</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    x = zsl-&gt;tail;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">NULL</span> || !zslValueGteMin(x-&gt;score,range)) <span class="comment">// 两端校验</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    x = zsl-&gt;header-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">NULL</span> || !zslValueLteMax(x-&gt;score,range))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="zskiplistNode-zslFirstInRange-zskiplist-zsl-zrangespec-range"><a href="#zskiplistNode-zslFirstInRange-zskiplist-zsl-zrangespec-range" class="headerlink" title="zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range);"></a><code>zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range);</code></h3><h4 id="功能-11"><a href="#功能-11" class="headerlink" title="功能"></a>功能</h4><p>获取到跳表第一个在范围内的元素</p>
<h4 id="源码-11"><a href="#源码-11" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Find the first node that is contained in the specified range.</span></span><br><span class="line"><span class="comment"> * Returns NULL when no element is contained in the range. */</span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslFirstInRange</span><span class="params">(zskiplist *zsl, zrangespec *range)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If everything is out of range, return early. */</span></span><br><span class="line">    <span class="keyword">if</span> (!zslIsInRange(zsl,range)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 遍历找到第一个大于最小值的元素</span></span><br><span class="line">        <span class="comment">/* Go forward while *OUT* of range. */</span></span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            !zslValueGteMin(x-&gt;level[i].forward-&gt;score,range))</span><br><span class="line">                x = x-&gt;level[i].forward;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This is an inner range, so the next node cannot be NULL. */</span></span><br><span class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">    serverAssert(x != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if score &lt;= max. */</span></span><br><span class="line">    <span class="keyword">if</span> (!zslValueLteMax(x-&gt;score,range)) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 判断是否小于最大值</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="zskiplistNode-zslLastInRange-zskiplist-zsl-zrangespec-range"><a href="#zskiplistNode-zslLastInRange-zskiplist-zsl-zrangespec-range" class="headerlink" title="zskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range);"></a><code>zskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range);</code></h3><h4 id="功能-12"><a href="#功能-12" class="headerlink" title="功能"></a>功能</h4><p>获取最后一个在给定范围内的元素</p>
<h4 id="源码-12"><a href="#源码-12" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Find the last node that is contained in the specified range.</span></span><br><span class="line"><span class="comment"> * Returns NULL when no element is contained in the range. */</span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslLastInRange</span><span class="params">(zskiplist *zsl, zrangespec *range)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If everything is out of range, return early. */</span></span><br><span class="line">    <span class="keyword">if</span> (!zslIsInRange(zsl,range)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 遍历找到最后一个小于最大值的元素</span></span><br><span class="line">        <span class="comment">/* Go forward while *IN* range. */</span></span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            zslValueLteMax(x-&gt;level[i].forward-&gt;score,range))</span><br><span class="line">                x = x-&gt;level[i].forward;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This is an inner range, so this node cannot be NULL. */</span></span><br><span class="line">    serverAssert(x != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if score &gt;= min. */</span></span><br><span class="line">    <span class="keyword">if</span> (!zslValueGteMin(x-&gt;score,range)) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 判断是否大于最小值</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unsigned-long-zslDeleteRangeByScore-zskiplist-zsl-zrangespec-range-dict-dict"><a href="#unsigned-long-zslDeleteRangeByScore-zskiplist-zsl-zrangespec-range-dict-dict" class="headerlink" title="unsigned long zslDeleteRangeByScore(zskiplist *zsl, zrangespec *range, dict *dict);"></a><code>unsigned long zslDeleteRangeByScore(zskiplist *zsl, zrangespec *range, dict *dict);</code></h3><h4 id="功能-13"><a href="#功能-13" class="headerlink" title="功能"></a>功能</h4><p>根据分数范围删除跳表内的元素<br>dict是同时删除dict内的记录</p>
<h4 id="源码-13"><a href="#源码-13" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Delete all the elements with score between min and max from the skiplist.</span></span><br><span class="line"><span class="comment"> * Min and max are inclusive, so a score &gt;= min || score &lt;= max is deleted.</span></span><br><span class="line"><span class="comment"> * Note that this function takes the reference to the hash table view of the</span></span><br><span class="line"><span class="comment"> * sorted set, in order to remove the elements from the hash table too. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">zslDeleteRangeByScore</span><span class="params">(zskiplist *zsl, zrangespec *range, dict *dict)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> removed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp; (range-&gt;minex ?</span><br><span class="line">            x-&gt;level[i].forward-&gt;score &lt;= range-&gt;min :</span><br><span class="line">            x-&gt;level[i].forward-&gt;score &lt; range-&gt;min))</span><br><span class="line">                x = x-&gt;level[i].forward;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Current node is the last with score &lt; or &lt;= min. */</span></span><br><span class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Delete nodes while in range. */</span></span><br><span class="line">    <span class="keyword">while</span> (x &amp;&amp;</span><br><span class="line">           (range-&gt;maxex ? x-&gt;score &lt; range-&gt;max : x-&gt;score &lt;= range-&gt;max))</span><br><span class="line">    &#123;</span><br><span class="line">        zskiplistNode *next = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">        zslDeleteNode(zsl,x,update);</span><br><span class="line">        dictDelete(dict,x-&gt;obj);</span><br><span class="line">        zslFreeNode(x);</span><br><span class="line">        removed++;</span><br><span class="line">        x = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unsigned-long-zslDeleteRangeByLex-zskiplist-zsl-zlexrangespec-range-dict-dict"><a href="#unsigned-long-zslDeleteRangeByLex-zskiplist-zsl-zlexrangespec-range-dict-dict" class="headerlink" title="unsigned long zslDeleteRangeByLex(zskiplist *zsl, zlexrangespec *range, dict *dict);"></a><code>unsigned long zslDeleteRangeByLex(zskiplist *zsl, zlexrangespec *range, dict *dict);</code></h3><h4 id="功能-14"><a href="#功能-14" class="headerlink" title="功能"></a>功能</h4><p>根据范围对象删除跳表元素<br>dict是同时删除dict内的记录</p>
<h4 id="源码-14"><a href="#源码-14" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">zslDeleteRangeByLex</span><span class="params">(zskiplist *zsl, zlexrangespec *range, dict *dict)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> removed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            !zslLexValueGteMin(x-&gt;level[i].forward-&gt;obj,range))</span><br><span class="line">                x = x-&gt;level[i].forward;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Current node is the last with score &lt; or &lt;= min. */</span></span><br><span class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Delete nodes while in range. */</span></span><br><span class="line">    <span class="keyword">while</span> (x &amp;&amp; zslLexValueLteMax(x-&gt;obj,range)) &#123;</span><br><span class="line">        zskiplistNode *next = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">        zslDeleteNode(zsl,x,update);</span><br><span class="line">        dictDelete(dict,x-&gt;obj);</span><br><span class="line">        zslFreeNode(x);</span><br><span class="line">        removed++;</span><br><span class="line">        x = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unsigned-long-zslDeleteRangeByRank-zskiplist-zsl-unsigned-int-start-unsigned-int-end-dict-dict"><a href="#unsigned-long-zslDeleteRangeByRank-zskiplist-zsl-unsigned-int-start-unsigned-int-end-dict-dict" class="headerlink" title="unsigned long zslDeleteRangeByRank(zskiplist *zsl, unsigned int start, unsigned int end, dict *dict);"></a><code>unsigned long zslDeleteRangeByRank(zskiplist *zsl, unsigned int start, unsigned int end, dict *dict);</code></h3><h4 id="功能-15"><a href="#功能-15" class="headerlink" title="功能"></a>功能</h4><p>根据rank的起始和结束位置删除跳表数据<br>dict是同时删除dict内的记录</p>
<h4 id="源码-15"><a href="#源码-15" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Delete all the elements with rank between start and end from the skiplist.</span></span><br><span class="line"><span class="comment"> * Start and end are inclusive. Note that start and end need to be 1-based */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">zslDeleteRangeByRank</span><span class="params">(zskiplist *zsl, <span class="keyword">unsigned</span> <span class="keyword">int</span> start, <span class="keyword">unsigned</span> <span class="keyword">int</span> end, dict *dict)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> traversed = <span class="number">0</span>, removed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp; (traversed + x-&gt;level[i].span) &lt; start) &#123;</span><br><span class="line">            traversed += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    traversed++;</span><br><span class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">    <span class="keyword">while</span> (x &amp;&amp; traversed &lt;= end) &#123;</span><br><span class="line">        zskiplistNode *next = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">        zslDeleteNode(zsl,x,update);</span><br><span class="line">        dictDelete(dict,x-&gt;obj);</span><br><span class="line">        zslFreeNode(x);</span><br><span class="line">        removed++;</span><br><span class="line">        traversed++;</span><br><span class="line">        x = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unsigned-long-zslGetRank-zskiplist-zsl-double-score-robj-o"><a href="#unsigned-long-zslGetRank-zskiplist-zsl-double-score-robj-o" class="headerlink" title="unsigned long zslGetRank(zskiplist *zsl, double score, robj *o);"></a><code>unsigned long zslGetRank(zskiplist *zsl, double score, robj *o);</code></h3><h4 id="功能-16"><a href="#功能-16" class="headerlink" title="功能"></a>功能</h4><p>根据积分和对象查找在跳表中的rank信息<br>不存在则返回0</p>
<h4 id="源码-16"><a href="#源码-16" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Find the rank for an element by both score and key.</span></span><br><span class="line"><span class="comment"> * Returns 0 when the element cannot be found, rank otherwise.</span></span><br><span class="line"><span class="comment"> * Note that the rank is 1-based due to the span of zsl-&gt;header to the</span></span><br><span class="line"><span class="comment"> * first element. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">zslGetRank</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, robj *o)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rank = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,o) &lt;= <span class="number">0</span>))) &#123;</span><br><span class="line">            rank += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* x might be equal to zsl-&gt;header, so test if obj is non-NULL */</span></span><br><span class="line">        <span class="keyword">if</span> (x-&gt;obj &amp;&amp; equalStringObjects(x-&gt;obj,o)) &#123;</span><br><span class="line">            <span class="keyword">return</span> rank;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="zskiplistNode-zslGetElementByRank-zskiplist-zsl-unsigned-long-rank"><a href="#zskiplistNode-zslGetElementByRank-zskiplist-zsl-unsigned-long-rank" class="headerlink" title="zskiplistNode* zslGetElementByRank(zskiplist *zsl, unsigned long rank);"></a><code>zskiplistNode* zslGetElementByRank(zskiplist *zsl, unsigned long rank);</code></h3><h4 id="功能-17"><a href="#功能-17" class="headerlink" title="功能"></a>功能</h4><p>根据rank信息查找对应的跳表元素</p>
<h4 id="源码-17"><a href="#源码-17" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Finds an element by its rank. The rank argument needs to be 1-based. */</span></span><br><span class="line"><span class="function">zskiplistNode* <span class="title">zslGetElementByRank</span><span class="params">(zskiplist *zsl, <span class="keyword">unsigned</span> <span class="keyword">long</span> rank)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> traversed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp; (traversed + x-&gt;level[i].span) &lt;= rank)</span><br><span class="line">        &#123;</span><br><span class="line">            traversed += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (traversed == rank) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>redis</category>
        <category>source</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 源码分析-字符串</title>
    <url>/2018/04/27/redis-source-string/</url>
    <content><![CDATA[<p>动态长度字符串<br>本质就是<code>typedef char *sds;</code><br>但是redis在sds的前面又增加了一个数据结构(不同长度数据结构不一样)<br>和c++的string不一样,这里的长度,容量和内存申请都是完全独立的<br>需要非常小心的手动维护<br>否则会出现数值和实际申请的内存不一致的情况</p>
<h2 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h2><ul>
<li>sds.h</li>
<li>sds.c</li>
</ul>
<a id="more"></a>

<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul>
<li>内存对齐<br>  gcc的对齐是有优化的,按照结构体的最大位数进行对齐<br>  <code>__attribute__ ((__packed__))</code>的含义是取消gcc的对齐,数据实际占用多少就用多少内存<br>  没有空空间</li>
<li>宏中<code>#</code>的含义<ul>
<li><code>#</code>,将参数按字面表现转化为字符串</li>
<li><code>##</code>,字符串拼接</li>
</ul>
</li>
</ul>
<h2 id="主要函数"><a href="#主要函数" class="headerlink" title="主要函数"></a>主要函数</h2><h3 id="外部调用"><a href="#外部调用" class="headerlink" title="外部调用"></a>外部调用</h3><ul>
<li>创建字符串<br>  <code>sds sdsnew(const char *init);</code></li>
<li>创建空字符串<br>  <code>sds sdsempty(void);</code></li>
<li>复制字符串<br>  <code>sds sdsdup(const sds s);</code></li>
<li>释放字符串<br>  <code>void sdsfree(sds s);</code></li>
<li>连接字符串<br>  <code>sds sdscat(sds s, const char *t);</code></li>
<li>复制字符串到已有字符串<br>  <code>sds sdscpy(sds s, const char *t);</code></li>
</ul>
<h3 id="内部调用"><a href="#内部调用" class="headerlink" title="内部调用"></a>内部调用</h3><ul>
<li>扩展字符串容量<br>  <code>sds sdsMakeRoomFor(sds s, size_t addlen);</code></li>
<li>维护字符串新增长度<br>  <code>void sdsIncrLen(sds s, int incr);</code></li>
<li>将容量设置为长度,节省内存<br>  <code>sds sdsRemoveFreeSpace(sds s);</code></li>
<li>获取字符串容量(包含结构体长度)<br>  <code>size_t sdsAllocSize(sds s);</code></li>
<li>获取字符串实际结构指针<br>  <code>void *sdsAllocPtr(sds s);</code></li>
<li>获取字符串长度<br>  <code>static inline size_t sdslen(const sds s)</code></li>
<li>获取字符串剩余空间<br>  <code>static inline size_t sdsavail(const sds s)</code></li>
<li>变更字符传长度记录<br>  <code>static inline void sdssetlen(sds s, size_t newlen)</code></li>
<li>增加字符串长度记录<br>  <code>static inline void sdsinclen(sds s, size_t inc)</code></li>
<li>获取字符串容量<br>  <code>static inline size_t sdsalloc(const sds s)</code></li>
<li>变更字符串容量记录<br>  <code>static inline void sdssetalloc(sds s, size_t newlen)</code></li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li>数据记录是使用<code>char*</code></li>
<li>所有的<code>sdshdr</code>结尾都使用<code>char buf[]</code>动态数组做结尾,不占用内存</li>
<li><code>flags</code>字段的低3位是记录改字符串的数据结构类型</li>
<li><code>sdshdr5</code>的高5位记录字符串长度</li>
<li>非<code>sdshdr5</code>的数据结构<code>len</code>是长度(实际使用的连续可用内存的大小)</li>
<li><code>alloc</code>是容量(实际申请的可用连续内存的大小)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h2><h3 id="define-SDS-HDR-VAR-T-s"><a href="#define-SDS-HDR-VAR-T-s" class="headerlink" title="#define SDS_HDR_VAR(T,s)"></a><code>#define SDS_HDR_VAR(T,s)</code></h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>获取<code>sds</code>字符串的原始结构体指针<code>sh</code></p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));</span></span><br></pre></td></tr></table></figure>

<h3 id="define-SDS-HDR-T-s"><a href="#define-SDS-HDR-T-s" class="headerlink" title="#define SDS_HDR(T,s)"></a><code>#define SDS_HDR(T,s)</code></h3><h4 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h4><p>将<code>sds</code>字符串转换为原始结构体指针</p>
<h4 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))</span></span><br></pre></td></tr></table></figure>

<h3 id="sds-sdsnewlen-const-void-init-size-t-initlen"><a href="#sds-sdsnewlen-const-void-init-size-t-initlen" class="headerlink" title="sds sdsnewlen(const void *init, size_t initlen);"></a><code>sds sdsnewlen(const void *init, size_t initlen);</code></h3><h4 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create a new sds string with the content specified by the &#x27;init&#x27; pointer</span></span><br><span class="line"><span class="comment"> * and &#x27;initlen&#x27;.</span></span><br><span class="line"><span class="comment"> * If NULL is used for &#x27;init&#x27; the string is initialized with zero bytes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The string is always null-termined (all the sds strings are, always) so</span></span><br><span class="line"><span class="comment"> * even if you create an sds string with:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * mystring = sdsnewlen(&quot;abc&quot;,3);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * You can print the string with printf() as there is an implicit \0 at the</span></span><br><span class="line"><span class="comment"> * end of the string. However the string is binary safe and can contain</span></span><br><span class="line"><span class="comment"> * \0 characters in the middle, as the length is stored in the sds header. */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh;</span><br><span class="line">    sds s;</span><br><span class="line">    <span class="keyword">char</span> type = sdsReqType(initlen); <span class="comment">// 根据长度判断出需要存储的数据类型</span></span><br><span class="line">    <span class="comment">/* Empty strings are usually created in order to append. Use type 8</span></span><br><span class="line"><span class="comment">     * since type 5 is not good at this. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class="number">0</span>) type = SDS_TYPE_8; <span class="comment">// 使用SDS_TYPE_8来做空字符串</span></span><br><span class="line">    <span class="keyword">int</span> hdrlen = sdsHdrSize(type); <span class="comment">// 获取结构体本身长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp; <span class="comment">/* flags pointer. */</span></span><br><span class="line"></span><br><span class="line">    sh = s_malloc(hdrlen+initlen+<span class="number">1</span>); <span class="comment">// 申请内存(结构体长度+字符串长度+结尾终止符)</span></span><br><span class="line">    <span class="keyword">if</span> (!init)</span><br><span class="line">        <span class="built_in">memset</span>(sh, <span class="number">0</span>, hdrlen+initlen+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    s = (<span class="keyword">char</span>*)sh+hdrlen;</span><br><span class="line">    fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s)<span class="number">-1</span>; <span class="comment">// 根据内存排序,这里的[-1]就是结构体中的`flags`</span></span><br><span class="line">    <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">16</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">32</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">64</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(s, init, initlen); <span class="comment">// 赋值</span></span><br><span class="line">    s[initlen] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 标记结束符</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sds-sdsempty-void"><a href="#sds-sdsempty-void" class="headerlink" title="sds sdsempty(void);"></a><code>sds sdsempty(void);</code></h3><h4 id="功能-3"><a href="#功能-3" class="headerlink" title="功能"></a>功能</h4><p>创建空字符串<br>常用于复制,连接字符串</p>
<h4 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsempty</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(<span class="string">&quot;&quot;</span>,<span class="number">0</span>); <span class="comment">// 这里即使长度是0,结尾也有结束符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sds-sdsnew-const-char-init"><a href="#sds-sdsnew-const-char-init" class="headerlink" title="sds sdsnew(const char *init);"></a><code>sds sdsnew(const char *init);</code></h3><h4 id="功能-4"><a href="#功能-4" class="headerlink" title="功能"></a>功能</h4><p>根据字符串创建一个<code>sds</code></p>
<h4 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> initlen = (init == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">strlen</span>(init);</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(init, initlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sds-sdsdup-const-sds-s"><a href="#sds-sdsdup-const-sds-s" class="headerlink" title="sds sdsdup(const sds s);"></a><code>sds sdsdup(const sds s);</code></h3><h4 id="功能-5"><a href="#功能-5" class="headerlink" title="功能"></a>功能</h4><p>复制字符串</p>
<h4 id="源码-4"><a href="#源码-4" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsdup</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(s, sdslen(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void-sdsfree-sds-s"><a href="#void-sdsfree-sds-s" class="headerlink" title="void sdsfree(sds s);"></a><code>void sdsfree(sds s);</code></h3><h4 id="功能-6"><a href="#功能-6" class="headerlink" title="功能"></a>功能</h4><p>释放字符串空间</p>
<h4 id="源码-5"><a href="#源码-5" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    s_free((<span class="keyword">char</span>*)s-sdsHdrSize(s[<span class="number">-1</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void-sdsclear-sds-s"><a href="#void-sdsclear-sds-s" class="headerlink" title="void sdsclear(sds s);"></a><code>void sdsclear(sds s);</code></h3><h4 id="功能-7"><a href="#功能-7" class="headerlink" title="功能"></a>功能</h4><p>清空字符串内容<br>申请的内存和结构不动<br>后续使用这个字符串不需要重新申请内存</p>
<h4 id="源码-6"><a href="#源码-6" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsclear</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    sdssetlen(s, <span class="number">0</span>);</span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sds-sdsMakeRoomFor-sds-s-size-t-addlen"><a href="#sds-sdsMakeRoomFor-sds-s-size-t-addlen" class="headerlink" title="sds sdsMakeRoomFor(sds s, size_t addlen);"></a><code>sds sdsMakeRoomFor(sds s, size_t addlen);</code></h3><h4 id="功能-8"><a href="#功能-8" class="headerlink" title="功能"></a>功能</h4><p>扩大字符串的容量<br>为连接/扩展字符串做准备</p>
<h4 id="源码-7"><a href="#源码-7" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh, *newsh;</span><br><span class="line">    <span class="keyword">size_t</span> avail = sdsavail(s);</span><br><span class="line">    <span class="keyword">size_t</span> len, newlen;</span><br><span class="line">    <span class="keyword">char</span> type, oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK;</span><br><span class="line">    <span class="keyword">int</span> hdrlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return ASAP if there is enough space left. */</span></span><br><span class="line">    <span class="keyword">if</span> (avail &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    sh = (<span class="keyword">char</span>*)s-sdsHdrSize(oldtype);</span><br><span class="line">    newlen = (len+addlen);</span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line"></span><br><span class="line">    type = sdsReqType(newlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don&#x27;t use type 5: the user is appending to the string and type 5 is</span></span><br><span class="line"><span class="comment">     * not able to remember empty space, so sdsMakeRoomFor() must be called</span></span><br><span class="line"><span class="comment">     * at every appending operation. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8;</span><br><span class="line"></span><br><span class="line">    hdrlen = sdsHdrSize(type);</span><br><span class="line">    <span class="keyword">if</span> (oldtype==type) &#123;</span><br><span class="line">        newsh = s_realloc(sh, hdrlen+newlen+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Since the header size changes, need to move the string forward,</span></span><br><span class="line"><span class="comment">         * and can&#x27;t use realloc */</span></span><br><span class="line">        newsh = s_malloc(hdrlen+newlen+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)newsh+hdrlen, s, len+<span class="number">1</span>);</span><br><span class="line">        s_free(sh);</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen;</span><br><span class="line">        s[<span class="number">-1</span>] = type;</span><br><span class="line">        sdssetlen(s, len);</span><br><span class="line">    &#125;</span><br><span class="line">    sdssetalloc(s, newlen);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sds-sdsRemoveFreeSpace-sds-s"><a href="#sds-sdsRemoveFreeSpace-sds-s" class="headerlink" title="sds sdsRemoveFreeSpace(sds s);"></a><code>sds sdsRemoveFreeSpace(sds s);</code></h3><h4 id="功能-9"><a href="#功能-9" class="headerlink" title="功能"></a>功能</h4><p>清空字符串结构的容量冗余<br>使容量等于字符串长度<br>节省内存使用</p>
<h4 id="源码-8"><a href="#源码-8" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Reallocate the sds string so that it has no free space at the end. The</span></span><br><span class="line"><span class="comment"> * contained string remains not altered, but next concatenation operations</span></span><br><span class="line"><span class="comment"> * will require a reallocation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * After the call, the passed sds string is no longer valid and all the</span></span><br><span class="line"><span class="comment"> * references must be substituted with the new pointer returned by the call. */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsRemoveFreeSpace</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh, *newsh;</span><br><span class="line">    <span class="keyword">char</span> type, oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK; <span class="comment">// 获取字符串结构类型</span></span><br><span class="line">    <span class="keyword">int</span> hdrlen;</span><br><span class="line">    <span class="keyword">size_t</span> len = sdslen(s); <span class="comment">// 获取字符串长度</span></span><br><span class="line">    sh = (<span class="keyword">char</span>*)s-sdsHdrSize(oldtype); <span class="comment">// 获取字符串原始结构指针</span></span><br><span class="line"></span><br><span class="line">    type = sdsReqType(len); <span class="comment">// 获取最终转化的类型</span></span><br><span class="line">    hdrlen = sdsHdrSize(type); <span class="comment">// 获取最终转化的结构头长度</span></span><br><span class="line">    <span class="keyword">if</span> (oldtype==type) &#123; <span class="comment">// 类型没有变化</span></span><br><span class="line">        newsh = s_realloc(sh, hdrlen+len+<span class="number">1</span>); <span class="comment">// 重新分配申请内存的大小(截断以前的剩余空间)</span></span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen; <span class="comment">// 获取新的字符串首地址</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newsh = s_malloc(hdrlen+len+<span class="number">1</span>); <span class="comment">// 申请新结构体空间</span></span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)newsh+hdrlen, s, len+<span class="number">1</span>); <span class="comment">// 复制原始字符串数据</span></span><br><span class="line">        s_free(sh); <span class="comment">// 释放原始指针</span></span><br><span class="line">        s = (<span class="keyword">char</span>*)newsh+hdrlen; <span class="comment">// 获取新的字符串首地址</span></span><br><span class="line">        s[<span class="number">-1</span>] = type; <span class="comment">// 设置新类型</span></span><br><span class="line">        sdssetlen(s, len); <span class="comment">// 标记字符串长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    sdssetalloc(s, len); <span class="comment">// 标记字符串容量</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sds-sdsgrowzero-sds-s-size-t-len"><a href="#sds-sdsgrowzero-sds-s-size-t-len" class="headerlink" title="sds sdsgrowzero(sds s, size_t len);"></a><code>sds sdsgrowzero(sds s, size_t len);</code></h3><h4 id="功能-10"><a href="#功能-10" class="headerlink" title="功能"></a>功能</h4><p>从有效字符串结尾开始,直到<code>len</code>位置<br>初始化所有数据为0</p>
<h4 id="源码-9"><a href="#源码-9" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Grow the sds to have the specified length. Bytes that were not part of</span></span><br><span class="line"><span class="comment"> * the original length of the sds will be set to zero.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * if the specified length is smaller than the current length, no operation</span></span><br><span class="line"><span class="comment"> * is performed. */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsgrowzero</span><span class="params">(sds s, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= curlen) <span class="keyword">return</span> s;</span><br><span class="line">    s = sdsMakeRoomFor(s,len-curlen);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure added region doesn&#x27;t contain garbage */</span></span><br><span class="line">    <span class="built_in">memset</span>(s+curlen,<span class="number">0</span>,(len-curlen+<span class="number">1</span>)); <span class="comment">/* also set trailing \0 byte */</span></span><br><span class="line">    sdssetlen(s, len);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sds-sdscatlen-sds-s-const-void-t-size-t-len"><a href="#sds-sdscatlen-sds-s-const-void-t-size-t-len" class="headerlink" title="sds sdscatlen(sds s, const void *t, size_t len);"></a><code>sds sdscatlen(sds s, const void *t, size_t len);</code></h3><h4 id="功能-11"><a href="#功能-11" class="headerlink" title="功能"></a>功能</h4><p>字符串连接</p>
<h4 id="源码-10"><a href="#源码-10" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Append the specified binary-safe string pointed by &#x27;t&#x27; of &#x27;len&#x27; bytes to the</span></span><br><span class="line"><span class="comment"> * end of the specified sds string &#x27;s&#x27;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * After the call, the passed sds string is no longer valid and all the</span></span><br><span class="line"><span class="comment"> * references must be substituted with the new pointer returned by the call. */</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</span><br><span class="line"></span><br><span class="line">    s = sdsMakeRoomFor(s,len);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</span><br><span class="line">    sdssetlen(s, curlen+len);</span><br><span class="line">    s[curlen+len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int-sdsll2str-char-s-long-long-value"><a href="#int-sdsll2str-char-s-long-long-value" class="headerlink" title="int sdsll2str(char *s, long long value);"></a><code>int sdsll2str(char *s, long long value);</code></h3><h4 id="功能-12"><a href="#功能-12" class="headerlink" title="功能"></a>功能</h4><p>将数字按字面值转化为字符串</p>
<h4 id="源码-11"><a href="#源码-11" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Helper for sdscatlonglong() doing the actual number -&gt; string</span></span><br><span class="line"><span class="comment"> * conversion. &#x27;s&#x27; must point to a string with room for at least</span></span><br><span class="line"><span class="comment"> * SDS_LLSTR_SIZE bytes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns the length of the null-terminated string</span></span><br><span class="line"><span class="comment"> * representation stored at &#x27;s&#x27;. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_LLSTR_SIZE 21</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sdsll2str</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">long</span> <span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p, aux;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> v;</span><br><span class="line">    <span class="keyword">size_t</span> l;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Generate the string representation, this method produces</span></span><br><span class="line"><span class="comment">     * an reversed string. */</span></span><br><span class="line">    v = (value &lt; <span class="number">0</span>) ? -value : value;</span><br><span class="line">    p = s;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        *p++ = <span class="string">&#x27;0&#x27;</span>+(v%<span class="number">10</span>);</span><br><span class="line">        v /= <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span>(v);</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span>) *p++ = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Compute length and add null term. */</span></span><br><span class="line">    l = p-s;</span><br><span class="line">    *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reverse the string. */</span></span><br><span class="line">    p--;</span><br><span class="line">    <span class="keyword">while</span>(s &lt; p) &#123;</span><br><span class="line">        aux = *s;</span><br><span class="line">        *s = *p;</span><br><span class="line">        *p = aux;</span><br><span class="line">        s++;</span><br><span class="line">        p--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sds-sdsfromlonglong-long-long-value"><a href="#sds-sdsfromlonglong-long-long-value" class="headerlink" title="sds sdsfromlonglong(long long value);"></a><code>sds sdsfromlonglong(long long value);</code></h3><h4 id="功能-13"><a href="#功能-13" class="headerlink" title="功能"></a>功能</h4><p>将数字转化为sds</p>
<h4 id="源码-12"><a href="#源码-12" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsfromlonglong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[SDS_LLSTR_SIZE];</span><br><span class="line">    <span class="keyword">int</span> len = sdsll2str(buf,value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(buf,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sds-sdscatvprintf-sds-s-const-char-fmt-va-list-ap"><a href="#sds-sdscatvprintf-sds-s-const-char-fmt-va-list-ap" class="headerlink" title="sds sdscatvprintf(sds s, const char *fmt, va_list ap);"></a><code>sds sdscatvprintf(sds s, const char *fmt, va_list ap);</code></h3><h4 id="功能-14"><a href="#功能-14" class="headerlink" title="功能"></a>功能</h4><p>字符串格式化连接</p>
<h4 id="源码-13"><a href="#源码-13" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Like sdscatprintf() but gets va_list instead of being variadic. */</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatvprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span> </span>&#123;</span><br><span class="line">    va_list cpy;</span><br><span class="line">    <span class="keyword">char</span> staticbuf[<span class="number">1024</span>], *buf = staticbuf, *t;</span><br><span class="line">    <span class="keyword">size_t</span> buflen = <span class="built_in">strlen</span>(fmt)*<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We try to start using a static buffer for speed.</span></span><br><span class="line"><span class="comment">     * If not possible we revert to heap allocation. */</span></span><br><span class="line">    <span class="keyword">if</span> (buflen &gt; <span class="keyword">sizeof</span>(staticbuf)) &#123;</span><br><span class="line">        buf = s_malloc(buflen);</span><br><span class="line">        <span class="keyword">if</span> (buf == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buflen = <span class="keyword">sizeof</span>(staticbuf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Try with buffers two times bigger every time we fail to</span></span><br><span class="line"><span class="comment">     * fit the string in the current buffer size. */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        buf[buflen<span class="number">-2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        va_copy(cpy,ap);</span><br><span class="line">        vsnprintf(buf, buflen, fmt, cpy);</span><br><span class="line">        va_end(cpy);</span><br><span class="line">        <span class="keyword">if</span> (buf[buflen<span class="number">-2</span>] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buf != staticbuf) s_free(buf);</span><br><span class="line">            buflen *= <span class="number">2</span>;</span><br><span class="line">            buf = s_malloc(buflen);</span><br><span class="line">            <span class="keyword">if</span> (buf == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Finally concat the obtained string to the SDS string and return it. */</span></span><br><span class="line">    t = sdscat(s, buf);</span><br><span class="line">    <span class="keyword">if</span> (buf != staticbuf) s_free(buf);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sds-sdscatprintf-sds-s-const-char-fmt"><a href="#sds-sdscatprintf-sds-s-const-char-fmt" class="headerlink" title="sds sdscatprintf(sds s, const char *fmt, ...);"></a><code>sds sdscatprintf(sds s, const char *fmt, ...);</code></h3><h4 id="功能-15"><a href="#功能-15" class="headerlink" title="功能"></a>功能</h4><p>字符串格式化连接</p>
<h4 id="源码-14"><a href="#源码-14" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Append to the sds string &#x27;s&#x27; a string obtained using printf-alike format</span></span><br><span class="line"><span class="comment"> * specifier.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * After the call, the modified sds string is no longer valid and all the</span></span><br><span class="line"><span class="comment"> * references must be substituted with the new pointer returned by the call.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * s = sdsnew(&quot;Sum is: &quot;);</span></span><br><span class="line"><span class="comment"> * s = sdscatprintf(s,&quot;%d+%d = %d&quot;,a,b,a+b).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Often you need to create a string from scratch with the printf-alike</span></span><br><span class="line"><span class="comment"> * format. When this is the need, just use sdsempty() as the target string:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * s = sdscatprintf(sdsempty(), &quot;... your format ...&quot;, args);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatprintf</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="keyword">char</span> *t;</span><br><span class="line">    va_start(ap, fmt);</span><br><span class="line">    t = sdscatvprintf(s,fmt,ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sds-sdscatfmt-sds-s-char-const-fmt"><a href="#sds-sdscatfmt-sds-s-char-const-fmt" class="headerlink" title="sds sdscatfmt(sds s, char const *fmt, ...);"></a><code>sds sdscatfmt(sds s, char const *fmt, ...);</code></h3><h4 id="功能-16"><a href="#功能-16" class="headerlink" title="功能"></a>功能</h4><p>字符串格式化连接(高效简略版)</p>
<h4 id="源码-15"><a href="#源码-15" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This function is similar to sdscatprintf, but much faster as it does</span></span><br><span class="line"><span class="comment"> * not rely on sprintf() family functions implemented by the libc that</span></span><br><span class="line"><span class="comment"> * are often very slow. Moreover directly handling the sds string as</span></span><br><span class="line"><span class="comment"> * new data is concatenated provides a performance improvement.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * However this function only handles an incompatible subset of printf-alike</span></span><br><span class="line"><span class="comment"> * format specifiers:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %s - C String</span></span><br><span class="line"><span class="comment"> * %S - SDS string</span></span><br><span class="line"><span class="comment"> * %i - signed int</span></span><br><span class="line"><span class="comment"> * %I - 64 bit signed integer (long long, int64_t)</span></span><br><span class="line"><span class="comment"> * %u - unsigned int</span></span><br><span class="line"><span class="comment"> * %U - 64 bit unsigned integer (unsigned long long, uint64_t)</span></span><br><span class="line"><span class="comment"> * %% - Verbatim &quot;%&quot; character.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatfmt</span><span class="params">(sds s, <span class="keyword">char</span> <span class="keyword">const</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> initlen = sdslen(s);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *f = fmt;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    va_list ap;</span><br><span class="line"></span><br><span class="line">    va_start(ap,fmt);</span><br><span class="line">    f = fmt;    <span class="comment">/* Next format specifier byte to process. */</span></span><br><span class="line">    i = initlen; <span class="comment">/* Position of the next byte to write to dest str. */</span></span><br><span class="line">    <span class="keyword">while</span>(*f) &#123;</span><br><span class="line">        <span class="keyword">char</span> next, *str;</span><br><span class="line">        <span class="keyword">size_t</span> l;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> unum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Make sure there is always space for at least 1 char. */</span></span><br><span class="line">        <span class="keyword">if</span> (sdsavail(s)==<span class="number">0</span>) &#123;</span><br><span class="line">            s = sdsMakeRoomFor(s,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(*f) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">            next = *(f+<span class="number">1</span>);</span><br><span class="line">            f++;</span><br><span class="line">            <span class="keyword">switch</span>(next) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">                str = va_arg(ap,<span class="keyword">char</span>*);</span><br><span class="line">                l = (next == <span class="string">&#x27;s&#x27;</span>) ? <span class="built_in">strlen</span>(str) : sdslen(str);</span><br><span class="line">                <span class="keyword">if</span> (sdsavail(s) &lt; l) &#123;</span><br><span class="line">                    s = sdsMakeRoomFor(s,l);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">memcpy</span>(s+i,str,l);</span><br><span class="line">                sdsinclen(s,l);</span><br><span class="line">                i += l;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="string">&#x27;i&#x27;</span>)</span><br><span class="line">                    num = va_arg(ap,<span class="keyword">int</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    num = va_arg(ap,<span class="keyword">long</span> <span class="keyword">long</span>);</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">char</span> buf[SDS_LLSTR_SIZE];</span><br><span class="line">                    l = sdsll2str(buf,num);</span><br><span class="line">                    <span class="keyword">if</span> (sdsavail(s) &lt; l) &#123;</span><br><span class="line">                        s = sdsMakeRoomFor(s,l);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">memcpy</span>(s+i,buf,l);</span><br><span class="line">                    sdsinclen(s,l);</span><br><span class="line">                    i += l;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;U&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="string">&#x27;u&#x27;</span>)</span><br><span class="line">                    unum = va_arg(ap,<span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    unum = va_arg(ap,<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>);</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">char</span> buf[SDS_LLSTR_SIZE];</span><br><span class="line">                    l = sdsull2str(buf,unum);</span><br><span class="line">                    <span class="keyword">if</span> (sdsavail(s) &lt; l) &#123;</span><br><span class="line">                        s = sdsMakeRoomFor(s,l);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">memcpy</span>(s+i,buf,l);</span><br><span class="line">                    sdsinclen(s,l);</span><br><span class="line">                    i += l;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="comment">/* Handle %% and generally %&lt;unknown&gt;. */</span></span><br><span class="line">                s[i++] = next;</span><br><span class="line">                sdsinclen(s,<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            s[i++] = *f;</span><br><span class="line">            sdsinclen(s,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f++;</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(ap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Add null-term */</span></span><br><span class="line">    s[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sds-sdstrim-sds-s-const-char-cset"><a href="#sds-sdstrim-sds-s-const-char-cset" class="headerlink" title="sds sdstrim(sds s, const char *cset);"></a><code>sds sdstrim(sds s, const char *cset);</code></h3><h4 id="功能-17"><a href="#功能-17" class="headerlink" title="功能"></a>功能</h4><p>去除字符串两边需要过滤的字符集</p>
<h4 id="源码-16"><a href="#源码-16" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Remove the part of the string from left and from right composed just of</span></span><br><span class="line"><span class="comment"> * contiguous characters found in &#x27;cset&#x27;, that is a null terminted C string.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * After the call, the modified sds string is no longer valid and all the</span></span><br><span class="line"><span class="comment"> * references must be substituted with the new pointer returned by the call.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * s = sdsnew(&quot;AA...AA.a.aa.aHelloWorld     :::&quot;);</span></span><br><span class="line"><span class="comment"> * s = sdstrim(s,&quot;Aa. :&quot;);</span></span><br><span class="line"><span class="comment"> * printf(&quot;%s\n&quot;, s);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Output will be just &quot;Hello World&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdstrim</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *cset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *start, *end, *sp, *ep;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line"></span><br><span class="line">    sp = start = s;</span><br><span class="line">    ep = end = s+sdslen(s)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(sp &lt;= end &amp;&amp; <span class="built_in">strchr</span>(cset, *sp)) sp++;</span><br><span class="line">    <span class="keyword">while</span>(ep &gt; sp &amp;&amp; <span class="built_in">strchr</span>(cset, *ep)) ep--;</span><br><span class="line">    len = (sp &gt; ep) ? <span class="number">0</span> : ((ep-sp)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != sp) memmove(s, sp, len);</span><br><span class="line">    s[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    sdssetlen(s,len);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void-sdsrange-sds-s-int-start-int-end"><a href="#void-sdsrange-sds-s-int-start-int-end" class="headerlink" title="void sdsrange(sds s, int start, int end)"></a><code>void sdsrange(sds s, int start, int end)</code></h3><h4 id="功能-18"><a href="#功能-18" class="headerlink" title="功能"></a>功能</h4><p>截取字符串<br>支持负数倒叙定位</p>
<h4 id="源码-17"><a href="#源码-17" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Turn the string into a smaller (or equal) string containing only the</span></span><br><span class="line"><span class="comment"> * substring specified by the &#x27;start&#x27; and &#x27;end&#x27; indexes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * start and end can be negative, where -1 means the last character of the</span></span><br><span class="line"><span class="comment"> * string, -2 the penultimate character, and so forth.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The interval is inclusive, so the start and end characters will be part</span></span><br><span class="line"><span class="comment"> * of the resulting string.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The string is modified in-place.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * s = sdsnew(&quot;Hello World&quot;);</span></span><br><span class="line"><span class="comment"> * sdsrange(s,1,-1); =&gt; &quot;ello World&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsrange</span><span class="params">(sds s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> newlen, len = sdslen(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        start = len+start;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        end = len+end;</span><br><span class="line">        <span class="keyword">if</span> (end &lt; <span class="number">0</span>) end = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    newlen = (start &gt; end) ? <span class="number">0</span> : (end-start)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (newlen != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= (<span class="keyword">signed</span>)len) &#123;</span><br><span class="line">            newlen = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end &gt;= (<span class="keyword">signed</span>)len) &#123;</span><br><span class="line">            end = len<span class="number">-1</span>;</span><br><span class="line">            newlen = (start &gt; end) ? <span class="number">0</span> : (end-start)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        start = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (start &amp;&amp; newlen) memmove(s, s+start, newlen);</span><br><span class="line">    s[newlen] = <span class="number">0</span>;</span><br><span class="line">    sdssetlen(s,newlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void-sdstolower-sds-s"><a href="#void-sdstolower-sds-s" class="headerlink" title="void sdstolower(sds s);"></a><code>void sdstolower(sds s);</code></h3><h4 id="功能-19"><a href="#功能-19" class="headerlink" title="功能"></a>功能</h4><p>所有字符变为小写</p>
<h4 id="源码-18"><a href="#源码-18" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Apply tolower() to every character of the sds string &#x27;s&#x27;. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstolower</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = sdslen(s), j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++) s[j] = <span class="built_in">tolower</span>(s[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void-sdstoupper-sds-s"><a href="#void-sdstoupper-sds-s" class="headerlink" title="void sdstoupper(sds s);"></a><code>void sdstoupper(sds s);</code></h3><h4 id="功能-20"><a href="#功能-20" class="headerlink" title="功能"></a>功能</h4><p>所有字符变为大写</p>
<h4 id="源码-19"><a href="#源码-19" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Apply toupper() to every character of the sds string &#x27;s&#x27;. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdstoupper</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = sdslen(s), j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++) s[j] = <span class="built_in">toupper</span>(s[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int-sdscmp-const-sds-s1-const-sds-s2"><a href="#int-sdscmp-const-sds-s1-const-sds-s2" class="headerlink" title="int sdscmp(const sds s1, const sds s2);"></a><code>int sdscmp(const sds s1, const sds s2);</code></h3><h4 id="功能-21"><a href="#功能-21" class="headerlink" title="功能"></a>功能</h4><p>比较两个字符串的大小</p>
<h4 id="源码-20"><a href="#源码-20" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Compare two sds strings s1 and s2 with memcmp().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return value:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     positive if s1 &gt; s2.</span></span><br><span class="line"><span class="comment"> *     negative if s1 &lt; s2.</span></span><br><span class="line"><span class="comment"> *     0 if s1 and s2 are exactly the same binary string.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If two strings share exactly the same prefix, but one of the two has</span></span><br><span class="line"><span class="comment"> * additional characters, the longer string is considered to be greater than</span></span><br><span class="line"><span class="comment"> * the smaller one. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sdscmp</span><span class="params">(<span class="keyword">const</span> sds s1, <span class="keyword">const</span> sds s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> l1, l2, minlen;</span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line"></span><br><span class="line">    l1 = sdslen(s1);</span><br><span class="line">    l2 = sdslen(s2);</span><br><span class="line">    minlen = (l1 &lt; l2) ? l1 : l2;</span><br><span class="line">    cmp = <span class="built_in">memcmp</span>(s1,s2,minlen);</span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> l1-l2;</span><br><span class="line">    <span class="keyword">return</span> cmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sds-sdssplitlen-const-char-s-int-len-const-char-sep-int-seplen-int-count"><a href="#sds-sdssplitlen-const-char-s-int-len-const-char-sep-int-seplen-int-count" class="headerlink" title="sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count);"></a><code>sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count);</code></h3><h4 id="功能-22"><a href="#功能-22" class="headerlink" title="功能"></a>功能</h4><p>将字符串按照sep拆分为字符数组</p>
<h4 id="源码-21"><a href="#源码-21" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Split &#x27;s&#x27; with separator in &#x27;sep&#x27;. An array</span></span><br><span class="line"><span class="comment"> * of sds strings is returned. *count will be set</span></span><br><span class="line"><span class="comment"> * by reference to the number of tokens returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On out of memory, zero length string, zero length</span></span><br><span class="line"><span class="comment"> * separator, NULL is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that &#x27;sep&#x27; is able to split a string using</span></span><br><span class="line"><span class="comment"> * a multi-character separator. For example</span></span><br><span class="line"><span class="comment"> * sdssplit(&quot;foo_-_bar&quot;,&quot;_-_&quot;); will return two</span></span><br><span class="line"><span class="comment"> * elements &quot;foo&quot; and &quot;bar&quot;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This version of the function is binary-safe but</span></span><br><span class="line"><span class="comment"> * requires length arguments. sdssplit() is just the</span></span><br><span class="line"><span class="comment"> * same function but for zero-terminated strings.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds *<span class="title">sdssplitlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> len, <span class="keyword">const</span> <span class="keyword">char</span> *sep, <span class="keyword">int</span> seplen, <span class="keyword">int</span> *count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> elements = <span class="number">0</span>, slots = <span class="number">5</span>, start = <span class="number">0</span>, j;</span><br><span class="line">    sds *tokens;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (seplen &lt; <span class="number">1</span> || len &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    tokens = s_malloc(<span class="keyword">sizeof</span>(sds)*slots);</span><br><span class="line">    <span class="keyword">if</span> (tokens == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        *count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> tokens;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; (len-(seplen<span class="number">-1</span>)); j++) &#123;</span><br><span class="line">        <span class="comment">/* make sure there is room for the next element and the final one */</span></span><br><span class="line">        <span class="keyword">if</span> (slots &lt; elements+<span class="number">2</span>) &#123;</span><br><span class="line">            sds *newtokens;</span><br><span class="line"></span><br><span class="line">            slots *= <span class="number">2</span>;</span><br><span class="line">            newtokens = s_realloc(tokens,<span class="keyword">sizeof</span>(sds)*slots);</span><br><span class="line">            <span class="keyword">if</span> (newtokens == <span class="literal">NULL</span>) <span class="keyword">goto</span> cleanup;</span><br><span class="line">            tokens = newtokens;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* search the separator */</span></span><br><span class="line">        <span class="keyword">if</span> ((seplen == <span class="number">1</span> &amp;&amp; *(s+j) == sep[<span class="number">0</span>]) || (<span class="built_in">memcmp</span>(s+j,sep,seplen) == <span class="number">0</span>)) &#123;</span><br><span class="line">            tokens[elements] = sdsnewlen(s+start,j-start);</span><br><span class="line">            <span class="keyword">if</span> (tokens[elements] == <span class="literal">NULL</span>) <span class="keyword">goto</span> cleanup;</span><br><span class="line">            elements++;</span><br><span class="line">            start = j+seplen;</span><br><span class="line">            j = j+seplen<span class="number">-1</span>; <span class="comment">/* skip the separator */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Add the final element. We are sure there is room in the tokens array. */</span></span><br><span class="line">    tokens[elements] = sdsnewlen(s+start,len-start);</span><br><span class="line">    <span class="keyword">if</span> (tokens[elements] == <span class="literal">NULL</span>) <span class="keyword">goto</span> cleanup;</span><br><span class="line">    elements++;</span><br><span class="line">    *count = elements;</span><br><span class="line">    <span class="keyword">return</span> tokens;</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elements; i++) sdsfree(tokens[i]);</span><br><span class="line">        s_free(tokens);</span><br><span class="line">        *count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void-sdsfreesplitres-sds-tokens-int-count"><a href="#void-sdsfreesplitres-sds-tokens-int-count" class="headerlink" title="void sdsfreesplitres(sds *tokens, int count);"></a><code>void sdsfreesplitres(sds *tokens, int count);</code></h3><h4 id="功能-23"><a href="#功能-23" class="headerlink" title="功能"></a>功能</h4><p>整体释放字符数组</p>
<h4 id="源码-22"><a href="#源码-22" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Free the result returned by sdssplitlen(), or do nothing if &#x27;tokens&#x27; is NULL. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfreesplitres</span><span class="params">(sds *tokens, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tokens) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(count--)</span><br><span class="line">        sdsfree(tokens[count]);</span><br><span class="line">    s_free(tokens);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sds-sdsjoin-char-argv-int-argc-char-sep"><a href="#sds-sdsjoin-char-argv-int-argc-char-sep" class="headerlink" title="sds sdsjoin(char **argv, int argc, char *sep);"></a><code>sds sdsjoin(char **argv, int argc, char *sep);</code></h3><h4 id="功能-24"><a href="#功能-24" class="headerlink" title="功能"></a>功能</h4><p>字符数组连接为一个字符串<br>连接符为<code>sep</code></p>
<h4 id="源码-23"><a href="#源码-23" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Join an array of C strings using the specified separator (also a C string).</span></span><br><span class="line"><span class="comment"> * Returns the result as an sds string. */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsjoin</span><span class="params">(<span class="keyword">char</span> **argv, <span class="keyword">int</span> argc, <span class="keyword">char</span> *sep)</span> </span>&#123;</span><br><span class="line">    sds join = sdsempty();</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) &#123;</span><br><span class="line">        join = sdscat(join, argv[j]);</span><br><span class="line">        <span class="keyword">if</span> (j != argc<span class="number">-1</span>) join = sdscat(join,sep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> join;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>redis</category>
        <category>source</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>REDISLV配置分析</title>
    <url>/2018/07/19/redislv-config/</url>
    <content><![CDATA[<p>REDISLV的配置文件解析redis-config.md</p>
<h2 id="使用配置文件的方法"><a href="#使用配置文件的方法" class="headerlink" title="使用配置文件的方法"></a>使用配置文件的方法</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./redis-server $(path)/redis.conf</span><br></pre></td></tr></table></figure>

<h2 id="常用修改参数"><a href="#常用修改参数" class="headerlink" title="常用修改参数"></a>常用修改参数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bind 127.0.0.1</span><br><span class="line">port 6379</span><br></pre></td></tr></table></figure>

<h2 id="INCLUDE"><a href="#INCLUDE" class="headerlink" title="INCLUDE"></a>INCLUDE</h2><p>使用include可以引用其他配置文件<br>使用用方法:<code>include $(path)/xxx.conf</code><br>可以同时使用多个include</p>
<p>注:<strong>redis是按照顺序解析配置文件参数的,同样的参数后面的设置会覆盖前面的设置</strong><br>如果不希望include被覆盖,<br>就将include放置在配置文件最后,<br>否则就放在前面的位置</p>
<a id="more"></a>
<h2 id="NETWORK"><a href="#NETWORK" class="headerlink" title="NETWORK"></a>NETWORK</h2><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>使用bind参数开启网络监听绑定<br>只有通过被bind的地址才可以访问数据库<br>可以同时bind多个ip(根据代码内宏定义,最多16个ip)<br><strong>bind所绑定的ip地址都是本机ip地址,具体是指这台主机有多个网卡,这些网卡对应的ip地址,而不是远程访问的ip地址</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_BINDADDR_MAX 16</span></span><br></pre></td></tr></table></figure>
<p>如果没有bind参数,则接受所有主机的访问</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bind 192.168.1.100 10.0.0.1</span><br></pre></td></tr></table></figure>

<h3 id="protected-mode"><a href="#protected-mode" class="headerlink" title="protected-mode"></a>protected-mode</h3><h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><p>额外一层防护,防止用户忘记限制ip,同时忘记密码<br>就将数据库暴露在公网上</p>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected-mode yes</span><br><span class="line">protected-mode no</span><br></pre></td></tr></table></figure>

<h4 id="校验触发条件"><a href="#校验触发条件" class="headerlink" title="校验触发条件"></a>校验触发条件</h4><ol>
<li>开启protected-mode</li>
<li>没用bind任何ip</li>
<li>没有启用密码校验</li>
<li>客户端不是通过unix-socket连接过来的</li>
<li>不是来自本机客户端的连接操作</li>
</ol>
<p>同时满足上述条件,则会返回连接失败提示,并告知失败原因</p>
<p>对应代码<code>acceptCommonHandler</code>中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.protected_mode &amp;&amp;</span><br><span class="line">        server.bindaddr_count == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        server.requirepass == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">        !(flags &amp; CLIENT_UNIX_SOCKET) &amp;&amp;</span><br><span class="line">        ip != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(ip,<span class="string">&quot;127.0.0.1&quot;</span>) &amp;&amp; <span class="built_in">strcmp</span>(ip,<span class="string">&quot;::1&quot;</span>)) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="port"><a href="#port" class="headerlink" title="port"></a>port</h3><h4 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h4><p>监听端口<br>设置为0则不开启网络端口监听</p>
<h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">prot 6379</span><br></pre></td></tr></table></figure>

<h3 id="tcp-backlog"><a href="#tcp-backlog" class="headerlink" title="tcp-backlog"></a>tcp-backlog</h3><h4 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h4><p>只有当每秒钟有很多个客户端进行连接数据库时才需要扩大这个值</p>
<ol>
<li>backlog本身<br>tcp-backlog是对应函数<code>listen(backlog)</code>中的参数的一个值<br>backlog本身是一个队列长度<br>当同时请求连接的数量超过这个值时,<br>会连接失败.</li>
</ol>
<p>注:<strong>这个值不是最大连接数,是等待处理连接的数量.</strong><br>当多个连接间隔时间比较长的情况下连接服务器,是不会超出连接等待队列的</p>
<ol start="2">
<li>backlog的值<br>redis的配置文件本身可以设置一个值<br>系统<code>/proc/sys/net/core/somaxconn</code>文件中也有一个这个值<br>实际上这个值是这两个位置的最小值<br>如果需要扩大这个值,需要同时扩大这两个地方</li>
</ol>
<h4 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcp-backlog 511</span><br></pre></td></tr></table></figure>

<h3 id="unixsocket"><a href="#unixsocket" class="headerlink" title="unixsocket"></a>unixsocket</h3><h4 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h4><p>该功能默认关闭<br>模式使用普通网络通信端口进行通信<br>该功能是使用unixsocket进行与客户端之间的通信</p>
<h5 id="unixsocket本身的说明"><a href="#unixsocket本身的说明" class="headerlink" title="unixsocket本身的说明"></a>unixsocket本身的说明</h5><p>unixsocket是unix根据一般的网络IPC通信发展出来的本地文件通信方式.<br>是通过一个文件进行本地进程之间的通信.<br>传统IPC通信是不稳定,不可靠,有乱序.<br>而unixsocket通信是稳定可靠,无乱序,不需要校验的.</p>
<h4 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unixsocket &#x2F;tmp&#x2F;redis.sock # 指定进行通信的文件</span><br><span class="line">unixsocketperm 777 # 指定对文件的操作权限(700可能会无法清除缓存?没有尝试过)</span><br></pre></td></tr></table></figure>

<h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><h4 id="说明-5"><a href="#说明-5" class="headerlink" title="说明"></a>说明</h4><p>客户端连接超时配置<br>单位:秒<br>客户端与服务器上次交互时间到现在超过这个时间则会被断开连接<br>参数:0,无时间限制</p>
<h4 id="例子-5"><a href="#例子-5" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">timeout 0</span><br></pre></td></tr></table></figure>

<h3 id="tcp-keepalive"><a href="#tcp-keepalive" class="headerlink" title="tcp-keepalive"></a>tcp-keepalive</h3><h4 id="说明-6"><a href="#说明-6" class="headerlink" title="说明"></a>说明</h4><p>tcp保持连接的心跳跑检测时间设置<br>tcp网络本身提供了心跳包的检测参数配置<br>可以用于检测客户端是否掉线<br>tcp-keepalive参数单位:秒</p>
<h5 id="SO-KEEPALIVE说明"><a href="#SO-KEEPALIVE说明" class="headerlink" title="SO_KEEPALIVE说明"></a>SO_KEEPALIVE说明</h5><ul>
<li><code>SO_KEEPALIVE</code>,这个是表明启用TCP心跳包</li>
<li><code>TCP_KEEPIDLE</code>,连续多长时间(秒)后没有通信,则发送心跳包</li>
<li><code>TCP_KEEPINTVL</code>,发送心跳包的间隔时间</li>
<li><code>TCP_KEEPCNT</code>,心跳包发送的次数,连续多少次发送没有返回,则说明断开连接,只要有一次返回,则不会发送后续的心跳包</li>
</ul>
<p>注:这个心跳包本身可能有些地方检测不了,当远端突然掉线,拔网线,关机等操作行为导致无法连接时,<br>心跳包机制会以为是发送失败不断重新发送单条协议,而不是判断已经掉线了.TCP的自动重传机制优先度要<br>高于KEEPALIVE机制,导致我们只知道我们自己发送失败,而不是对方已经掉线.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set TCP keep alive option to detect dead peers. The interval option</span></span><br><span class="line"><span class="comment"> * is only used for Linux as we are using Linux-specific APIs to set</span></span><br><span class="line"><span class="comment"> * the probe send time, interval, and count. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetKeepAlive</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd, <span class="keyword">int</span> interval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &amp;val, <span class="keyword">sizeof</span>(val)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        anetSetError(err, <span class="string">&quot;setsockopt SO_KEEPALIVE: %s&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> ANET_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></span><br><span class="line">    <span class="comment">/* Default settings are more or less garbage, with the keepalive time</span></span><br><span class="line"><span class="comment">     * set to 7200 by default on Linux. Modify settings to make the feature</span></span><br><span class="line"><span class="comment">     * actually useful. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Send first probe after interval. */</span></span><br><span class="line">    val = interval;</span><br><span class="line">    <span class="keyword">if</span> (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;val, <span class="keyword">sizeof</span>(val)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        anetSetError(err, <span class="string">&quot;setsockopt TCP_KEEPIDLE: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> ANET_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Send next probes after the specified interval. Note that we set the</span></span><br><span class="line"><span class="comment">     * delay as interval / 3, as we send three probes before detecting</span></span><br><span class="line"><span class="comment">     * an error (see the next setsockopt call). */</span></span><br><span class="line">    val = interval/<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (val == <span class="number">0</span>) val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, &amp;val, <span class="keyword">sizeof</span>(val)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        anetSetError(err, <span class="string">&quot;setsockopt TCP_KEEPINTVL: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> ANET_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Consider the socket in error state after three we send three ACK</span></span><br><span class="line"><span class="comment">     * probes without getting a reply. */</span></span><br><span class="line">    val = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, &amp;val, <span class="keyword">sizeof</span>(val)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        anetSetError(err, <span class="string">&quot;setsockopt TCP_KEEPCNT: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> ANET_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    ((<span class="keyword">void</span>) interval); <span class="comment">/* Avoid unused var warning for non Linux systems. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ANET_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="例子-6"><a href="#例子-6" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcp-keepalive 300</span><br></pre></td></tr></table></figure>

<h2 id="GENERAL"><a href="#GENERAL" class="headerlink" title="GENERAL"></a>GENERAL</h2><h3 id="daemonize"><a href="#daemonize" class="headerlink" title="daemonize"></a>daemonize</h3><h4 id="说明-7"><a href="#说明-7" class="headerlink" title="说明"></a>说明</h4><p>标明redis进程为前台进程还是后台守护进程</p>
<ul>
<li>前台进程,当远程连接关闭后,进程也会随之关闭</li>
<li>后台进程,当远程连接关闭后,进程不会随之关闭,同时会在<code>/var/run/redis.pid</code>文件中记录当前进程的pid</li>
</ul>
<h4 id="例子-7"><a href="#例子-7" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">daemonize yes</span><br></pre></td></tr></table></figure>

<h3 id="supervised"><a href="#supervised" class="headerlink" title="supervised"></a>supervised</h3><h4 id="说明-8"><a href="#说明-8" class="headerlink" title="说明"></a>说明</h4><p>提供不同方式的redis启动和管理的配置</p>
<ul>
<li><code>no</code>,没有启动控制系统,手动启动关闭</li>
<li><code>upstart</code>,以upstart方式启动redis</li>
<li><code>systemd</code>,以<code>systemctl</code>方式启动redis</li>
<li><code>auto</code>,自动判断是以上那种方式</li>
</ul>
<h4 id="例子-8"><a href="#例子-8" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">supervised no</span><br></pre></td></tr></table></figure>

<h3 id="pidfile"><a href="#pidfile" class="headerlink" title="pidfile"></a>pidfile</h3><h4 id="说明-9"><a href="#说明-9" class="headerlink" title="说明"></a>说明</h4><ul>
<li>前台运行时,不指定这个文件,则不会生成pid文件</li>
<li>后台运行时,指定这个文件则在这个文件生成,否则会在默认文件<code>/var/run/redis.pid</code>中生成</li>
</ul>
<p>进程结束后会删除这个文件<br>另外,即时创建pid文件失败也不会影响redis的正常运行</p>
<h4 id="例子-9"><a href="#例子-9" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis-6379.pid</span><br></pre></td></tr></table></figure>

<h3 id="loglevel"><a href="#loglevel" class="headerlink" title="loglevel"></a>loglevel</h3><h4 id="说明-10"><a href="#说明-10" class="headerlink" title="说明"></a>说明</h4><p>日志等级</p>
<ul>
<li>debug,最多日志输出</li>
<li>verbose,比debug少</li>
<li>notice,比verbose少,一般用于实际生产中</li>
<li>warning,只看最重要的信息</li>
</ul>
<h4 id="例子-10"><a href="#例子-10" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loglevel notice</span><br></pre></td></tr></table></figure>

<h3 id="logfile"><a href="#logfile" class="headerlink" title="logfile"></a>logfile</h3><h4 id="说明-11"><a href="#说明-11" class="headerlink" title="说明"></a>说明</h4><p>日志文件(完整地址:路径+文件名)<br>为空表示使用标准输出<br>(文件内容是追加,不是重写,所以不会删除以前的日志内容)</p>
<ul>
<li>前台运行,控制台可以直接看到</li>
<li>后台运行,直接输出到<code>/dev/null</code>中,不会有日志存在</li>
</ul>
<h4 id="例子-11"><a href="#例子-11" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logfile &quot;redis.log&quot;</span><br></pre></td></tr></table></figure>

<h3 id="syslog-enabled"><a href="#syslog-enabled" class="headerlink" title="syslog-enabled"></a>syslog-enabled</h3><h4 id="说明-12"><a href="#说明-12" class="headerlink" title="说明"></a>说明</h4><p>是否使用系统日志记录<br>默认是关闭<br>和上面配置的logfile不冲突,同时开启会记录双份日志<br>日志记录位置:<code>/var/log/messages</code></p>
<h4 id="例子-12"><a href="#例子-12" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">syslog-enabled yes</span><br></pre></td></tr></table></figure>

<h3 id="syslog-ident"><a href="#syslog-ident" class="headerlink" title="syslog-ident"></a>syslog-ident</h3><h4 id="说明-13"><a href="#说明-13" class="headerlink" title="说明"></a>说明</h4><p>系统日志的标识名称<br>在<code>/var/log/messages</code>日志文件中的每行日志都有这个文字作为日志来源的标识</p>
<h4 id="例子-13"><a href="#例子-13" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">syslog-ident redis</span><br></pre></td></tr></table></figure>

<h3 id="syslog-facility"><a href="#syslog-facility" class="headerlink" title="syslog-facility"></a>syslog-facility</h3><h4 id="说明-14"><a href="#说明-14" class="headerlink" title="说明"></a>说明</h4><p>表明日志的来源信息</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* facility codes */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LOG_KERN	(0&lt;&lt;3)	<span class="comment">/* kernel messages */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LOG_USER	(1&lt;&lt;3)	<span class="comment">/* random user-level messages */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LOG_MAIL	(2&lt;&lt;3)	<span class="comment">/* mail system */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LOG_DAEMON	(3&lt;&lt;3)	<span class="comment">/* system daemons */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LOG_AUTH	(4&lt;&lt;3)	<span class="comment">/* security/authorization messages */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LOG_SYSLOG	(5&lt;&lt;3)	<span class="comment">/* messages generated internally by syslogd */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LOG_LPR		(6&lt;&lt;3)	<span class="comment">/* line printer subsystem */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LOG_NEWS	(7&lt;&lt;3)	<span class="comment">/* network news subsystem */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LOG_UUCP	(8&lt;&lt;3)	<span class="comment">/* UUCP subsystem */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LOG_CRON	(9&lt;&lt;3)	<span class="comment">/* clock daemon */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LOG_AUTHPRIV	(10&lt;&lt;3)	<span class="comment">/* security/authorization messages (private) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LOG_FTP		(11&lt;&lt;3)	<span class="comment">/* ftp daemon */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* other codes through 15 reserved for system use */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LOG_LOCAL0	(16&lt;&lt;3)	<span class="comment">/* reserved for local use */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LOG_LOCAL1	(17&lt;&lt;3)	<span class="comment">/* reserved for local use */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LOG_LOCAL2	(18&lt;&lt;3)	<span class="comment">/* reserved for local use */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LOG_LOCAL3	(19&lt;&lt;3)	<span class="comment">/* reserved for local use */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LOG_LOCAL4	(20&lt;&lt;3)	<span class="comment">/* reserved for local use */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LOG_LOCAL5	(21&lt;&lt;3)	<span class="comment">/* reserved for local use */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LOG_LOCAL6	(22&lt;&lt;3)	<span class="comment">/* reserved for local use */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	LOG_LOCAL7	(23&lt;&lt;3)	<span class="comment">/* reserved for local use */</span></span></span><br><span class="line"></span><br><span class="line">configEnum syslog_facility_enum[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;user&quot;</span>,    LOG_USER&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;local0&quot;</span>,  LOG_LOCAL0&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;local1&quot;</span>,  LOG_LOCAL1&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;local2&quot;</span>,  LOG_LOCAL2&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;local3&quot;</span>,  LOG_LOCAL3&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;local4&quot;</span>,  LOG_LOCAL4&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;local5&quot;</span>,  LOG_LOCAL5&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;local6&quot;</span>,  LOG_LOCAL6&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;local7&quot;</span>,  LOG_LOCAL7&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="例子-14"><a href="#例子-14" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">syslog-facility local0</span><br></pre></td></tr></table></figure>

<h3 id="databases"><a href="#databases" class="headerlink" title="databases"></a>databases</h3><h4 id="说明-15"><a href="#说明-15" class="headerlink" title="说明"></a>说明</h4><p>数据库的数量<br>默认数量是16,<br>分别对应数据库编号:0-15,<br>初始数据库使用的时候0<br>可以通过使用命令<code>select $&#123;dbnum&#125;</code>来切换当前使用的数据库</p>
<h4 id="例子-15"><a href="#例子-15" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">databases 16</span><br></pre></td></tr></table></figure>

<h2 id="SNAPSHOTTING"><a href="#SNAPSHOTTING" class="headerlink" title="SNAPSHOTTING"></a>SNAPSHOTTING</h2><h3 id="save"><a href="#save" class="headerlink" title="save"></a>save</h3><h4 id="说明-16"><a href="#说明-16" class="headerlink" title="说明"></a>说明</h4><ul>
<li>条件<ul>
<li>&lt;=指定时间</li>
<li>&gt;=指定次数</li>
</ul>
</li>
<li>结果<ul>
<li>保存数据到硬盘</li>
</ul>
</li>
</ul>
<p>另外:该参数不会互相覆盖,本质是一个数组,校验的时候会遍历每条数据的条件进行<br><code>save &quot;&quot;</code>会重置它所在行之前的所有save命令,是一个清空的功能</p>
<h4 id="例子-16"><a href="#例子-16" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<h3 id="stop-writes-on-bgsave-error"><a href="#stop-writes-on-bgsave-error" class="headerlink" title="stop-writes-on-bgsave-error"></a>stop-writes-on-bgsave-error</h3><h4 id="说明-17"><a href="#说明-17" class="headerlink" title="说明"></a>说明</h4><p>当后台保存数据到硬盘失败时,<br>是否停止对redis的写命令的执行.<br>默认为开启.</p>
<p>当最近一次对数据持久化写硬盘失败后,<br>会在内存中标记写硬盘失败.<br>当该选项开启时,写硬盘失败的话,<br>会同时停止redis对所有写命令的执行,<br>以这种方式来提示用户硬盘写入有问题.</p>
<p>当出现问题后,再次后台保存数据成功时,<br>redis会自动恢复对写命令的执行.</p>
<h4 id="例子-17"><a href="#例子-17" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stop-writes-on-bgsave-error yes</span><br></pre></td></tr></table></figure>

<h3 id="rdbcompression"><a href="#rdbcompression" class="headerlink" title="rdbcompression"></a>rdbcompression</h3><h4 id="说明-18"><a href="#说明-18" class="headerlink" title="说明"></a>说明</h4><p>在进行rdb的dump时,是否对内容进行lzf压缩<br>默认开启,<br>如果为了节省cpu,可以关闭,但是可能会占用更多硬盘</p>
<h4 id="例子-18"><a href="#例子-18" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rdbcompression yes</span><br></pre></td></tr></table></figure>

<h3 id="rdbchecksum"><a href="#rdbchecksum" class="headerlink" title="rdbchecksum"></a>rdbchecksum</h3><h4 id="说明-19"><a href="#说明-19" class="headerlink" title="说明"></a>说明</h4><p>rdb保存在版本5之后会在结尾追加8字节的checksum<br>这个校验和可以增加数据的完整性安全,<br>但是会额外增加大概10%的性能消耗<br>默认开启</p>
<h4 id="例子-19"><a href="#例子-19" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rdbchecksum yes</span><br></pre></td></tr></table></figure>

<h3 id="dbfilename"><a href="#dbfilename" class="headerlink" title="dbfilename"></a>dbfilename</h3><h4 id="说明-20"><a href="#说明-20" class="headerlink" title="说明"></a>说明</h4><p>rdb保存时对应的文件名</p>
<h4 id="例子-20"><a href="#例子-20" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dbfilename dump.rdb</span><br></pre></td></tr></table></figure>

<h3 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h3><h4 id="说明-21"><a href="#说明-21" class="headerlink" title="说明"></a>说明</h4><p>rdb,aof,logfile文件保存时所在的文件夹<br><strong>这里必须是文件夹,而不是一个文件</strong><br>注:leveldb数据保存是在这个文件夹基础上的一个路径</p>
<h4 id="例子-21"><a href="#例子-21" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dir .&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="REPLICATION"><a href="#REPLICATION" class="headerlink" title="REPLICATION"></a>REPLICATION</h2><p>主从备份<br>一个主数据库可以对应多个从数据库<br>从数据库的数据是从主数据库异步同步过来的</p>
<ol>
<li>同步是异步的,但是可以设置主数据库的最少从数据库连接数.<br> 当当前连接的从数据库数量少于最少配置数量时,可以停止<br> 主数据库对写命令的执行</li>
<li>当从数据库在相对短的时间内与主数据库断开连接口,再次连接<br> 时,可以对局部的数据进行重新同步.这个相对短的时间取决于<br> 主数据库设置的backlog的大小</li>
<li>主从备份是自动的,无需手动操作,网络断线后会自动重连</li>
</ol>
<h3 id="slaveof"><a href="#slaveof" class="headerlink" title="slaveof"></a>slaveof</h3><h4 id="说明-22"><a href="#说明-22" class="headerlink" title="说明"></a>说明</h4><p>指明自己是那个redis的从数据库</p>
<h4 id="例子-22"><a href="#例子-22" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slaveof 127.0.0.1 6688</span><br></pre></td></tr></table></figure>

<h3 id="masterauth"><a href="#masterauth" class="headerlink" title="masterauth"></a>masterauth</h3><h4 id="说明-23"><a href="#说明-23" class="headerlink" title="说明"></a>说明</h4><p>如果master启动了密码认证<br>从服务器连接的时候就需要提供密码<br>这里是设置连接主服务器时用的密码的设置</p>
<h4 id="例子-23"><a href="#例子-23" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masterauth &lt;master-password&gt;</span><br></pre></td></tr></table></figure>

<h3 id="slave-serve-stale-data"><a href="#slave-serve-stale-data" class="headerlink" title="slave-serve-stale-data"></a>slave-serve-stale-data</h3><h4 id="说明-24"><a href="#说明-24" class="headerlink" title="说明"></a>说明</h4><p>当从数据库数据不是最新的时候是否提供数据读写服务</p>
<p>可能发生的原因</p>
<ul>
<li>从数据库与主数据库断开连接</li>
<li>从数据库正在从主数据库备份数据过程中</li>
</ul>
<p>处理方式</p>
<ul>
<li>当该参数设置为真,会使用旧数据提供读写服务</li>
<li>当该参数设置为假,除了命令<code>info</code>和<code>slaveof</code><br>  之外的所有命令都会得到<code>SYNC with master in progress</code>的错误信息</li>
</ul>
<h4 id="例子-24"><a href="#例子-24" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slave-serve-stale-data yes</span><br></pre></td></tr></table></figure>

<h3 id="slave-read-only"><a href="#slave-read-only" class="headerlink" title="slave-read-only"></a>slave-read-only</h3><h4 id="说明-25"><a href="#说明-25" class="headerlink" title="说明"></a>说明</h4><p>从数据库是否可写<br>有的时候可能有从数据库可以给非主数据库连接改写的情况(正常不用)<br>从数据库即使设置成只读,<br>也不会屏蔽掉一些管理命令,<br>比如<code>config</code>,<code>debug</code>之类的,<br>如果为了安全考虑,可以使用<code>rename-command</code>来隐藏这些命令</p>
<h4 id="例子-25"><a href="#例子-25" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slave-read-only yes</span><br></pre></td></tr></table></figure>

<h3 id="repl-diskless-sync"><a href="#repl-diskless-sync" class="headerlink" title="repl-diskless-sync"></a>repl-diskless-sync</h3><h4 id="说明-26"><a href="#说明-26" class="headerlink" title="说明"></a>说明</h4><p>当全新的从数据库连接或者重连的从数据库已经超过backlog提供的恢复信息后<br>从数据库需要一个完整的数据同步来达到和主数据库一直的状态<br>有两种方式</p>
<ul>
<li>基于硬盘数据的<br>  主数据库新建进程来创建RDB文件,<br>  主数据库进程将这个RDB文件增量传输给需要的从数据库</li>
<li>无硬盘的<br>  主数据库新建进程<br>  新进程直接创建RDB文件并并直接通过socket发送给相应的从数据库<br>  在硬盘慢带宽大的情况下效果更好</li>
</ul>
<h4 id="例子-26"><a href="#例子-26" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repl-diskless-sync no</span><br></pre></td></tr></table></figure>

<h3 id="repl-diskless-sync-delay"><a href="#repl-diskless-sync-delay" class="headerlink" title="repl-diskless-sync-delay"></a>repl-diskless-sync-delay</h3><h4 id="说明-27"><a href="#说明-27" class="headerlink" title="说明"></a>说明</h4><p>复制同步的延迟<br>当无硬盘备份启动时<br>一旦传输开始,到传输完成为止,<br>期间都不能为新增的从数据库提供同步服务<br>这个延迟是为了等待更多的从数据库<br>进行平行同步用的<br>单位(秒)<br>设置为0则是禁用延迟,立刻同步</p>
<h4 id="例子-27"><a href="#例子-27" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repl-diskless-sync-delay 5</span><br></pre></td></tr></table></figure>

<h3 id="repl-ping-slave-period"><a href="#repl-ping-slave-period" class="headerlink" title="repl-ping-slave-period"></a>repl-ping-slave-period</h3><h4 id="说明-28"><a href="#说明-28" class="headerlink" title="说明"></a>说明</h4><p>主数据库定时ping从数据库,<br>用于检测从数据库是否掉线失去连接.<br>单位:秒<br>默认10秒</p>
<h4 id="例子-28"><a href="#例子-28" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repl-ping-slave-period 10</span><br></pre></td></tr></table></figure>

<h3 id="repl-timeout"><a href="#repl-timeout" class="headerlink" title="repl-timeout"></a>repl-timeout</h3><h4 id="说明-29"><a href="#说明-29" class="headerlink" title="说明"></a>说明</h4><p>这是一个公用的超时时间设置</p>
<ul>
<li>从数据库长时间没有收到主数据库的数据信息<ul>
<li>连接过程中</li>
<li>连接成功后</li>
<li>数据库传输过程中</li>
</ul>
</li>
<li>主数据库长时间没有收到从数据库的数据信息<ul>
<li>没有收到ACK信息</li>
</ul>
</li>
</ul>
<h4 id="例子-29"><a href="#例子-29" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repl-timeout 60</span><br></pre></td></tr></table></figure>

<h3 id="repl-disable-tcp-nodelay"><a href="#repl-disable-tcp-nodelay" class="headerlink" title="repl-disable-tcp-nodelay"></a>repl-disable-tcp-nodelay</h3><h4 id="说明-30"><a href="#说明-30" class="headerlink" title="说明"></a>说明</h4><p>是否禁用TCP的nodelay选项<br>禁用后会降低slave的延迟,但是会增加通信量<br>这个配置很绕</p>
<ul>
<li>no是没有延迟高带宽负载</li>
<li>yes是有延迟低带宽负载</li>
</ul>
<h4 id="例子-30"><a href="#例子-30" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repl-disable-tcp-nodelay no</span><br></pre></td></tr></table></figure>

<h3 id="repl-backlog-size"><a href="#repl-backlog-size" class="headerlink" title="repl-backlog-size"></a>repl-backlog-size</h3><h4 id="说明-31"><a href="#说明-31" class="headerlink" title="说明"></a>说明</h4><p>主从备份的backlog的日志大小<br>当从数据库与主数据库断开一段时间内<br>只要间隔操作还在backlog的记录时间内<br>都可以通过主数据库的backlog来进行数据恢复<br>而不是一次完整的同步<br>backlog只有在任意从数据库初次连接时才会分配内存</p>
<h4 id="例子-31"><a href="#例子-31" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repl-backlog-size 1mb</span><br></pre></td></tr></table></figure>

<h3 id="repl-backlog-ttl"><a href="#repl-backlog-ttl" class="headerlink" title="repl-backlog-ttl"></a>repl-backlog-ttl</h3><h4 id="说明-32"><a href="#说明-32" class="headerlink" title="说明"></a>说明</h4><p>当没有任何从数据库连接时<br>主数据库释放backlog内存空间的延时时间<br>单位:秒<br>从最后一个从数据库断开连接后开始计时</p>
<h4 id="例子-32"><a href="#例子-32" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repl-backlog-ttl 3600</span><br></pre></td></tr></table></figure>

<h3 id="slave-priority"><a href="#slave-priority" class="headerlink" title="slave-priority"></a>slave-priority</h3><h4 id="说明-33"><a href="#说明-33" class="headerlink" title="说明"></a>说明</h4><p>当有哨兵存在时有效<br>哨兵会根据这个值来决定当主数据库失效无法连接时,<br>选取那个从数据库提升为主数据库.<br>哨兵会选取这个值最小的为主数据库.<br>当这个值为0时,表示该数据库不会被选为主数据库.</p>
<p>注:哨兵为<code>redis-sentinel</code>这个程序,启动哨兵只需要修改<code>sentinel.conf</code><br>文件中的主数据库的ip和端口就可以了,哨兵在连接主数据库失败时会自动<br>选举主数据库.<br>注:客户端需要连接哨兵才能知道是那个数据库被提升为主数据库了.</p>
<h4 id="例子-33"><a href="#例子-33" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slave-priority 100</span><br></pre></td></tr></table></figure>

<h3 id="min-slaves-to-write-amp-min-slaves-max-lag"><a href="#min-slaves-to-write-amp-min-slaves-max-lag" class="headerlink" title="min-slaves-to-write &amp; min-slaves-max-lag"></a>min-slaves-to-write &amp; min-slaves-max-lag</h3><h4 id="说明-34"><a href="#说明-34" class="headerlink" title="说明"></a>说明</h4><p>redis可以根据从数据库的数量和从数据库的连接延迟来<br>组织写命令的执行.<br>这是保证数据安全的一种机制</p>
<ul>
<li><code>min-slaves-to-write</code>,最小从数据库数量,当从数据库数量&lt;这个值时,主数据库禁用写命令</li>
<li><code>min-slaves-max-lag</code>,从数据库最大延迟时间,当单个从数据库的延迟时间&lt;这个值时,从数据库数量+1,单位:秒</li>
</ul>
<p>只有同时设置这两个参数,功能才会生效,任意一个没有设置或为0<br>功能不生效</p>
<h4 id="例子-34"><a href="#例子-34" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">min-slaves-to-write 3</span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure>

<h2 id="SECURITY"><a href="#SECURITY" class="headerlink" title="SECURITY"></a>SECURITY</h2><h3 id="requirepass"><a href="#requirepass" class="headerlink" title="requirepass"></a>requirepass</h3><h4 id="说明-35"><a href="#说明-35" class="headerlink" title="说明"></a>说明</h4><p>密码设置,默认注释<br>因为一般都是本机运行<br>因为redis很快,每秒钟可以尝试150k次密码校验<br>所以除非密码异常复杂,否则很容易被试出来.<br>没有任何加密,就是明码字符串,<br>和客户端传来的字符串做比较</p>
<h4 id="例子-35"><a href="#例子-35" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">requirepass foobared</span><br></pre></td></tr></table></figure>

<h3 id="rename-command"><a href="#rename-command" class="headerlink" title="rename-command"></a>rename-command</h3><h4 id="说明-36"><a href="#说明-36" class="headerlink" title="说明"></a>说明</h4><p>重命名命令<br>因为有一些命令非常危险<br>重命名命令为一些很难想想的内容可以保证安全,同时又不影响内部管理员的使用<br>重命名命令为空字符串会完全禁用这个命令</p>
<p>注:<strong>如果使用aof记录数据或者存在从数据库,使用重命名命令可能会导致问题,因为它们的命令可能还是以前正常的命令</strong></p>
<h4 id="例子-36"><a href="#例子-36" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span><br><span class="line">rename-command CONFIG &quot;&quot;</span><br></pre></td></tr></table></figure>

<h2 id="LIMITS"><a href="#LIMITS" class="headerlink" title="LIMITS"></a>LIMITS</h2><h3 id="maxclients"><a href="#maxclients" class="headerlink" title="maxclients"></a>maxclients</h3><h4 id="说明-37"><a href="#说明-37" class="headerlink" title="说明"></a>说明</h4><p>redis可以同时连接的最大客户端数量<br>因为redis内部也会有模拟客户端连接<br>所以实际上可以同时连接的最大客户端数量为<br>这个值-32的结果.<br>当连接数超过这个值时,后面的连接会受到<code>max number of clients reached</code><br>默认值为10000</p>
<h4 id="例子-37"><a href="#例子-37" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">maxclients 10000</span><br></pre></td></tr></table></figure>

<h3 id="maxmemory"><a href="#maxmemory" class="headerlink" title="maxmemory"></a>maxmemory</h3><h4 id="说明-38"><a href="#说明-38" class="headerlink" title="说明"></a>说明</h4><p>redis存储数据(不包括主从备份使用的通信用缓冲区大小)内存使用的大小限制<br>单位:字节</p>
<p>当maxmemory为0时</p>
<ul>
<li>32位机器,maxmemory自动设置为3GB</li>
<li>64位机器,maxmemory为0(不做限制)</li>
</ul>
<h4 id="例子-38"><a href="#例子-38" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">maxmemory &lt;bytes&gt;</span><br></pre></td></tr></table></figure>

<h3 id="maxmemory-policy"><a href="#maxmemory-policy" class="headerlink" title="maxmemory-policy"></a>maxmemory-policy</h3><h4 id="说明-39"><a href="#说明-39" class="headerlink" title="说明"></a>说明</h4><p>当内存到达上限时,<br>redis的内存策略</p>
<ul>
<li>volatile-lru,根据LRU规则删除有时效的数据</li>
<li>allkeys-lru,根据LRU规则删除所有的数据</li>
<li>volatile-random,随机删除有时效的数据</li>
<li>allkeys-random,随机删除所有的数据</li>
<li>volatile-ttl,根据键的失效时间排序,按最快失效的键依次删除(不是精确排序)</li>
<li>noeviction,不删除,只返回错误</li>
</ul>
<p><strong>redis模式采用的是volatile-lru规则</strong><br>该配置配合maxmemory来使用,当maxmemory非0时(x32会自动设置为3GB,要注意),<br>会按照这条规则处理超出内存的数据</p>
<h4 id="例子-39"><a href="#例子-39" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">maxmemory-policy volatile-lru</span><br></pre></td></tr></table></figure>

<h3 id="maxmemory-samples"><a href="#maxmemory-samples" class="headerlink" title="maxmemory-samples"></a>maxmemory-samples</h3><h4 id="说明-40"><a href="#说明-40" class="headerlink" title="说明"></a>说明</h4><p>LRU算法和TTL算法都不是精确算法<br>而是估算算法(可以提高效率)<br>这个参数是算法的样本个数<br>取这个个数的值的样本进行比较得出的键就是算法的结果<br>提高这个值会降低效率,但是会提高算法精度</p>
<h4 id="例子-40"><a href="#例子-40" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">maxmemory-samples 3</span><br></pre></td></tr></table></figure>

<h2 id="APPEND-ONLY-MODE"><a href="#APPEND-ONLY-MODE" class="headerlink" title="APPEND ONLY MODE"></a>APPEND ONLY MODE</h2><h3 id="appendonly"><a href="#appendonly" class="headerlink" title="appendonly"></a>appendonly</h3><h4 id="说明-41"><a href="#说明-41" class="headerlink" title="说明"></a>说明</h4><p>是否开启AOF功能<br>AOF是相对于RDB的另外一种REDIS自带的数据持久化功能<br>RDB在发生突发情况(断电,REDIS崩溃)后,会丢失自上次保存后的所有数据<br>AOF只会丢失突发情况前1秒钟的内容,是一种持续持久化方式<br>AOF可以和RDB同时开启,当同时开启时,REDIS会使用AOF的存储文件,<br>因为AOF相对更可靠一些.</p>
<h4 id="例子-41"><a href="#例子-41" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appendonly no</span><br></pre></td></tr></table></figure>

<h3 id="appendfilename"><a href="#appendfilename" class="headerlink" title="appendfilename"></a>appendfilename</h3><h4 id="说明-42"><a href="#说明-42" class="headerlink" title="说明"></a>说明</h4><p>AOF保存的文件名</p>
<h4 id="例子-42"><a href="#例子-42" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br></pre></td></tr></table></figure>

<h3 id="appendfsync"><a href="#appendfsync" class="headerlink" title="appendfsync"></a>appendfsync</h3><h4 id="说明-43"><a href="#说明-43" class="headerlink" title="说明"></a>说明</h4><p>文件写入磁盘实际是有延迟的,<br>这个参数的作用是何时通知系统将日志写入磁盘</p>
<ul>
<li>no,不通知,按操作系统内部逻辑写磁盘</li>
<li>everysec,每秒通知系统写磁盘</li>
<li>always,每次变更都通知系统写磁盘</li>
</ul>
<h4 id="例子-43"><a href="#例子-43" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure>

<h3 id="no-appendfsync-on-rewrite"><a href="#no-appendfsync-on-rewrite" class="headerlink" title="no-appendfsync-on-rewrite"></a>no-appendfsync-on-rewrite</h3><h4 id="说明-44"><a href="#说明-44" class="headerlink" title="说明"></a>说明</h4><p>当有子进程正在写AOF或者RDB文件时,<br>同时还要追加写AOF日志会使Redis在fsync()阻塞<br>比较长的时间,解决方法是当有子进程<br>在写文件时,日志追加写文件为等同于不通知调用fsync()接口,<br>这样就不会阻塞很长时间了.<br>但是有可能在发生灾难情况后丢失比较长时间的日志.<br>默认为关闭,当性能有问题时,可以打开.</p>
<h4 id="例子-44"><a href="#例子-44" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">no-appendfsync-on-rewrite no</span><br></pre></td></tr></table></figure>

<h3 id="auto-aof-rewrite-percentage-amp-auto-aof-rewrite-min-size"><a href="#auto-aof-rewrite-percentage-amp-auto-aof-rewrite-min-size" class="headerlink" title="auto-aof-rewrite-percentage &amp; auto-aof-rewrite-min-size"></a>auto-aof-rewrite-percentage &amp; auto-aof-rewrite-min-size</h3><h4 id="说明-45"><a href="#说明-45" class="headerlink" title="说明"></a>说明</h4><p>AOF有自动重写功能<br>当AOF文件尺寸超过基础尺寸的该设置的百分比时<br>会对AOF文件进行重写合并处理<br>最小尺寸表示最小进行合并的值,<br>当AOF文件不到这个尺寸是,即时满足百分比条件<br>也不会进行重写(太小了,重写没有意义)<br>当AOF重写百分比设置为0是,是关闭该功能,<br>关闭后将不会自动重写AOF文件<br>基础尺寸是本次启动时的尺寸,和最后一次重写后的尺寸</p>
<h4 id="例子-45"><a href="#例子-45" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>

<h3 id="aof-load-truncated"><a href="#aof-load-truncated" class="headerlink" title="aof-load-truncated"></a>aof-load-truncated</h3><h4 id="说明-46"><a href="#说明-46" class="headerlink" title="说明"></a>说明</h4><p>当AOF文件因为系统原因导致不完整时<br>(宕机,断电等原因)是否读取不完整的<br>AOF文件.<br>注:当AOF文件从中间断掉了,还是会退出<br>启动,该选项只会在尝试读取指定数量的<br>字节数据失败时生效<br>TODO:PAN 这里不是理解的很清楚,后面需要在查看下</p>
<h4 id="例子-46"><a href="#例子-46" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aof-load-truncated yes</span><br></pre></td></tr></table></figure>

<h2 id="LUA-SCRIPTING"><a href="#LUA-SCRIPTING" class="headerlink" title="LUA SCRIPTING"></a>LUA SCRIPTING</h2><h3 id="lua-time-limit"><a href="#lua-time-limit" class="headerlink" title="lua-time-limit"></a>lua-time-limit</h3><h4 id="说明-47"><a href="#说明-47" class="headerlink" title="说明"></a>说明</h4><p>脚本执行超时的警告时间设置<br>lua脚本执行的毫秒数超出这个值,<br>则会在日志中记录超时警告.<br>这个值设置为0则关闭警告,无限时间等待脚本执行完成.<br>这个时候执行脚本的客户端除了等待<br>脚本执行完毕后,只有两条命令可以执行</p>
<ul>
<li><code>script kill</code>,在脚本没有调用写命令时可以调用,可以停止脚本的执行</li>
<li><code>shutdown nosave</code>,当脚本已经调用了写命令操作后,只能通过关闭redis来终止脚本执行</li>
</ul>
<h4 id="例子-47"><a href="#例子-47" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lua-time-limit 5000</span><br></pre></td></tr></table></figure>

<h2 id="SLOW-LOG"><a href="#SLOW-LOG" class="headerlink" title="SLOW LOG"></a>SLOW LOG</h2><h3 id="slowlog-log-slower-than"><a href="#slowlog-log-slower-than" class="headerlink" title="slowlog-log-slower-than"></a>slowlog-log-slower-than</h3><h4 id="说明-48"><a href="#说明-48" class="headerlink" title="说明"></a>说明</h4><p>慢日志触发的时间<br>单位:微秒<br>1000000微秒=1秒<br>当命令的执行时间(不包含I/O操作)(实际就是命令对应的的<code>proc</code>函数的执行时间)超过这个设置的时间后<br>会被记录到慢日志当中<br>用于查询执行缓慢的命令<br>设置为0则每条命令都记录<br>设置为负数则关闭该功能</p>
<p>时间统计</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">start = ustime();</span><br><span class="line"><span class="comment">//if true 说明是在leveldb下禁止的命令.直接回复error</span></span><br><span class="line"><span class="keyword">if</span> (c-&gt;cmd-&gt;flags &amp; REDIS_CMD_FORBID_LEVELDB) &#123;</span><br><span class="line">	addReplyErrorFormat(c,<span class="string">&quot;command:%s invalid in leveldb&quot;</span>, c-&gt;cmd-&gt;name);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	c-&gt;cmd-&gt;proc(c);</span><br><span class="line">&#125;</span><br><span class="line">duration = ustime()-start;</span><br></pre></td></tr></table></figure>

<h4 id="例子-48"><a href="#例子-48" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slowlog-log-slower-than 10000</span><br></pre></td></tr></table></figure>

<h3 id="slowlog-max-len"><a href="#slowlog-max-len" class="headerlink" title="slowlog-max-len"></a>slowlog-max-len</h3><h4 id="说明-49"><a href="#说明-49" class="headerlink" title="说明"></a>说明</h4><p>慢日志的最大条目数<br>这个没有限制具体的大小限制<br>但是要注意,这个记录会占用内存<br>如有需要,可以使用命令<code>slowlog reset</code><br>来重置慢日志记录</p>
<h4 id="例子-49"><a href="#例子-49" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slowlog-max-len 128</span><br></pre></td></tr></table></figure>

<h2 id="LATENCY-MONITOR"><a href="#LATENCY-MONITOR" class="headerlink" title="LATENCY MONITOR"></a>LATENCY MONITOR</h2><h3 id="latency-monitor-threshold"><a href="#latency-monitor-threshold" class="headerlink" title="latency-monitor-threshold"></a>latency-monitor-threshold</h3><h4 id="说明-50"><a href="#说明-50" class="headerlink" title="说明"></a>说明</h4><p>延迟监控<br>纳入延迟监控的命令的运行时间.<br>redis是单线程的,处理命令只能逐个处理<br>帮助用户检查排除可能导致延迟的问题.<br>单位:毫秒<br>当延迟值&gt;=设置值时,会增加记录<br>使用<code>latency</code>命令可以查看记录的详细信息<br>默认关闭<br>因为会影响性能</p>
<h4 id="例子-50"><a href="#例子-50" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">latency-monitor-threshold 0</span><br></pre></td></tr></table></figure>

<h2 id="Event-notification"><a href="#Event-notification" class="headerlink" title="Event notification"></a>Event notification</h2><h3 id="notify-keyspace-events"><a href="#notify-keyspace-events" class="headerlink" title="notify-keyspace-events"></a>notify-keyspace-events</h3><h4 id="说明-51"><a href="#说明-51" class="headerlink" title="说明"></a>说明</h4><p>pub/sub功能的监听内容设置<br>参数说明:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#  K     Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.</span><br><span class="line">#  E     Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.</span><br><span class="line">#  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...</span><br><span class="line">#  $     String commands</span><br><span class="line">#  l     List commands</span><br><span class="line">#  s     Set commands</span><br><span class="line">#  h     Hash commands</span><br><span class="line">#  z     Sorted set commands</span><br><span class="line">#  x     Expired events (events generated every time a key expires)</span><br><span class="line">#  e     Evicted events (events generated when a key is evicted for maxmemory)</span><br><span class="line">#  A     Alias for g$lshzxe, so that the &quot;AKE&quot; string means all the events.</span><br></pre></td></tr></table></figure>
<p>两种事件类型:K/E,<br>如果要使用该功能,必须至少监听其中一种<br>然后在配合具体的监听对象来启用监听事件<br>开启监听后<br>客户端添加订阅redis的监听,并提供相应的回调处理<br>当监听事件发生后,<br>客户端对应的回调函数会收到redis的调用.<br>默认为””关闭,<br>因为大部分情况下都用不到<br>也会消耗性能</p>
<h4 id="例子-51"><a href="#例子-51" class="headerlink" title="例子"></a>例子</h4><p>监听所有的键过期事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">notify-keyspace-events Ex</span><br></pre></td></tr></table></figure>

<h2 id="ADVANCED-CONFIG"><a href="#ADVANCED-CONFIG" class="headerlink" title="ADVANCED CONFIG"></a>ADVANCED CONFIG</h2><h3 id="hash-max-ziplist-entries-amp-hash-max-ziplist-value"><a href="#hash-max-ziplist-entries-amp-hash-max-ziplist-value" class="headerlink" title="hash-max-ziplist-entries &amp; hash-max-ziplist-value"></a>hash-max-ziplist-entries &amp; hash-max-ziplist-value</h3><h4 id="说明-52"><a href="#说明-52" class="headerlink" title="说明"></a>说明</h4><p>哈希表在元素数&lt;=配置值,<br>并且每个元素的长度&lt;=配置值时,<br>Redis启用特殊编码,对数据进行封装<br>而不是直接使用哈希表.<br>这对内存大小和查询性能都有优化</p>
<h4 id="例子-52"><a href="#例子-52" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br></pre></td></tr></table></figure>

<h3 id="list-max-ziplist-entries-amp-list-max-ziplist-value"><a href="#list-max-ziplist-entries-amp-list-max-ziplist-value" class="headerlink" title="list-max-ziplist-entries &amp; list-max-ziplist-value"></a>list-max-ziplist-entries &amp; list-max-ziplist-value</h3><h4 id="例子-53"><a href="#例子-53" class="headerlink" title="例子"></a>例子</h4><p>列表元素数&lt;=配置值,<br>并且列表元素长度&lt;=配置值,<br>会使用压缩数据优化.</p>
<h4 id="例子-54"><a href="#例子-54" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list-max-ziplist-entries 512</span><br><span class="line">list-max-ziplist-value 64</span><br></pre></td></tr></table></figure>

<h3 id="set-max-intset-entries"><a href="#set-max-intset-entries" class="headerlink" title="set-max-intset-entries"></a>set-max-intset-entries</h3><h4 id="说明-53"><a href="#说明-53" class="headerlink" title="说明"></a>说明</h4><p>由<code>int64_t</code>组成的set在<br>元素个数&lt;=配置值时,<br>会使用压缩数据优化.</p>
<h4 id="例子-55"><a href="#例子-55" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set-max-intset-entries 512</span><br></pre></td></tr></table></figure>

<h3 id="zset-max-ziplist-entries-amp-zset-max-ziplist-value"><a href="#zset-max-ziplist-entries-amp-zset-max-ziplist-value" class="headerlink" title="zset-max-ziplist-entries &amp; zset-max-ziplist-value"></a>zset-max-ziplist-entries &amp; zset-max-ziplist-value</h3><h4 id="说明-54"><a href="#说明-54" class="headerlink" title="说明"></a>说明</h4><p>当有序set的元素个数&lt;=配置值,<br>并且元素的长度都&lt;=配置值,<br>会使用压缩数据优化.</p>
<h4 id="例子-56"><a href="#例子-56" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br></pre></td></tr></table></figure>

<h3 id="hll-sparse-max-bytes"><a href="#hll-sparse-max-bytes" class="headerlink" title="hll-sparse-max-bytes"></a>hll-sparse-max-bytes</h3><h4 id="说明-55"><a href="#说明-55" class="headerlink" title="说明"></a>说明</h4><p>MARK:hll的功能其实完全不知道<br>稀疏结构的最大字节数<br>默认值3000<br>当不关心cpu而在意内存占用的话<br>可以设置为10000<br>可用值范围一般为0-15000<br>当设置为16000时还不如使用密集结构</p>
<h4 id="例子-57"><a href="#例子-57" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hll-sparse-max-bytes 3000</span><br></pre></td></tr></table></figure>

<h3 id="activerehashing"><a href="#activerehashing" class="headerlink" title="activerehashing"></a>activerehashing</h3><h4 id="说明-56"><a href="#说明-56" class="headerlink" title="说明"></a>说明</h4><p>这是对redis最上层的哈希表的rehash的处理方式<br>是否主动rehash<br>主动rehash会节省内存,但是会占用cpu(1/100)的时间<br>默认的dict是被动rehash,当dict被操作时,才会进行<br>rehash,不会占用额外cpu时间,但是当没有访问表时,<br>会导致rehash停止,从而会占用更多的内存<br>默认是开启主动rehash,节省内存</p>
<h4 id="例子-58"><a href="#例子-58" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">activerehashing yes</span><br></pre></td></tr></table></figure>

<h3 id="client-output-buffer-limit"><a href="#client-output-buffer-limit" class="headerlink" title="client-output-buffer-limit"></a>client-output-buffer-limit</h3><h4 id="说明-57"><a href="#说明-57" class="headerlink" title="说明"></a>说明</h4><p>当客户端读取数据速度比不上服务器推送的速度时<br>服务端的推送数据缓冲会积压<br>当积压大于这个配置值时,<br>服务端会主动断开与客户端的连接<br>(一般的客户端不会有这个问题,<br>因为是请求-返回的模式,<br>异步客户端可能会出现这种问题)</p>
<p>客户端的类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># normal -&gt; normal clients including MONITOR clients</span><br><span class="line"># slave  -&gt; slave clients</span><br><span class="line"># pubsub -&gt; clients subscribed to at least one pubsub channel or pattern</span><br></pre></td></tr></table></figure>

<p>操作语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span><br></pre></td></tr></table></figure>

<p>值设置为0则表示不限制</p>
<h4 id="例子-59"><a href="#例子-59" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line">client-output-buffer-limit slave 256mb 64mb 60</span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br></pre></td></tr></table></figure>

<h3 id="hz"><a href="#hz" class="headerlink" title="hz"></a>hz</h3><h4 id="说明-58"><a href="#说明-58" class="headerlink" title="说明"></a>说明</h4><p>就是决定函数<code>serverCron</code>函数内部分功能的调用频率的<br>默认为10次/秒<br>取值范围为1-500<br>正常使用10即可,<br>对过期键等判断要求严格的可以上调至100<br>但会在空闲时占用更多的cpu.</p>
<h4 id="例子-60"><a href="#例子-60" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hz 10</span><br></pre></td></tr></table></figure>

<h3 id="aof-rewrite-incremental-fsync"><a href="#aof-rewrite-incremental-fsync" class="headerlink" title="aof-rewrite-incremental-fsync"></a>aof-rewrite-incremental-fsync</h3><h4 id="说明-59"><a href="#说明-59" class="headerlink" title="说明"></a>说明</h4><p>当重写AOF文件时,开启该功能会按照每<br>32MB数据写一次磁盘.<br>就是开启增量写文件的功能.<br>可以防止一次性写很大的数据使延迟很大</p>
<h4 id="例子-61"><a href="#例子-61" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure>

<h2 id="LEVELDB"><a href="#LEVELDB" class="headerlink" title="LEVELDB"></a>LEVELDB</h2><h3 id="leveldb"><a href="#leveldb" class="headerlink" title="leveldb"></a>leveldb</h3><h4 id="说明-60"><a href="#说明-60" class="headerlink" title="说明"></a>说明</h4><p>是否使用leveldb持久化数据</p>
<h4 id="例子-62"><a href="#例子-62" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">leveldb yes</span><br></pre></td></tr></table></figure>

<h3 id="leveldb-path"><a href="#leveldb-path" class="headerlink" title="leveldb-path"></a>leveldb-path</h3><h4 id="说明-61"><a href="#说明-61" class="headerlink" title="说明"></a>说明</h4><p>leveldb数据的存放目录<br>这个目录是在上面的<code>dir</code>配置的基础上拼装出来的,<br>并不是从根目录开始计算</p>
<h4 id="例子-63"><a href="#例子-63" class="headerlink" title="例子"></a>例子</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">leveldb-path .&#x2F;var</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>redisLV</tag>
        <tag>configuration</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift引导学习笔记</title>
    <url>/2018/09/05/swift-tutorial/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Swift的学习笔记<br>以下代码可以直接在playground中运行<br>学习版本:swift 4.2</p>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>关键点</p>
<ul>
<li>不需要引用其他库</li>
<li>行尾没有<code>;</code></li>
<li>没有<code>main</code>函数,编译器会已在全局范围内的代码作为程序入口点<a id="more"></a>

</li>
</ul>
<h2 id="Simple-Values"><a href="#Simple-Values" class="headerlink" title="Simple Values"></a>Simple Values</h2><ul>
<li><code>let</code>,常量声明</li>
<li><code>var</code>,变量声明,<strong>常量可以先声明,随后在使用前初始化一次</strong></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>swift是强类型的,一旦变量类型被确定,就不能改变</strong></li>
<li>不需要手动声明类型,通过初次赋值,编译器可以推断出变量/常量的类型</li>
<li>当定义不足以提供所需的数据类型时,可以使用显示的类型定义<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> implicitInteger = <span class="number">70</span></span><br><span class="line"><span class="keyword">let</span> implicitDouble = <span class="number">70.0</span></span><br><span class="line"><span class="keyword">let</span> explicitDouble: <span class="type">Double</span> = <span class="number">70</span></span><br></pre></td></tr></table></figure></li>
<li>不支持隐式转换,所有不同类型的赋值都需要显示的转换<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> label = <span class="string">&quot;The width is &quot;</span></span><br><span class="line"><span class="keyword">let</span> width = <span class="number">94</span></span><br><span class="line"><span class="keyword">let</span> widthLabel = label + <span class="type">String</span>(width)</span><br><span class="line"><span class="built_in">print</span>(widthLabel)</span><br></pre></td></tr></table></figure></li>
<li>可以使用<code>\(内容)</code>的方式在字符串中插入其他变量的内容<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> apples = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> oranges = <span class="number">5</span></span><br><span class="line"><span class="keyword">let</span> appleSummary = <span class="string">&quot;I have \(apples) apples.&quot;</span></span><br><span class="line"><span class="keyword">let</span> fruitSummary = <span class="string">&quot;I have \(apples + oranges) pieces of fruits.&quot;</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">&quot;test&quot;</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="string">&quot;This is a \(a).&quot;</span></span><br><span class="line"><span class="built_in">print</span>(appleSummary)</span><br><span class="line"><span class="built_in">print</span>(fruitSummary)</span><br><span class="line"><span class="built_in">print</span>(b, b)</span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = <span class="number">2.5</span></span><br><span class="line"><span class="keyword">let</span> d = <span class="number">1.23333</span></span><br><span class="line"><span class="keyword">let</span> e = <span class="string">&quot;This is a \(c + d + 3.1 + 10).&quot;</span></span><br><span class="line"><span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure></li>
<li>使用三个双引号包围可以创建多行字符串,同时可以使用特殊字符而不需要转义(替换变量/常量功能依然有效)<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> quotation = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">I said &quot;I have \(apples) apples.&quot;</span></span><br><span class="line"><span class="string">And then I said &quot;I have \(apples + oranges) pieces of fruit.&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>使用中括号<code>[]</code>来定义/声明数组和字典,使用索引或key来访问/修改元素,最后一个元素结尾可以有<code>,</code><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shoppingList = [<span class="string">&quot;catfish&quot;</span>, <span class="string">&quot;water&quot;</span>, <span class="string">&quot;tulips&quot;</span>, <span class="string">&quot;blue paint&quot;</span>]</span><br><span class="line">shoppingList[<span class="number">1</span>] = <span class="string">&quot;bottle of water&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> occupations = [</span><br><span class="line">	<span class="string">&quot;Malcolm&quot;</span>: <span class="string">&quot;Captain&quot;</span>,</span><br><span class="line">	<span class="string">&quot;Kaylee&quot;</span>: <span class="string">&quot;Mechanic&quot;</span>,</span><br><span class="line">]</span><br><span class="line">occupations[<span class="string">&quot;Jayne&quot;</span>] = <span class="string">&quot;Public Relations&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>创建空数组或字典,需要使用初始化语法<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> emptyArray = [<span class="type">String</span>]()</span><br><span class="line"><span class="keyword">let</span> emptyDictionary = [<span class="type">String</span>: <span class="type">Float</span>]()</span><br></pre></td></tr></table></figure></li>
<li>如果数组或字典的类型可以被编译器推断出来则可以直接使用<code>[]</code>,<code>[:]</code>来初始化数组和字典.(不知道怎么使用,据说是传参数或者设置变量时可以这样用)<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">shoppingList = []</span><br><span class="line">occupations = [:]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Control-Flow"><a href="#Control-Flow" class="headerlink" title="Control Flow"></a>Control Flow</h2><p>简介</p>
<ul>
<li><code>if</code>/<code>switch</code>,条件控制</li>
<li><code>for-in</code>/<code>while</code>/<code>repeat-while</code>,循环</li>
<li>条件的<code>()</code>/<code>循环变量</code>可以省略</li>
<li>执行代码的<code>&#123;&#125;</code>不能省略</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> individualScores = [<span class="number">75</span>, <span class="number">43</span>, <span class="number">103</span>, <span class="number">87</span>, <span class="number">12</span>]</span><br><span class="line"><span class="keyword">var</span> teamScore = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> score <span class="keyword">in</span> individualScores &#123;</span><br><span class="line">	<span class="keyword">if</span> score &gt; <span class="number">50</span> &#123;</span><br><span class="line">		teamScore += <span class="number">3</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		teamScore += <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(teamScore)</span><br></pre></td></tr></table></figure>

<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>判断条件并执行代码</p>
<ul>
<li>条件必须是bool类型</li>
<li>不会隐式和0做比较</li>
<li>在类型之后使用<code>?</code>来表示该变量为可选变量(可以有值或为<code>nil</code>)</li>
<li>可以使用<code>if</code>+<code>let</code>判断可选参数是否为空<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a:<span class="type">Bool?</span> = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> a = b &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="number">1</span>, a) <span class="comment">// 会进入这个条件</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> optionalString: <span class="type">String?</span> = <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(optionalString == <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> optionalName: <span class="type">String?</span> = <span class="string">&quot;John Appleseed&quot;</span></span><br><span class="line"><span class="keyword">var</span> greeting = <span class="string">&quot;Hello!&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> name = optionalName &#123;</span><br><span class="line">    greeting = <span class="string">&quot;Hello, \(name)&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>可以使用<code>??</code>来为可选变量设置默认值<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nickName: <span class="type">String?</span> = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">let</span> fullName: <span class="type">String</span> = <span class="string">&quot;John Appleseed&quot;</span></span><br><span class="line"><span class="keyword">let</span> informalGreeting = <span class="string">&quot;Hi \(nickName ?? fullName)&quot;</span></span><br><span class="line"><span class="built_in">print</span>(informalGreeting) </span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><ul>
<li>支持比较判断</li>
<li>case支持赋值函数判断</li>
<li>case内不需要break</li>
<li>case支持使用<code>,</code>来表示或操作</li>
<li>必须有default语句(所有的case包含了所有情况的话,则不需要default)</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vegetable = <span class="string">&quot;red pepper&quot;</span></span><br><span class="line"><span class="keyword">switch</span> vegetable &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;celery&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Add some raisins and make ants on a log.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;cucumber&quot;</span>, <span class="string">&quot;watercress&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;That would make a good tea sandwich.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> x <span class="keyword">where</span> x.hasSuffix(<span class="string">&quot;pepper&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Is it a spicy \(x)?&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Everything tastes good in soup.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> interestingNumbers = [</span><br><span class="line">    <span class="string">&quot;Prime&quot;</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>],</span><br><span class="line">    <span class="string">&quot;Fibonacci&quot;</span>: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>],</span><br><span class="line">    <span class="string">&quot;Square&quot;</span>: [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>],</span><br><span class="line">]</span><br><span class="line"><span class="keyword">var</span> largest = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> largestKind = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> (kind, numbers) <span class="keyword">in</span> interestingNumbers &#123;</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        <span class="keyword">if</span> number &gt; largest &#123;</span><br><span class="line">            largest = number</span><br><span class="line">            largestKind = kind</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(largest, largestKind)</span><br></pre></td></tr></table></figure>

<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><ul>
<li><code>..&lt;</code>,遍历不包含上限</li>
<li><code>...</code>,遍历包含上限</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> total = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">4</span> &#123;</span><br><span class="line">    total += i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(total)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>...<span class="number">4</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> n &lt; <span class="number">100</span> &#123;</span><br><span class="line">	n *= <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">2</span></span><br><span class="line"><span class="keyword">repeat</span> &#123;</span><br><span class="line">	m *= <span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">while</span> m &lt; <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(m)</span><br></pre></td></tr></table></figure>

<h2 id="Functions-and-Closures"><a href="#Functions-and-Closures" class="headerlink" title="Functions and Closures"></a>Functions and Closures</h2><h3 id="func"><a href="#func" class="headerlink" title="func"></a>func</h3><p>函数调用的参数有一个标签的概念,<br>调用函数需要指定参数的标签进行调用.<br>默认情况下,是使用参数名来作为标签.<br>可以使用<code>_</code>来表示不使用标签,<br>可以在参数名前增加标签的名字(用空格分隔)<br>当添加标签后,原始的参数名将不能作为函数参数标签使用<br>(标签并不能改变参数的调用顺序,还是需要从前向后一次传参)</p>
<h4 id="默认标签的使用"><a href="#默认标签的使用" class="headerlink" title="默认标签的使用"></a>默认标签的使用</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(person: String, day: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello \(person), today is \(day).&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> res = greet(person: <span class="string">&quot;Bob&quot;</span>, day: <span class="string">&quot;Tuesday&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>

<h4 id="标签的常规调用"><a href="#标签的常规调用" class="headerlink" title="标签的常规调用"></a>标签的常规调用</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(<span class="number">_</span> person: String, on day: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello \(person), today is \(day).&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">greet(<span class="string">&quot;John&quot;</span>, on: <span class="string">&quot;Wednesday&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="函数的多返回"><a href="#函数的多返回" class="headerlink" title="函数的多返回"></a>函数的多返回</h4><ul>
<li>返回值使用tuple的方式返回</li>
<li>获取返回值的内容既可以使用返回的参数名,又可以使用索引</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func calculateStatistics(scores: [Int]) -&gt; (min: Int, max: Int, sum: Int) &#123;</span><br><span class="line">    var min &#x3D; scores[0]</span><br><span class="line">    var max &#x3D; scores[0]</span><br><span class="line">    var sum &#x3D; 0</span><br><span class="line"></span><br><span class="line">    for score in scores &#123;</span><br><span class="line">        if score &gt; max &#123;</span><br><span class="line">            max &#x3D; score</span><br><span class="line">        &#125; else if score &lt; min &#123;</span><br><span class="line">            min &#x3D; score</span><br><span class="line">        &#125;</span><br><span class="line">        sum +&#x3D; score</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (min, max, sum)</span><br><span class="line">&#125;</span><br><span class="line">let statistics &#x3D; calculateStatistics(scores: [5, 3, 100, 3, 9])</span><br><span class="line">print(statistics.sum)</span><br><span class="line">print(statistics.2)</span><br></pre></td></tr></table></figure>

<h4 id="局部函数"><a href="#局部函数" class="headerlink" title="局部函数"></a>局部函数</h4><p>局部函数可以使用外部的变量<br>可以用于实现一些复杂的问题</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnFifteen</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</span><br><span class="line">        y += <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">    add()</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line">returnFifteen()</span><br></pre></td></tr></table></figure>

<h4 id="函数可以作为参数-返回值"><a href="#函数可以作为参数-返回值" class="headerlink" title="函数可以作为参数,返回值"></a>函数可以作为参数,返回值</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> -&gt; ((<span class="type">Int</span>) -&gt; <span class="type">Int</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> b = <span class="number">10</span></span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="title">c</span><span class="params">(d : Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">		b += d</span><br><span class="line">		<span class="keyword">return</span> b</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = a()</span><br><span class="line"><span class="built_in">print</span>(b(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(b(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(b(<span class="number">5</span>))</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">c</span> = a()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">c</span>(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasAnyMatches</span><span class="params">(list: [Int], condition: <span class="params">(Int)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> condition(item) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lessThanTen</span><span class="params">(number: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> number &lt; <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">20</span>, <span class="number">19</span>, <span class="number">7</span>, <span class="number">12</span>]</span><br><span class="line">hasAnyMatches(list: numbers, condition: lessThanTen)</span><br></pre></td></tr></table></figure>

<h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func a(i : Int, f : (Int) -&gt; Int) &#123;</span><br><span class="line">    print(f(i))</span><br><span class="line">&#125;</span><br><span class="line">a(i:10, f:&#123;(num : Int) -&gt; Int in</span><br><span class="line">    let r &#x3D; num * 3</span><br><span class="line">    return r</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="匿名函数的参数和返回值可以推断省略"><a href="#匿名函数的参数和返回值可以推断省略" class="headerlink" title="匿名函数的参数和返回值可以推断省略"></a>匿名函数的参数和返回值可以推断省略</h4><p>单行函数,会直接返回这行代码执行的结果</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> b = a.<span class="built_in">map</span>(&#123; num <span class="keyword">in</span> num * <span class="number">3</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>

<h4 id="匿名函数中可以使用从0开始的序号来代替参数名"><a href="#匿名函数中可以使用从0开始的序号来代替参数名" class="headerlink" title="匿名函数中可以使用从0开始的序号来代替参数名"></a>匿名函数中可以使用从0开始的序号来代替参数名</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">var</span> b = a.sorted(by:&#123;$<span class="number">0</span> &lt; $<span class="number">1</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>

<h2 id="Objects-and-Classes"><a href="#Objects-and-Classes" class="headerlink" title="Objects and Classes"></a>Objects and Classes</h2><ul>
<li>类的声明<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfSides = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A shape with \(numberOfSides) sides.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>类的使用<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shape = <span class="type">Shape</span>()</span><br><span class="line">shape.numberOfSides = <span class="number">7</span></span><br><span class="line"><span class="keyword">var</span> shapeDescription = shape.simpleDescription()</span><br><span class="line"><span class="built_in">print</span>(shapeDescription)</span><br></pre></td></tr></table></figure></li>
<li>构造函数(init),类属性都必需要初始化,要么在声明中初始化,要么在构造函数中初始化<ul>
<li>同名属性和参数使用<code>self</code>区分</li>
<li>不能使用<code>func</code>做关键字<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamedShape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numberOfSides: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;A shape with \(numberOfSides) sides.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>析构函数(deinit),在类生命终止时,需要做的操作</li>
<li>子类<ul>
<li>不强制继承某个类</li>
<li>调用基类函数使用<code>super</code>关键字</li>
<li>覆盖基类函数强制使用<code>override</code>关键字</li>
</ul>
</li>
<li>属性的setter/getter<ul>
<li><code>set</code>默认使用<code>newValue</code>作为参数名(可以手动设置该参数名)</li>
<li>有<code>get</code>/<code>set</code>的属性必然是计算属性(不是值属性)<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> b : <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a * <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            a = newValue / <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="type">Shape</span>()</span><br><span class="line"><span class="built_in">print</span>(a.a)</span><br><span class="line"><span class="built_in">print</span>(a.b)</span><br><span class="line">a.b = <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(a.a)</span><br><span class="line"><span class="built_in">print</span>(a.b)</span><br></pre></td></tr></table></figure></li>
<li><code>willSet</code>/<code>didSet</code>方法,就是在设置值属性前/后调用的方法,必然是值属性(不是计算属性)<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> b : <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;will set&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;did set&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        b = <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="type">Shape</span>()</span><br><span class="line"><span class="built_in">print</span>(a.a)</span><br><span class="line"><span class="built_in">print</span>(a.b)</span><br><span class="line">a.b = <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(a.a)</span><br><span class="line"><span class="built_in">print</span>(a.b)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>可选值的相关使用,如果前面的指针是nil,则后面的内容都不会执行,表达式返回nil<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var a: A? = A()</span></span><br><span class="line"><span class="keyword">var</span> a: <span class="type">A?</span> = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">var</span> b = a?.a</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Enumerations-and-Structures"><a href="#Enumerations-and-Structures" class="headerlink" title="Enumerations and Structures"></a>Enumerations and Structures</h2><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><ul>
<li>默认从0开始</li>
<li>递增1</li>
<li>可以有函数</li>
<li>类型可以有字符串,浮点数等</li>
<li>使用<code>rawValue</code>来访问具体对应的数值<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Rank</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> b, <span class="built_in">c</span>, d, e</span><br><span class="line">    <span class="keyword">case</span> f, g, h</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> .a:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;:a&quot;</span></span><br><span class="line">            <span class="keyword">case</span> .b:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;:b&quot;</span></span><br><span class="line">            <span class="keyword">case</span> .f:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;:f&quot;</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="type">String</span>(<span class="keyword">self</span>.rawValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="type">Rank</span>.a</span><br><span class="line"><span class="keyword">var</span> aRawValue = a.rawValue</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(aRawValue)</span><br><span class="line"><span class="built_in">print</span>(a.simpleDescription())</span><br></pre></td></tr></table></figure></li>
<li>在枚举外部,调用枚举时需要使用<code>类型.枚举</code></li>
<li>当使用<code>switch</code>限定了参数的类型时,调用枚举时,只需要使用<code>.枚举</code>即可<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Suit</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> spades, hearts, diamonds, clubs</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .spades:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;spades&quot;</span></span><br><span class="line">        <span class="keyword">case</span> .hearts:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;hearts&quot;</span></span><br><span class="line">        <span class="keyword">case</span> .diamonds:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;diamonds&quot;</span></span><br><span class="line">        <span class="keyword">case</span> .clubs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;clubs&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">color</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> .spades, .clubs:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;black&quot;</span></span><br><span class="line">            <span class="keyword">case</span> .hearts, .diamonds:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;red&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> hearts = <span class="type">Suit</span>.hearts</span><br><span class="line"><span class="keyword">let</span> heartsDescription = hearts.simpleDescription()</span><br><span class="line"><span class="built_in">print</span>(hearts.color())</span><br></pre></td></tr></table></figure></li>
<li>相同枚举的实例的值一般是相同的</li>
<li><strong>奇怪的代码</strong>,主要是不知道这样写的意义是什么<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ServerResponse</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> result(<span class="type">String</span>, <span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> failure(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> success = <span class="type">ServerResponse</span>.result(<span class="string">&quot;6:00 am&quot;</span>, <span class="string">&quot;8:09 pm&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> failure = <span class="type">ServerResponse</span>.failure(<span class="string">&quot;Out of cheese.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> success &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .result(sunrise, sunset):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Sunrise is at \(sunrise) and sunset is at \(sunset).&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .failure(message):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Failure...  \(message)&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><ul>
<li>结构体和类基本功能一样</li>
<li>区别<ul>
<li>传参的时候,结构体是值传递(完全拷贝),类是引用传递<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Card</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> rank: <span class="type">Rank</span></span><br><span class="line">    <span class="keyword">var</span> suit: <span class="type">Suit</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">simpleDescription</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;The \(rank.simpleDescription()) of \(suit.simpleDescription())&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> threeOfSpades = <span class="type">Card</span>(rank: .three, suit: .spades)</span><br><span class="line"><span class="keyword">let</span> threeOfSpadesDescription = threeOfSpades.simpleDescription()</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="Protocols-and-Extensions"><a href="#Protocols-and-Extensions" class="headerlink" title="Protocols and Extensions"></a>Protocols and Extensions</h2><h3 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h3><ul>
<li><strong><code>protocol</code>就是<code>interface</code>.</strong></li>
<li><strong>swift是单继承,多实现的方式</strong>,只能继承一个类,但是可以同时实现多个接口(protocol),使用<code>,</code>分隔</li>
<li>使用<code>protocol</code>关键字声明协议<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ExampleProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>类,枚举和结构体都可以继承protocol<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span>: <span class="title">ExampleProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> = <span class="string">&quot;A very simple class.&quot;</span></span><br><span class="line">    <span class="keyword">var</span> anotherProperty: <span class="type">Int</span> = <span class="number">69105</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span> &#123;</span><br><span class="line">        simpleDescription += <span class="string">&quot;  Now 100% adjusted.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="type">SimpleClass</span>()</span><br><span class="line">a.adjust()</span><br><span class="line"><span class="keyword">let</span> aDescription = a.simpleDescription</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SimpleStructure</span>: <span class="title">ExampleProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> = <span class="string">&quot;A simple structure&quot;</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span> &#123;</span><br><span class="line">        simpleDescription += <span class="string">&quot; (adjusted)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="type">SimpleStructure</span>()</span><br><span class="line">b.adjust()</span><br><span class="line"><span class="keyword">let</span> bDescription = b.simpleDescription</span><br></pre></td></tr></table></figure></li>
<li><code>mutating</code>关键字用于表示该函数会修改成员属性<ul>
<li><code>class</code>内部不需要使用该关键字,因为类函数都是修改类内容的</li>
</ul>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">AProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a : <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BClass</span> : <span class="title">AProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a : <span class="type">String</span> = <span class="string">&quot;class var a&quot;</span></span><br><span class="line">    <span class="keyword">var</span> b : <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">        a += <span class="string">&quot;;(class)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CStruct</span> : <span class="title">AProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a : <span class="type">String</span> = <span class="string">&quot;struct var a&quot;</span></span><br><span class="line">    <span class="keyword">var</span> b : <span class="type">Int</span> = <span class="number">20</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">        a += <span class="string">&quot;;(struct)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="type">BClass</span>()</span><br><span class="line">a.f()</span><br><span class="line"><span class="built_in">print</span>(a.a)</span><br><span class="line"><span class="keyword">var</span> b = <span class="type">CStruct</span>()</span><br><span class="line">b.f()</span><br><span class="line"><span class="built_in">print</span>(b.a)</span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> : <span class="type">AProtocol</span> = a</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">c</span>.a)</span><br><span class="line"><span class="comment">// print(c.b) // 报错,AProtocol中没有b属性,即时实际指向的对象是BClass</span></span><br></pre></td></tr></table></figure>

<h3 id="extension"><a href="#extension" class="headerlink" title="extension"></a>extension</h3><ul>
<li>可以为已有类型追加函数<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span>: <span class="title">ExampleProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;The number \(self)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span> += <span class="number">42</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">7</span>.simpleDescription)</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ExampleProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span>: <span class="title">ExampleProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> simpleDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;The number \(self)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">adjust</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span> += <span class="number">42</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">7</span>.simpleDescription)</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line">a.adjust()</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a.simpleDescription)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Error-Handling"><a href="#Error-Handling" class="headerlink" title="Error Handling"></a>Error Handling</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>错误是枚举类型</li>
<li>需要实现<code>Error</code>接口</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PrinterError</span>: <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> outOfPaper</span><br><span class="line">    <span class="keyword">case</span> noToner</span><br><span class="line">    <span class="keyword">case</span> onFire</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><ul>
<li>在可能抛出一样的函数声明时需要在参数列表后面加<code>throws</code>标记,标识函数可能抛出异常</li>
<li>使用<code>throw</code>和对应的异常枚举来抛出异常</li>
<li>函数在抛出异常后会立刻返回,终止执行,不会有返回值</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(job: Int, toPrinter printerName: String)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> printerName == <span class="string">&quot;Never Has Toner&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">PrinterError</span>.noToner</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Job sent&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><ul>
<li>使用<code>do...catch</code>来捕获异常</li>
<li><code>catch</code>中的异常默认名为<code>error</code>,可以手动设置来修改该名称</li>
<li>调用可能会抛出异常的函数时需要在函数名前使用<code>try</code></li>
<li>假如没有发生异常,则<code>catch</code>代码段不会执行</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> printerResponse = <span class="keyword">try</span> send(job: <span class="number">1040</span>, toPrinter: <span class="string">&quot;Bi Sheng&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(printerResponse)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用多个<code>catch</code>,分别捕获不同的异常</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> printerResponse = <span class="keyword">try</span> send(job: <span class="number">1440</span>, toPrinter: <span class="string">&quot;Gutenberg&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(printerResponse)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">PrinterError</span>.onFire &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I&#x27;ll just put this over here, with the rest of the fire.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="keyword">let</span> printerError <span class="keyword">as</span> <span class="type">PrinterError</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Printer error: \(printerError).&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用<code>try?</code>来忽略异常,发生异常后,返回nil,无异常则正常返回</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> printerSuccess = <span class="keyword">try</span>? send(job: <span class="number">1884</span>, toPrinter: <span class="string">&quot;Mergenthaler&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> printerFailure = <span class="keyword">try</span>? send(job: <span class="number">1885</span>, toPrinter: <span class="string">&quot;Never Has Toner&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PrinterError</span>: <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> outOfPaper</span><br><span class="line">    <span class="keyword">case</span> noToner</span><br><span class="line">    <span class="keyword">case</span> onFire</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(job: Int, toPrinter printerName: String)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> printerName == <span class="string">&quot;Never Has Toner&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">PrinterError</span>.noToner</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Job sent&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> printerResponse = <span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    printerResponse = <span class="keyword">try</span> send(job: <span class="number">1040</span>, toPrinter: <span class="string">&quot;Never Has Toner&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(printerResponse)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(printerResponse, error) <span class="comment">// 123	noToner</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><ul>
<li>在代码块内所有代码执行后,最后执行的代码</li>
<li>不会因为有异常而不执行</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fridgeIsOpen = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> fridgeContent = [<span class="string">&quot;milk&quot;</span>, <span class="string">&quot;eggs&quot;</span>, <span class="string">&quot;leftovers&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fridgeContains</span><span class="params">(<span class="number">_</span> food: String)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    fridgeIsOpen = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">        fridgeIsOpen = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = fridgeContent.<span class="built_in">contains</span>(food)</span><br><span class="line">    <span class="built_in">print</span>(fridgeIsOpen)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">fridgeContains(<span class="string">&quot;banana&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(fridgeIsOpen)</span><br></pre></td></tr></table></figure>

<h2 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h2><ul>
<li>就是像c++模版一样的功能</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeArray</span>&lt;Item&gt;<span class="params">(repeating item: Item, numberOfTimes: Int)</span></span> -&gt; [<span class="type">Item</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> result = [<span class="type">Item</span>]()</span><br><span class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;numberOfTimes &#123;</span><br><span class="line">        result.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">makeArray(repeating: <span class="string">&quot;knock&quot;</span>, numberOfTimes: <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>类/枚举也可以使用模版</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Reimplement the Swift standard library&#x27;s optional type</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OptionalValue</span>&lt;<span class="title">Wrapped</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">none</span></span><br><span class="line">    <span class="keyword">case</span> some(<span class="type">Wrapped</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> possibleInteger: <span class="type">OptionalValue</span>&lt;<span class="type">Int</span>&gt; = .<span class="keyword">none</span></span><br><span class="line">possibleInteger = .some(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>where</code>可以限定模版参数的类型</li>
<li>Writing<code>&lt;T: Equatable&gt;</code>is the same as writing<code>&lt;T&gt; ... where T: Equatable</code>.</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anyCommonElements</span>&lt;T: Sequence, U: Sequence&gt;<span class="params">(<span class="number">_</span> lhs: T, <span class="number">_</span> rhs: U)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">where</span> <span class="type">T</span>.<span class="type">Iterator</span>.<span class="type">Element</span>: <span class="type">Equatable</span>, <span class="type">T</span>.<span class="type">Iterator</span>.<span class="type">Element</span> == <span class="type">U</span>.<span class="type">Iterator</span>.<span class="type">Element</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> lhsItem <span class="keyword">in</span> lhs &#123;</span><br><span class="line">            <span class="keyword">for</span> rhsItem <span class="keyword">in</span> rhs &#123;</span><br><span class="line">                <span class="keyword">if</span> lhsItem == rhsItem &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">anyCommonElements([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anyCommonElements</span>&lt;T: Sequence&gt;<span class="params">(<span class="number">_</span> lhs: T, <span class="number">_</span> rhs: T)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">where</span> <span class="type">T</span>.<span class="type">Iterator</span>.<span class="type">Element</span>: <span class="type">Equatable</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> lhsItem <span class="keyword">in</span> lhs &#123;</span><br><span class="line">            <span class="keyword">for</span> rhsItem <span class="keyword">in</span> rhs &#123;</span><br><span class="line">                <span class="keyword">if</span> lhsItem == rhsItem &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;abc&quot;</span>, anyCommonElements([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>]))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>tutorial</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 源码分析-哈希表</title>
    <url>/2018/05/03/redis-source-dict/</url>
    <content><![CDATA[<p>本质是链表<br>dict本身包含一个长度是2的链表数组<br>原因:<br>    - 减少rehashing过程中阻塞操作的时常<br>    - 可以方便的rehash,提高hash表效率</p>
<h2 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h2><ul>
<li>dict.h</li>
<li>dict.c</li>
</ul>
<a id="more"></a>

<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul>
<li>hash函数算法</li>
<li>函数指针</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span> <span class="comment">// 元素的实体类</span></span><br><span class="line">    <span class="keyword">void</span> *key; <span class="comment">// 键</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v; <span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">// 下个元素</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span> <span class="comment">// 字典类型(接口)</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>; <span class="comment">// hash运算函数指针</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key); <span class="comment">// 键复制函数指针</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj); <span class="comment">// 值复制函数指针</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2); <span class="comment">// 键比较函数指针</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key); <span class="comment">// 键删除函数指针</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj); <span class="comment">// 值删除函数指针</span></span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></span><br><span class="line"><span class="comment"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span> <span class="comment">// 包含dict的元素的数据结构(单个实例)</span></span><br><span class="line">    dictEntry **table; <span class="comment">// 元素数组</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size; <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask; <span class="comment">// 取余数计算数组索引用(值:容量-1)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used; <span class="comment">// 使用数量</span></span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span> <span class="comment">// dict数据结构</span></span><br><span class="line">    dictType *type; <span class="comment">// 操作接口类型(提供各种操作函数实现)</span></span><br><span class="line">    <span class="keyword">void</span> *privdata; <span class="comment">// 初始的私有数据(初始化时设置)</span></span><br><span class="line">    dictht ht[<span class="number">2</span>]; <span class="comment">// dict实际数据,0:主数据;1:rehash时操作的缓存数据</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span> <span class="comment">// rehash的数组下标索引(-1:没有在rehashing)</span></span><br><span class="line">    <span class="keyword">int</span> iterators; <span class="comment">/* number of iterators currently running */</span> <span class="comment">// 当前正在使用的安全的迭代器数量(安全的迭代器:可以进行添加删除操作的迭代器)</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If safe is set to 1 this is a safe iterator, that means, you can call</span></span><br><span class="line"><span class="comment"> * dictAdd, dictFind, and other functions against the dictionary even while</span></span><br><span class="line"><span class="comment"> * iterating. Otherwise it is a non safe iterator, and only dictNext()</span></span><br><span class="line"><span class="comment"> * should be called while iterating. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictIterator</span> &#123;</span> <span class="comment">// dict的迭代器</span></span><br><span class="line">    dict *d; <span class="comment">// 迭代的dict</span></span><br><span class="line">    <span class="keyword">long</span> index; <span class="comment">// 当前迭代的数组下标</span></span><br><span class="line">    <span class="keyword">int</span> table, safe; <span class="comment">// ht的索引, 是否是安全迭代器</span></span><br><span class="line">    dictEntry *entry, *nextEntry; <span class="comment">// 当前返回的元素指针,下一个元素指针(因为可能会删除当前元素指针进而找不到下一个元素指针)</span></span><br><span class="line">    <span class="comment">/* unsafe iterator fingerprint for misuse detection. */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fingerprint; <span class="comment">// 非安全迭代器校验用指纹(计算方法:ht[2]的指针+size+used计算的一个64位长度的值)(校验方法:使用前和使用后做指纹比较,一旦不同则是使用过程中有非安全的操作)</span></span><br><span class="line">&#125; dictIterator;</span><br></pre></td></tr></table></figure>

<h2 id="主要宏"><a href="#主要宏" class="headerlink" title="主要宏"></a>主要宏</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This is the initial size of every hash table */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_HT_INITIAL_SIZE     4 <span class="comment">// 所有dict的初始尺寸</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ------------------------------- Macros ------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictFreeVal(d, entry) \ <span class="comment">// 释放值</span></span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;valDestructor) \</span><br><span class="line">        (d)-&gt;type-&gt;valDestructor((d)-&gt;privdata, (entry)-&gt;v.val)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSetVal(d, entry, _val_) do &#123; \ <span class="comment">// 设置值</span></span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;valDup) \</span><br><span class="line">        entry-&gt;v.val = (d)-&gt;type-&gt;valDup((d)-&gt;privdata, _val_); \</span><br><span class="line">    <span class="keyword">else</span> \</span><br><span class="line">        entry-&gt;v.val = (_val_); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSetSignedIntegerVal(entry, _val_) \ <span class="comment">// 设置int64值</span></span></span><br><span class="line">    <span class="keyword">do</span> &#123; entry-&gt;v.s64 = _val_; &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSetUnsignedIntegerVal(entry, _val_) \ <span class="comment">// 设置uint64值</span></span></span><br><span class="line">    <span class="keyword">do</span> &#123; entry-&gt;v.u64 = _val_; &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSetDoubleVal(entry, _val_) \ <span class="comment">// 设置double值</span></span></span><br><span class="line">    <span class="keyword">do</span> &#123; entry-&gt;v.d = _val_; &#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictFreeKey(d, entry) \ <span class="comment">// 释放键</span></span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;keyDestructor) \</span><br><span class="line">        (d)-&gt;type-&gt;keyDestructor((d)-&gt;privdata, (entry)-&gt;key)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSetKey(d, entry, _key_) do &#123; \ <span class="comment">// 设置键</span></span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;keyDup) \</span><br><span class="line">        entry-&gt;key = (d)-&gt;type-&gt;keyDup((d)-&gt;privdata, _key_); \</span><br><span class="line">    <span class="keyword">else</span> \</span><br><span class="line">        entry-&gt;key = (_key_); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictCompareKeys(d, key1, key2) \ <span class="comment">// 比较键</span></span></span><br><span class="line">    (((d)-&gt;type-&gt;keyCompare) ? \</span><br><span class="line">        (d)-&gt;type-&gt;keyCompare((d)-&gt;privdata, key1, key2) : \</span><br><span class="line">        (key1) == (key2))</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictHashKey(d, key) (d)-&gt;type-&gt;hashFunction(key) <span class="comment">// 计算键的hash值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetKey(he) ((he)-&gt;key) <span class="comment">// 获取键</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetVal(he) ((he)-&gt;v.val) <span class="comment">// 获取值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetSignedIntegerVal(he) ((he)-&gt;v.s64) <span class="comment">// 获取int64值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetUnsignedIntegerVal(he) ((he)-&gt;v.u64) <span class="comment">// 获取uint64值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetDoubleVal(he) ((he)-&gt;v.d) <span class="comment">// 获取double值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSlots(d) ((d)-&gt;ht[0].size+(d)-&gt;ht[1].size) <span class="comment">// 获取dict的所有容量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSize(d) ((d)-&gt;ht[0].used+(d)-&gt;ht[1].used) <span class="comment">// 获取dict的所有已使用键值对数量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictIsRehashing(d) ((d)-&gt;rehashidx != -1) <span class="comment">// 是否在rehash过程中</span></span></span><br></pre></td></tr></table></figure>

<h2 id="hash算法"><a href="#hash算法" class="headerlink" title="hash算法"></a>hash算法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Thomas Wang&#x27;s 32 bit Mix Function */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dictIntHashFunction</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    key += ~(key &lt;&lt; <span class="number">15</span>);</span><br><span class="line">    key ^=  (key &gt;&gt; <span class="number">10</span>);</span><br><span class="line">    key +=  (key &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    key ^=  (key &gt;&gt; <span class="number">6</span>);</span><br><span class="line">    key += ~(key &lt;&lt; <span class="number">11</span>);</span><br><span class="line">    key ^=  (key &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* MurmurHash2, by Austin Appleby</span></span><br><span class="line"><span class="comment"> * Note - This code makes a few assumptions about how your machine behaves -</span></span><br><span class="line"><span class="comment"> * 1. We can read a 4-byte value from any address without crashing</span></span><br><span class="line"><span class="comment"> * 2. sizeof(int) == 4</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * And it has a few limitations -</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. It will not work incrementally.</span></span><br><span class="line"><span class="comment"> * 2. It will not produce the same results on little-endian and big-endian</span></span><br><span class="line"><span class="comment"> *    machines.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dictGenHashFunction</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* &#x27;m&#x27; and &#x27;r&#x27; are mixing constants generated offline.</span></span><br><span class="line"><span class="comment">     They&#x27;re not really &#x27;magic&#x27;, they just happen to work well.  */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> seed = dict_hash_function_seed;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> m = <span class="number">0x5bd1e995</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> r = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the hash to a &#x27;random&#x27; value */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> h = seed ^ len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Mix 4 bytes at a time into the hash */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *data = (<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *)key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(len &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> k = *(<span class="keyword">uint32_t</span>*)data;</span><br><span class="line"></span><br><span class="line">        k *= m;</span><br><span class="line">        k ^= k &gt;&gt; r;</span><br><span class="line">        k *= m;</span><br><span class="line"></span><br><span class="line">        h *= m;</span><br><span class="line">        h ^= k;</span><br><span class="line"></span><br><span class="line">        data += <span class="number">4</span>;</span><br><span class="line">        len -= <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle the last few bytes of the input array  */</span></span><br><span class="line">    <span class="keyword">switch</span>(len) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: h ^= data[<span class="number">2</span>] &lt;&lt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: h ^= data[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: h ^= data[<span class="number">0</span>]; h *= m;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do a few final mixes of the hash to ensure the last few</span></span><br><span class="line"><span class="comment">     * bytes are well-incorporated. */</span></span><br><span class="line">    h ^= h &gt;&gt; <span class="number">13</span>;</span><br><span class="line">    h *= m;</span><br><span class="line">    h ^= h &gt;&gt; <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* And a case insensitive hash function (based on djb hash) */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dictGenCaseHashFunction</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)dict_hash_function_seed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (len--)</span><br><span class="line">        hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + (<span class="built_in">tolower</span>(*buf++)); <span class="comment">/* hash * 33 + c */</span></span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h2><h3 id="dict-dictCreate-dictType-type-void-privDataPtr"><a href="#dict-dictCreate-dictType-type-void-privDataPtr" class="headerlink" title="dict *dictCreate(dictType *type, void *privDataPtr);"></a><code>dict *dictCreate(dictType *type, void *privDataPtr);</code></h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>创建空dict</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create a new hash table */</span></span><br><span class="line"><span class="function">dict *<span class="title">dictCreate</span><span class="params">(dictType *type,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> *privDataPtr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dict *d = zmalloc(<span class="keyword">sizeof</span>(*d)); <span class="comment">// 申请地址</span></span><br><span class="line"></span><br><span class="line">    _dictInit(d,type,privDataPtr); <span class="comment">// 初始化dict</span></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int-dictExpand-dict-d-unsigned-long-size"><a href="#int-dictExpand-dict-d-unsigned-long-size" class="headerlink" title="int dictExpand(dict *d, unsigned long size);"></a><code>int dictExpand(dict *d, unsigned long size);</code></h3><h4 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h4><p>变更dict的容量<br>size:可容纳键值对的数量</p>
<h4 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Expand or create the hash table */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictExpand</span><span class="params">(dict *d, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictht n; <span class="comment">/* the new hash table */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> realsize = _dictNextPower(size); <span class="comment">// 根据size计算实际需要的容量(为2的指数)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* the size is invalid if it is smaller than the number of</span></span><br><span class="line"><span class="comment">     * elements already inside the hash table */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d) || d-&gt;ht[<span class="number">0</span>].used &gt; size) <span class="comment">// 重新hash过程中不能扩展,低于已使用的值无效</span></span><br><span class="line">        <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Rehashing to the same table size is not useful. */</span></span><br><span class="line">    <span class="keyword">if</span> (realsize == d-&gt;ht[<span class="number">0</span>].size) <span class="keyword">return</span> DICT_ERR; <span class="comment">// 尺寸无变化,不处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate the new hash table and initialize all pointers to NULL */</span></span><br><span class="line">    n.size = realsize;</span><br><span class="line">    n.sizemask = realsize<span class="number">-1</span>;</span><br><span class="line">    n.table = zcalloc(realsize*<span class="keyword">sizeof</span>(dictEntry*)); <span class="comment">// 申请数据内存</span></span><br><span class="line">    n.used = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Is this the first initialization? If so it&#x27;s not really a rehashing</span></span><br><span class="line"><span class="comment">     * we just set the first hash table so that it can accept keys. */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].table == <span class="literal">NULL</span>) &#123; <span class="comment">// #0ht为空,则是全新的dict,直接初始化设置即可</span></span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = n;</span><br><span class="line">        <span class="keyword">return</span> DICT_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Prepare a second hash table for incremental rehashing */</span></span><br><span class="line">    d-&gt;ht[<span class="number">1</span>] = n; <span class="comment">// #1设置为新的ht,为后续rehash做准备</span></span><br><span class="line">    d-&gt;rehashidx = <span class="number">0</span>; <span class="comment">// 标记为开始rehash状态,并且索引为0</span></span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int-dictAdd-dict-d-void-key-void-val"><a href="#int-dictAdd-dict-d-void-key-void-val" class="headerlink" title="int dictAdd(dict *d, void *key, void *val);"></a><code>int dictAdd(dict *d, void *key, void *val);</code></h3><h4 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h4><p>向dict中添加键值对</p>
<h4 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Add an element to the target hash table */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictAdd</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *entry = dictAddRaw(d,key); <span class="comment">// 尝试向dict中添加一个key,成功后返回entry,失败返回NULL</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!entry) <span class="keyword">return</span> DICT_ERR; <span class="comment">// 添加失败了</span></span><br><span class="line">    dictSetVal(d, entry, val); <span class="comment">// 设置新添加的entry的值</span></span><br><span class="line">    <span class="keyword">return</span> DICT_OK; <span class="comment">// 返回成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dictEntry-dictAddRaw-dict-d-void-key"><a href="#dictEntry-dictAddRaw-dict-d-void-key" class="headerlink" title="dictEntry *dictAddRaw(dict *d, void *key);"></a><code>dictEntry *dictAddRaw(dict *d, void *key);</code></h3><h4 id="功能-3"><a href="#功能-3" class="headerlink" title="功能"></a>功能</h4><p>向dict中添加键</p>
<h4 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Low level add. This function adds the entry but instead of setting</span></span><br><span class="line"><span class="comment"> * a value returns the dictEntry structure to the user, that will make</span></span><br><span class="line"><span class="comment"> * sure to fill the value field as he wishes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is also directly exposed to the user API to be called</span></span><br><span class="line"><span class="comment"> * mainly in order to store non-pointers inside the hash value, example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * entry = dictAddRaw(dict,mykey);</span></span><br><span class="line"><span class="comment"> * if (entry != NULL) dictSetSignedIntegerVal(entry,1000);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return values:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If key already exists NULL is returned.</span></span><br><span class="line"><span class="comment"> * If key was added, the hash entry is returned to be manipulated by the caller.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictAddRaw</span><span class="params">(dict *d, <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    dictEntry *entry;</span><br><span class="line">    dictht *ht;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d); <span class="comment">// 如果是在rehash过程中,则rehash一个slot的链表(就是将ht[0]的一个索引的内容迁移到ht[1]中)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get the index of the new element, or -1 if</span></span><br><span class="line"><span class="comment">     * the element already exists. */</span></span><br><span class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key)) == <span class="number">-1</span>) <span class="comment">// 获取到key新插入的索引位置(-1:已经插入过了)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate the memory and store the new entry.</span></span><br><span class="line"><span class="comment">     * Insert the element in top, with the assumption that in a database</span></span><br><span class="line"><span class="comment">     * system it is more likely that recently added entries are accessed</span></span><br><span class="line"><span class="comment">     * more frequently. */</span></span><br><span class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>]; <span class="comment">// 如果是在rehash过程中,则直接插入新的ht[1]中,否则插入ht[0]</span></span><br><span class="line">    entry = zmalloc(<span class="keyword">sizeof</span>(*entry)); <span class="comment">// 申请内存</span></span><br><span class="line">    entry-&gt;next = ht-&gt;table[index]; <span class="comment">// 插入到链表开头(通用假定:新插入的数据使用频率更高,所以放在最前面)</span></span><br><span class="line">    ht-&gt;table[index] = entry; <span class="comment">// 链表原始数据后移</span></span><br><span class="line">    ht-&gt;used++; <span class="comment">// 记录已插入的条目数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the hash entry fields. */</span></span><br><span class="line">    dictSetKey(d, entry, key); <span class="comment">// entry设置key的值</span></span><br><span class="line">    <span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int-dictReplace-dict-d-void-key-void-val"><a href="#int-dictReplace-dict-d-void-key-void-val" class="headerlink" title="int dictReplace(dict *d, void *key, void *val);"></a><code>int dictReplace(dict *d, void *key, void *val);</code></h3><h4 id="功能-4"><a href="#功能-4" class="headerlink" title="功能"></a>功能</h4><p>插入/更新键值对<br>返回是否是插入<br>0:更新<br>1:插入</p>
<h4 id="源码-4"><a href="#源码-4" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Add an element, discarding the old if the key already exists.</span></span><br><span class="line"><span class="comment"> * Return 1 if the key was added from scratch, 0 if there was already an</span></span><br><span class="line"><span class="comment"> * element with such key and dictReplace() just performed a value update</span></span><br><span class="line"><span class="comment"> * operation. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictReplace</span><span class="params">(dict *d, <span class="keyword">void</span> *key, <span class="keyword">void</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *entry, auxentry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Try to add the element. If the key</span></span><br><span class="line"><span class="comment">     * does not exists dictAdd will suceed. */</span></span><br><span class="line">    <span class="keyword">if</span> (dictAdd(d, key, val) == DICT_OK) <span class="comment">// 添加成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* It already exists, get the entry */</span></span><br><span class="line">    entry = dictFind(d, key); <span class="comment">// 找到原有值</span></span><br><span class="line">    <span class="comment">/* Set the new value and free the old one. Note that it is important</span></span><br><span class="line"><span class="comment">     * to do that in this order, as the value may just be exactly the same</span></span><br><span class="line"><span class="comment">     * as the previous one. In this context, think to reference counting,</span></span><br><span class="line"><span class="comment">     * you want to increment (set), and then decrement (free), and not the</span></span><br><span class="line"><span class="comment">     * reverse. */</span></span><br><span class="line">    auxentry = *entry; <span class="comment">// 复制原有值</span></span><br><span class="line">    dictSetVal(d, entry, val); <span class="comment">// 设置新值(这里的顺序是因为有一个引用记数的存在,当新旧值一样时,需要先增加后减少,否则可能出现减少后引用记数为0,增加时出现问题的情况)</span></span><br><span class="line">    dictFreeVal(d, &amp;auxentry); <span class="comment">// 释放旧值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dictEntry-dictReplaceRaw-dict-d-void-key"><a href="#dictEntry-dictReplaceRaw-dict-d-void-key" class="headerlink" title="dictEntry *dictReplaceRaw(dict *d, void *key);"></a><code>dictEntry *dictReplaceRaw(dict *d, void *key);</code></h3><h4 id="功能-5"><a href="#功能-5" class="headerlink" title="功能"></a>功能</h4><p>从dict中获取到指定键的entry<br>可能是插入或更新</p>
<h4 id="源码-5"><a href="#源码-5" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* dictReplaceRaw() is simply a version of dictAddRaw() that always</span></span><br><span class="line"><span class="comment"> * returns the hash entry of the specified key, even if the key already</span></span><br><span class="line"><span class="comment"> * exists and can&#x27;t be added (in that case the entry of the already</span></span><br><span class="line"><span class="comment"> * existing key is returned.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * See dictAddRaw() for more information. */</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictReplaceRaw</span><span class="params">(dict *d, <span class="keyword">void</span> *key)</span> </span>&#123;</span><br><span class="line">    dictEntry *entry = dictFind(d,key); <span class="comment">// 查找旧数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> entry ? entry : dictAddRaw(d,key); <span class="comment">// 有旧数据就返回旧数据,否则返回新数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int-dictDelete-dict-d-const-void-key"><a href="#int-dictDelete-dict-d-const-void-key" class="headerlink" title="int dictDelete(dict *d, const void *key);"></a><code>int dictDelete(dict *d, const void *key);</code></h3><h4 id="功能-6"><a href="#功能-6" class="headerlink" title="功能"></a>功能</h4><p>删除指定键<br>释放键值对内存空间</p>
<h4 id="源码-6"><a href="#源码-6" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDelete</span><span class="params">(dict *ht, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dictGenericDelete(ht,key,<span class="number">0</span>); <span class="comment">// 删除指定键,参数0:释放键值对对应的内存空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int-dictDeleteNoFree-dict-d-const-void-key"><a href="#int-dictDeleteNoFree-dict-d-const-void-key" class="headerlink" title="int dictDeleteNoFree(dict *d, const void *key);"></a><code>int dictDeleteNoFree(dict *d, const void *key);</code></h3><h4 id="功能-7"><a href="#功能-7" class="headerlink" title="功能"></a>功能</h4><p>删除指定键<br>不释放键值对内存空间</p>
<h4 id="源码-7"><a href="#源码-7" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDeleteNoFree</span><span class="params">(dict *ht, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dictGenericDelete(ht,key,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void-dictRelease-dict-d"><a href="#void-dictRelease-dict-d" class="headerlink" title="void dictRelease(dict *d);"></a><code>void dictRelease(dict *d);</code></h3><h4 id="功能-8"><a href="#功能-8" class="headerlink" title="功能"></a>功能</h4><p>释放整个dict的所有数据</p>
<h4 id="源码-8"><a href="#源码-8" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Clear &amp; Release the hash table */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictRelease</span><span class="params">(dict *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _dictClear(d,&amp;d-&gt;ht[<span class="number">0</span>],<span class="literal">NULL</span>); <span class="comment">// 清空主数据</span></span><br><span class="line">    _dictClear(d,&amp;d-&gt;ht[<span class="number">1</span>],<span class="literal">NULL</span>); <span class="comment">// 清空从数据</span></span><br><span class="line">    zfree(d); <span class="comment">// 释放dict内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dictEntry-dictFind-dict-d-const-void-key"><a href="#dictEntry-dictFind-dict-d-const-void-key" class="headerlink" title="dictEntry * dictFind(dict *d, const void *key);"></a><code>dictEntry * dictFind(dict *d, const void *key);</code></h3><h4 id="功能-9"><a href="#功能-9" class="headerlink" title="功能"></a>功能</h4><p>查找键</p>
<h4 id="源码-9"><a href="#源码-9" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">dictEntry *<span class="title">dictFind</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *he;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> h, idx, table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used + d-&gt;ht[<span class="number">1</span>].used == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* dict is empty */</span> <span class="comment">// 空dict</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d); <span class="comment">// 尝试rehash一个slot</span></span><br><span class="line">    h = dictHashKey(d, key); <span class="comment">// 获取键的hash值</span></span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123; <span class="comment">// 遍历dict数据</span></span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask; <span class="comment">// 获取对应的下标索引</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx]; <span class="comment">// 获取到链表头数据</span></span><br><span class="line">        <span class="keyword">while</span>(he) &#123; <span class="comment">// 遍历链表</span></span><br><span class="line">            <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) <span class="comment">// 匹配键</span></span><br><span class="line">                <span class="keyword">return</span> he; <span class="comment">// 相同返回</span></span><br><span class="line">            he = he-&gt;next; <span class="comment">// 获取下一个数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 如果没有在rehash,则不存在ht[1],所以可以直接返回NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 没有找到,返回NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void-dictFetchValue-dict-d-const-void-key"><a href="#void-dictFetchValue-dict-d-const-void-key" class="headerlink" title="void *dictFetchValue(dict *d, const void *key);"></a><code>void *dictFetchValue(dict *d, const void *key);</code></h3><h4 id="功能-10"><a href="#功能-10" class="headerlink" title="功能"></a>功能</h4><p>根据键直接找到值指针</p>
<h4 id="源码-10"><a href="#源码-10" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dictFetchValue</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> </span>&#123;</span><br><span class="line">    dictEntry *he;</span><br><span class="line"></span><br><span class="line">    he = dictFind(d,key); <span class="comment">// 查找entry</span></span><br><span class="line">    <span class="keyword">return</span> he ? dictGetVal(he) : <span class="literal">NULL</span>; <span class="comment">// 返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int-dictResize-dict-d"><a href="#int-dictResize-dict-d" class="headerlink" title="int dictResize(dict *d);"></a><code>int dictResize(dict *d);</code></h3><h4 id="功能-11"><a href="#功能-11" class="headerlink" title="功能"></a>功能</h4><p>将dict占用内存缩小到最小的可用尺寸</p>
<h4 id="源码-11"><a href="#源码-11" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This is the initial size of every hash table */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICT_HT_INITIAL_SIZE     4</span></span><br><span class="line"><span class="comment">/* Resize the table to the minimal size that contains all the elements,</span></span><br><span class="line"><span class="comment"> * but with the invariant of a USED/BUCKETS ratio near to &lt;= 1 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictResize</span><span class="params">(dict *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minimal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dict_can_resize || dictIsRehashing(d)) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line">    minimal = d-&gt;ht[<span class="number">0</span>].used;</span><br><span class="line">    <span class="keyword">if</span> (minimal &lt; DICT_HT_INITIAL_SIZE)</span><br><span class="line">        minimal = DICT_HT_INITIAL_SIZE;</span><br><span class="line">    <span class="keyword">return</span> dictExpand(d, minimal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dictIterator-dictGetIterator-dict-d"><a href="#dictIterator-dictGetIterator-dict-d" class="headerlink" title="dictIterator *dictGetIterator(dict *d);"></a><code>dictIterator *dictGetIterator(dict *d);</code></h3><h4 id="功能-12"><a href="#功能-12" class="headerlink" title="功能"></a>功能</h4><p>生成一个指定dict的迭代器<br>默认非安全</p>
<h4 id="源码-12"><a href="#源码-12" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">dictIterator *<span class="title">dictGetIterator</span><span class="params">(dict *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictIterator *iter = zmalloc(<span class="keyword">sizeof</span>(*iter));</span><br><span class="line"></span><br><span class="line">    iter-&gt;d = d;</span><br><span class="line">    iter-&gt;table = <span class="number">0</span>;</span><br><span class="line">    iter-&gt;index = <span class="number">-1</span>;</span><br><span class="line">    iter-&gt;safe = <span class="number">0</span>;</span><br><span class="line">    iter-&gt;entry = <span class="literal">NULL</span>;</span><br><span class="line">    iter-&gt;nextEntry = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dictIterator-dictGetSafeIterator-dict-d"><a href="#dictIterator-dictGetSafeIterator-dict-d" class="headerlink" title="dictIterator *dictGetSafeIterator(dict *d);"></a><code>dictIterator *dictGetSafeIterator(dict *d);</code></h3><h4 id="功能-13"><a href="#功能-13" class="headerlink" title="功能"></a>功能</h4><p>生成一个指定dict的迭代器<br>安全</p>
<h4 id="源码-13"><a href="#源码-13" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">dictIterator *<span class="title">dictGetSafeIterator</span><span class="params">(dict *d)</span> </span>&#123;</span><br><span class="line">    dictIterator *i = dictGetIterator(d);</span><br><span class="line"></span><br><span class="line">    i-&gt;safe = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dictEntry-dictNext-dictIterator-iter"><a href="#dictEntry-dictNext-dictIterator-iter" class="headerlink" title="dictEntry *dictNext(dictIterator *iter);"></a><code>dictEntry *dictNext(dictIterator *iter);</code></h3><h4 id="功能-14"><a href="#功能-14" class="headerlink" title="功能"></a>功能</h4><p>根据迭代器<br>获取下一个dict的元素</p>
<h4 id="源码-14"><a href="#源码-14" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">dictEntry *<span class="title">dictNext</span><span class="params">(dictIterator *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="comment">// 死循环</span></span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;entry == <span class="literal">NULL</span>) &#123; <span class="comment">// 迭代器没有元素</span></span><br><span class="line">            dictht *ht = &amp;iter-&gt;d-&gt;ht[iter-&gt;table]; <span class="comment">// 获取到当前迭代的ht</span></span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;index == <span class="number">-1</span> &amp;&amp; iter-&gt;table == <span class="number">0</span>) &#123; <span class="comment">// 如果是第一次迭代(这两个条件只有在初始化时才满足)</span></span><br><span class="line">                <span class="keyword">if</span> (iter-&gt;safe) <span class="comment">// 安全迭代器</span></span><br><span class="line">                    iter-&gt;d-&gt;iterators++; <span class="comment">// 增加dict的安全迭代器记数</span></span><br><span class="line">                <span class="keyword">else</span> <span class="comment">// 非安全迭代器</span></span><br><span class="line">                    iter-&gt;fingerprint = dictFingerprint(iter-&gt;d); <span class="comment">// 生成指纹记录</span></span><br><span class="line">            &#125;</span><br><span class="line">            iter-&gt;index++; <span class="comment">// 增加索引</span></span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;index &gt;= (<span class="keyword">long</span>) ht-&gt;size) &#123; <span class="comment">// 索引超过容量长度</span></span><br><span class="line">                <span class="keyword">if</span> (dictIsRehashing(iter-&gt;d) &amp;&amp; iter-&gt;table == <span class="number">0</span>) &#123; <span class="comment">// 如果存在ht[1]的话</span></span><br><span class="line">                    iter-&gt;table++; <span class="comment">// 标记使用ht[1]</span></span><br><span class="line">                    iter-&gt;index = <span class="number">0</span>; <span class="comment">// 重置查询索引</span></span><br><span class="line">                    ht = &amp;iter-&gt;d-&gt;ht[<span class="number">1</span>]; <span class="comment">// 使用ht[1]</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 遍历完成,没有其他数据了</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            iter-&gt;entry = ht-&gt;table[iter-&gt;index]; <span class="comment">// 记录当前找到的entry</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            iter-&gt;entry = iter-&gt;nextEntry; <span class="comment">// 直接获取下一个entry</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;entry) &#123; <span class="comment">// 如果查询到的entry存在</span></span><br><span class="line">            <span class="comment">/* We need to save the &#x27;next&#x27; here, the iterator user</span></span><br><span class="line"><span class="comment">             * may delete the entry we are returning. */</span></span><br><span class="line">            iter-&gt;nextEntry = iter-&gt;entry-&gt;next; <span class="comment">// 记录下一个entry</span></span><br><span class="line">            <span class="keyword">return</span> iter-&gt;entry; <span class="comment">// 返回查询到的entry</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 没有查询到,返回NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void-dictReleaseIterator-dictIterator-iter"><a href="#void-dictReleaseIterator-dictIterator-iter" class="headerlink" title="void dictReleaseIterator(dictIterator *iter);"></a><code>void dictReleaseIterator(dictIterator *iter);</code></h3><h4 id="功能-15"><a href="#功能-15" class="headerlink" title="功能"></a>功能</h4><p>释放迭代器</p>
<h4 id="源码-15"><a href="#源码-15" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictReleaseIterator</span><span class="params">(dictIterator *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(iter-&gt;index == <span class="number">-1</span> &amp;&amp; iter-&gt;table == <span class="number">0</span>)) &#123; <span class="comment">// 是否是使用过的迭代器</span></span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;safe) <span class="comment">// 是否安全</span></span><br><span class="line">            iter-&gt;d-&gt;iterators--; <span class="comment">// 减少dict迭代器数量</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            assert(iter-&gt;fingerprint == dictFingerprint(iter-&gt;d)); <span class="comment">// 断言指纹一致</span></span><br><span class="line">    &#125;</span><br><span class="line">    zfree(iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dictEntry-dictGetRandomKey-dict-d"><a href="#dictEntry-dictGetRandomKey-dict-d" class="headerlink" title="dictEntry *dictGetRandomKey(dict *d);"></a><code>dictEntry *dictGetRandomKey(dict *d);</code></h3><h4 id="功能-16"><a href="#功能-16" class="headerlink" title="功能"></a>功能</h4><p>获取随机键<br>流程:<br>    1. 随机获取两个ht的总index<br>    2. 随机一个链表的索引</p>
<h4 id="源码-16"><a href="#源码-16" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Return a random entry from the hash table. Useful to</span></span><br><span class="line"><span class="comment"> * implement randomized algorithms */</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictGetRandomKey</span><span class="params">(dict *d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *he, *orighe;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">int</span> listlen, listele;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 空dict直接返回NULL</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d); <span class="comment">// 递进rehash()</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) &#123; <span class="comment">// 如果在rehashing中</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">/* We are sure there are no elements in indexes from 0</span></span><br><span class="line"><span class="comment">             * to rehashidx-1 */</span></span><br><span class="line">            h = d-&gt;rehashidx + (random() % (d-&gt;ht[<span class="number">0</span>].size +</span><br><span class="line">                                            d-&gt;ht[<span class="number">1</span>].size -</span><br><span class="line">                                            d-&gt;rehashidx)); <span class="comment">// 合并ht[0]和ht[1]的索引并跳过ht[0]的空索引部分随机</span></span><br><span class="line">            he = (h &gt;= d-&gt;ht[<span class="number">0</span>].size) ? d-&gt;ht[<span class="number">1</span>].table[h - d-&gt;ht[<span class="number">0</span>].size] :</span><br><span class="line">                                      d-&gt;ht[<span class="number">0</span>].table[h]; <span class="comment">// 获取到entry</span></span><br><span class="line">        &#125; <span class="keyword">while</span>(he == <span class="literal">NULL</span>); <span class="comment">// 没有随机到有效数据时</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 正常状况</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            h = random() &amp; d-&gt;ht[<span class="number">0</span>].sizemask; <span class="comment">// 直接随机整个ht[0]</span></span><br><span class="line">            he = d-&gt;ht[<span class="number">0</span>].table[h]; <span class="comment">// 获取到entry</span></span><br><span class="line">        &#125; <span class="keyword">while</span>(he == <span class="literal">NULL</span>); <span class="comment">// 没有随机到有效数据时</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now we found a non empty bucket, but it is a linked</span></span><br><span class="line"><span class="comment">     * list and we need to get a random element from the list.</span></span><br><span class="line"><span class="comment">     * The only sane way to do so is counting the elements and</span></span><br><span class="line"><span class="comment">     * select a random index. */</span></span><br><span class="line">    listlen = <span class="number">0</span>;</span><br><span class="line">    orighe = he;</span><br><span class="line">    <span class="keyword">while</span>(he) &#123; <span class="comment">// 统计链表长度</span></span><br><span class="line">        he = he-&gt;next;</span><br><span class="line">        listlen++;</span><br><span class="line">    &#125;</span><br><span class="line">    listele = random() % listlen; <span class="comment">// 随机索引</span></span><br><span class="line">    he = orighe;</span><br><span class="line">    <span class="keyword">while</span>(listele--) he = he-&gt;next; <span class="comment">// 遍历获取对应的entry</span></span><br><span class="line">    <span class="keyword">return</span> he; <span class="comment">// 返回最终随机结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unsigned-int-dictGetSomeKeys-dict-d-dictEntry-des-unsigned-int-count"><a href="#unsigned-int-dictGetSomeKeys-dict-d-dictEntry-des-unsigned-int-count" class="headerlink" title="unsigned int dictGetSomeKeys(dict *d, dictEntry **des, unsigned int count);"></a><code>unsigned int dictGetSomeKeys(dict *d, dictEntry **des, unsigned int count);</code></h3><h4 id="功能-17"><a href="#功能-17" class="headerlink" title="功能"></a>功能</h4><p>获取到<code>count</code>个从一个随机键开始的连续元素<br>实际返回元素数&lt;=count值<br>返回内容也不保证无重复</p>
<h4 id="源码-17"><a href="#源码-17" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This function samples the dictionary to return a few keys from random</span></span><br><span class="line"><span class="comment"> * locations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It does not guarantee to return all the keys specified in &#x27;count&#x27;, nor</span></span><br><span class="line"><span class="comment"> * it does guarantee to return non-duplicated elements, however it will make</span></span><br><span class="line"><span class="comment"> * some effort to do both things.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returned pointers to hash table entries are stored into &#x27;des&#x27; that</span></span><br><span class="line"><span class="comment"> * points to an array of dictEntry pointers. The array must have room for</span></span><br><span class="line"><span class="comment"> * at least &#x27;count&#x27; elements, that is the argument we pass to the function</span></span><br><span class="line"><span class="comment"> * to tell how many random elements we need.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns the number of items stored into &#x27;des&#x27;, that may</span></span><br><span class="line"><span class="comment"> * be less than &#x27;count&#x27; if the hash table has less than &#x27;count&#x27; elements</span></span><br><span class="line"><span class="comment"> * inside, or if not enough elements were found in a reasonable amount of</span></span><br><span class="line"><span class="comment"> * steps.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that this function is not suitable when you need a good distribution</span></span><br><span class="line"><span class="comment"> * of the returned items, but only when you need to &quot;sample&quot; a given number</span></span><br><span class="line"><span class="comment"> * of continuous elements to run some kind of algorithm or to produce</span></span><br><span class="line"><span class="comment"> * statistics. However the function is much faster than dictGetRandomKey()</span></span><br><span class="line"><span class="comment"> * at producing N elements. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dictGetSomeKeys</span><span class="params">(dict *d, dictEntry **des, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> j; <span class="comment">/* internal hash table id, 0 or 1. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> tables; <span class="comment">/* 1 or 2 tables? */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stored = <span class="number">0</span>, maxsizemask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> maxsteps;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) &lt; count) count = dictSize(d); <span class="comment">// 整理实际可以获得的count数量</span></span><br><span class="line">    maxsteps = count*<span class="number">10</span>; <span class="comment">// 最大循环次数,防止长时阻塞</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Try to do a rehashing work proportional to &#x27;count&#x27;. */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123; <span class="comment">// 步进rehash,count次</span></span><br><span class="line">        <span class="keyword">if</span> (dictIsRehashing(d))</span><br><span class="line">            _dictRehashStep(d);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tables = dictIsRehashing(d) ? <span class="number">2</span> : <span class="number">1</span>; <span class="comment">// 是否有ht[1]参与</span></span><br><span class="line">    maxsizemask = d-&gt;ht[<span class="number">0</span>].sizemask;</span><br><span class="line">    <span class="keyword">if</span> (tables &gt; <span class="number">1</span> &amp;&amp; maxsizemask &lt; d-&gt;ht[<span class="number">1</span>].sizemask) <span class="comment">// 获取最大的mask</span></span><br><span class="line">        maxsizemask = d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pick a random point inside the larger table. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i = random() &amp; maxsizemask; <span class="comment">// 随机索引值</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> emptylen = <span class="number">0</span>; <span class="comment">/* Continuous empty entries so far. */</span></span><br><span class="line">    <span class="keyword">while</span>(stored &lt; count &amp;&amp; maxsteps--) &#123; <span class="comment">// 存储数量不足并且没有达到最大步数的话</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; tables; j++) &#123; <span class="comment">// 遍历表</span></span><br><span class="line">            <span class="comment">/* Invariant of the dict.c rehashing: up to the indexes already</span></span><br><span class="line"><span class="comment">             * visited in ht[0] during the rehashing, there are no populated</span></span><br><span class="line"><span class="comment">             * buckets, so we can skip ht[0] for indexes between 0 and idx-1. */</span></span><br><span class="line">            <span class="keyword">if</span> (tables == <span class="number">2</span> &amp;&amp; j == <span class="number">0</span> &amp;&amp; i &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) d-&gt;rehashidx) &#123; <span class="comment">// rehashing中ht[0]的0-rehashidx的索引都是空的,因为已经移动到ht[1]中了</span></span><br><span class="line">                <span class="comment">/* Moreover, if we are currently out of range in the second</span></span><br><span class="line"><span class="comment">                 * table, there will be no elements in both tables up to</span></span><br><span class="line"><span class="comment">                 * the current rehashing index, so we jump if possible.</span></span><br><span class="line"><span class="comment">                 * (this happens when going from big to small table). */</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt;= d-&gt;ht[<span class="number">1</span>].size) i = d-&gt;rehashidx;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= d-&gt;ht[j].size) <span class="keyword">continue</span>; <span class="comment">/* Out of range for this table. */</span></span><br><span class="line">            dictEntry *he = d-&gt;ht[j].table[i]; <span class="comment">// 获取到指定的索引内容</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Count contiguous empty buckets, and jump to other</span></span><br><span class="line"><span class="comment">             * locations if they reach &#x27;count&#x27; (with a minimum of 5). */</span></span><br><span class="line">            <span class="keyword">if</span> (he == <span class="literal">NULL</span>) &#123; <span class="comment">// 是否为空</span></span><br><span class="line">                emptylen++;</span><br><span class="line">                <span class="keyword">if</span> (emptylen &gt;= <span class="number">5</span> &amp;&amp; emptylen &gt; count) &#123; <span class="comment">// 连续5次或超过count次为空</span></span><br><span class="line">                    i = random() &amp; maxsizemask; <span class="comment">// 重新随机索引</span></span><br><span class="line">                    emptylen = <span class="number">0</span>; <span class="comment">// 重置空次数</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                emptylen = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (he) &#123; <span class="comment">// 遍历填充链表的后续元素</span></span><br><span class="line">                    <span class="comment">/* Collect all the elements of the buckets found non</span></span><br><span class="line"><span class="comment">                     * empty while iterating. */</span></span><br><span class="line">                    *des = he;</span><br><span class="line">                    des++;</span><br><span class="line">                    he = he-&gt;next;</span><br><span class="line">                    stored++;</span><br><span class="line">                    <span class="keyword">if</span> (stored == count) <span class="keyword">return</span> stored; <span class="comment">// 数量足够,返回</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i = (i+<span class="number">1</span>) &amp; maxsizemask; <span class="comment">// 向后遍历取数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stored; <span class="comment">// 数据不足count,返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="static-void-dictReset-dictht-ht"><a href="#static-void-dictReset-dictht-ht" class="headerlink" title="static void _dictReset(dictht *ht);"></a><code>static void _dictReset(dictht *ht);</code></h3><h4 id="功能-18"><a href="#功能-18" class="headerlink" title="功能"></a>功能</h4><p>ht重置</p>
<h4 id="源码-18"><a href="#源码-18" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Reset a hash table already initialized with ht_init().</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> This function should only be called by ht_destroy(). */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictReset(dictht *ht)</span><br><span class="line">&#123;</span><br><span class="line">    ht-&gt;table = <span class="literal">NULL</span>;</span><br><span class="line">    ht-&gt;size = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;sizemask = <span class="number">0</span>;</span><br><span class="line">    ht-&gt;used = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int-dictInit-dict-d-dictType-type-void-privDataPtr"><a href="#int-dictInit-dict-d-dictType-type-void-privDataPtr" class="headerlink" title="int _dictInit(dict *d, dictType *type, void *privDataPtr);"></a><code>int _dictInit(dict *d, dictType *type, void *privDataPtr);</code></h3><h4 id="功能-19"><a href="#功能-19" class="headerlink" title="功能"></a>功能</h4><p>dict初始化</p>
<h4 id="源码-19"><a href="#源码-19" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Initialize the hash table */</span></span><br><span class="line"><span class="keyword">int</span> _dictInit(dict *d, dictType *type,</span><br><span class="line">        <span class="keyword">void</span> *privDataPtr)</span><br><span class="line">&#123;</span><br><span class="line">    _dictReset(&amp;d-&gt;ht[<span class="number">0</span>]);</span><br><span class="line">    _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">    d-&gt;type = type;</span><br><span class="line">    d-&gt;privdata = privDataPtr;</span><br><span class="line">    d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">    d-&gt;iterators = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int-dictRehash-dict-d-int-n"><a href="#int-dictRehash-dict-d-int-n" class="headerlink" title="int dictRehash(dict *d, int n)"></a><code>int dictRehash(dict *d, int n)</code></h3><h4 id="功能-20"><a href="#功能-20" class="headerlink" title="功能"></a>功能</h4><p>dict的rehash<br>将数据从ht[0]迁移到ht[1]中<br>当全部迁移完毕后<br>释放旧数据<br>统一将ht[1]移动到ht[0]<br>分多次运行处理<br>以保证不会阻塞</p>
<h4 id="源码-20"><a href="#源码-20" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Performs N steps of incremental rehashing. Returns 1 if there are still</span></span><br><span class="line"><span class="comment"> * keys to move from the old to the new hash table, otherwise 0 is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that a rehashing step consists in moving a bucket (that may have more</span></span><br><span class="line"><span class="comment"> * than one key as we use chaining) from the old to the new hash table, however</span></span><br><span class="line"><span class="comment"> * since part of the hash table may be composed of empty spaces, it is not</span></span><br><span class="line"><span class="comment"> * guaranteed that this function will rehash even a single bucket, since it</span></span><br><span class="line"><span class="comment"> * will visit at max N*10 empty buckets in total, otherwise the amount of</span></span><br><span class="line"><span class="comment"> * work it does would be unbound and the function may block for a long time. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> empty_visits = n*<span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span> <span class="comment">// 空处理的数量</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 没有在rehash状态,不操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123; <span class="comment">// 当有数据存在并且没有到达操作次数上限时</span></span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can&#x27;t overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)d-&gt;rehashidx);</span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123; <span class="comment">// 遍历到下一个有效数据</span></span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx]; <span class="comment">// 获取到entry</span></span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123; <span class="comment">// 遍历链表并移动到ht[1]中</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>; <span class="comment">// 清空旧链表</span></span><br><span class="line">        d-&gt;rehashidx++; <span class="comment">// 递增rehashidx</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123; <span class="comment">// 全部处理完成</span></span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table); <span class="comment">// 释放就数据</span></span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>]; <span class="comment">// 复制</span></span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]); <span class="comment">// 释放ht[1]</span></span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>; <span class="comment">// 标记为未rehash状态</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="long-long-timeInMilliseconds-void"><a href="#long-long-timeInMilliseconds-void" class="headerlink" title="long long timeInMilliseconds(void);"></a><code>long long timeInMilliseconds(void);</code></h3><h4 id="功能-21"><a href="#功能-21" class="headerlink" title="功能"></a>功能</h4><p>获取当前时间戳<br>毫秒</p>
<h4 id="源码-21"><a href="#源码-21" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">timeInMilliseconds</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;tv,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> (((<span class="keyword">long</span> <span class="keyword">long</span>)tv.tv_sec)*<span class="number">1000</span>)+(tv.tv_usec/<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int-dictRehashMilliseconds-dict-d-int-ms"><a href="#int-dictRehashMilliseconds-dict-d-int-ms" class="headerlink" title="int dictRehashMilliseconds(dict *d, int ms);"></a><code>int dictRehashMilliseconds(dict *d, int ms);</code></h3><h4 id="功能-22"><a href="#功能-22" class="headerlink" title="功能"></a>功能</h4><p>在指定毫秒内持续rehash</p>
<h4 id="源码-22"><a href="#源码-22" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Rehash for an amount of time between ms milliseconds and ms+1 milliseconds */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehashMilliseconds</span><span class="params">(dict *d, <span class="keyword">int</span> ms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start = timeInMilliseconds();</span><br><span class="line">    <span class="keyword">int</span> rehashes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(dictRehash(d,<span class="number">100</span>)) &#123;</span><br><span class="line">        rehashes += <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (timeInMilliseconds()-start &gt; ms) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rehashes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="static-void-dictRehashStep-dict-d"><a href="#static-void-dictRehashStep-dict-d" class="headerlink" title="static void _dictRehashStep(dict *d);"></a><code>static void _dictRehashStep(dict *d);</code></h3><h4 id="功能-23"><a href="#功能-23" class="headerlink" title="功能"></a>功能</h4><p>在没有安全迭代器的时候<br>rehash一个slot<br>通常在查找和更新dict时调用<br>目的是在使用dict的同时<br>自动rehash</p>
<h4 id="源码-23"><a href="#源码-23" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This function performs just a step of rehashing, and only if there are</span></span><br><span class="line"><span class="comment"> * no safe iterators bound to our hash table. When we have iterators in the</span></span><br><span class="line"><span class="comment"> * middle of a rehashing we can&#x27;t mess with the two hash tables otherwise</span></span><br><span class="line"><span class="comment"> * some element can be missed or duplicated.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is called by common lookup or update operations in the</span></span><br><span class="line"><span class="comment"> * dictionary so that the hash table automatically migrates from H1 to H2</span></span><br><span class="line"><span class="comment"> * while it is actively used. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictRehashStep(dict *d) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;iterators == <span class="number">0</span>) dictRehash(d,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="static-int-dictGenericDelete-dict-d-const-void-key-int-nofree"><a href="#static-int-dictGenericDelete-dict-d-const-void-key-int-nofree" class="headerlink" title="static int dictGenericDelete(dict *d, const void *key, int nofree);"></a><code>static int dictGenericDelete(dict *d, const void *key, int nofree);</code></h3><h4 id="功能-24"><a href="#功能-24" class="headerlink" title="功能"></a>功能</h4><p>通用删除操作</p>
<h4 id="源码-24"><a href="#源码-24" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Search and remove an element */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dictGenericDelete</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">int</span> nofree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> h, idx;</span><br><span class="line">    dictEntry *he, *prevHe;</span><br><span class="line">    <span class="keyword">int</span> table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> DICT_ERR; <span class="comment">/* d-&gt;ht[0].table is NULL */</span> <span class="comment">// 空表</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d); <span class="comment">// 步进rehash</span></span><br><span class="line">    h = dictHashKey(d, key); <span class="comment">// 获取hash值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123; <span class="comment">// 遍历ht</span></span><br><span class="line">        idx = h &amp; d-&gt;ht[table].sizemask; <span class="comment">// 获取下标</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx]; <span class="comment">// 获取entry</span></span><br><span class="line">        prevHe = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(he) &#123; <span class="comment">// 遍历链表</span></span><br><span class="line">            <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123; <span class="comment">// entry和目标键是否相同</span></span><br><span class="line">                <span class="comment">/* Unlink the element from the list */</span></span><br><span class="line">                <span class="keyword">if</span> (prevHe) <span class="comment">// 有前置的entry</span></span><br><span class="line">                    prevHe-&gt;next = he-&gt;next; <span class="comment">// 更新前置entry的next的值</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    d-&gt;ht[table].table[idx] = he-&gt;next; <span class="comment">// 将entry的next值标记为链表头数据</span></span><br><span class="line">                <span class="keyword">if</span> (!nofree) &#123; <span class="comment">// 是否需要释放内存</span></span><br><span class="line">                    dictFreeKey(d, he); <span class="comment">// 释放键</span></span><br><span class="line">                    dictFreeVal(d, he); <span class="comment">// 释放值</span></span><br><span class="line">                &#125;</span><br><span class="line">                zfree(he); <span class="comment">// 释放entry</span></span><br><span class="line">                d-&gt;ht[table].used--; <span class="comment">// 减少使用记数</span></span><br><span class="line">                <span class="keyword">return</span> DICT_OK; <span class="comment">// 返回成功</span></span><br><span class="line">            &#125;</span><br><span class="line">            prevHe = he; <span class="comment">// 记录前一个数据entry</span></span><br><span class="line">            he = he-&gt;next; <span class="comment">// 继续遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>; <span class="comment">// 没有rehash则停止</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_ERR; <span class="comment">/* not found */</span> <span class="comment">// 没有找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int-dictClear-dict-d-dictht-ht-void-callback-void"><a href="#int-dictClear-dict-d-dictht-ht-void-callback-void" class="headerlink" title="int _dictClear(dict *d, dictht *ht, void(callback)(void *));"></a><code>int _dictClear(dict *d, dictht *ht, void(callback)(void *));</code></h3><h4 id="功能-25"><a href="#功能-25" class="headerlink" title="功能"></a>功能</h4><p>清空指定的ht数据</p>
<h4 id="源码-25"><a href="#源码-25" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Destroy an entire dictionary */</span></span><br><span class="line"><span class="keyword">int</span> _dictClear(dict *d, dictht *ht, <span class="keyword">void</span>(callback)(<span class="keyword">void</span> *)) &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free all the elements */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ht-&gt;size &amp;&amp; ht-&gt;used &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">        dictEntry *he, *nextHe;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (callback &amp;&amp; (i &amp; <span class="number">65535</span>) == <span class="number">0</span>) callback(d-&gt;privdata);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((he = ht-&gt;table[i]) == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            nextHe = he-&gt;next;</span><br><span class="line">            dictFreeKey(d, he);</span><br><span class="line">            dictFreeVal(d, he);</span><br><span class="line">            zfree(he);</span><br><span class="line">            ht-&gt;used--;</span><br><span class="line">            he = nextHe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Free the table and the allocated cache structure */</span></span><br><span class="line">    zfree(ht-&gt;table);</span><br><span class="line">    <span class="comment">/* Re-initialize the table */</span></span><br><span class="line">    _dictReset(ht);</span><br><span class="line">    <span class="keyword">return</span> DICT_OK; <span class="comment">/* never fails */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="long-long-dictFingerprint-dict-d"><a href="#long-long-dictFingerprint-dict-d" class="headerlink" title="long long dictFingerprint(dict *d);"></a><code>long long dictFingerprint(dict *d);</code></h3><h4 id="功能-26"><a href="#功能-26" class="headerlink" title="功能"></a>功能</h4><p>计算dict的指纹数据</p>
<h4 id="源码-26"><a href="#源码-26" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* A fingerprint is a 64 bit number that represents the state of the dictionary</span></span><br><span class="line"><span class="comment"> * at a given time, it&#x27;s just a few dict properties xored together.</span></span><br><span class="line"><span class="comment"> * When an unsafe iterator is initialized, we get the dict fingerprint, and check</span></span><br><span class="line"><span class="comment"> * the fingerprint again when the iterator is released.</span></span><br><span class="line"><span class="comment"> * If the two fingerprints are different it means that the user of the iterator</span></span><br><span class="line"><span class="comment"> * performed forbidden operations against the dictionary while iterating. */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">dictFingerprint</span><span class="params">(dict *d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> integers[<span class="number">6</span>], hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    integers[<span class="number">0</span>] = (<span class="keyword">long</span>) d-&gt;ht[<span class="number">0</span>].table;</span><br><span class="line">    integers[<span class="number">1</span>] = d-&gt;ht[<span class="number">0</span>].size;</span><br><span class="line">    integers[<span class="number">2</span>] = d-&gt;ht[<span class="number">0</span>].used;</span><br><span class="line">    integers[<span class="number">3</span>] = (<span class="keyword">long</span>) d-&gt;ht[<span class="number">1</span>].table;</span><br><span class="line">    integers[<span class="number">4</span>] = d-&gt;ht[<span class="number">1</span>].size;</span><br><span class="line">    integers[<span class="number">5</span>] = d-&gt;ht[<span class="number">1</span>].used;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We hash N integers by summing every successive integer with the integer</span></span><br><span class="line"><span class="comment">     * hashing of the previous sum. Basically:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Result = hash(hash(hash(int1)+int2)+int3) ...</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This way the same set of integers in a different order will (likely) hash</span></span><br><span class="line"><span class="comment">     * to a different number. */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">        hash += integers[j];</span><br><span class="line">        <span class="comment">/* For the hashing step we use Tomas Wang&#x27;s 64 bit integer hash. */</span></span><br><span class="line">        hash = (~hash) + (hash &lt;&lt; <span class="number">21</span>); <span class="comment">// hash = (hash &lt;&lt; 21) - hash - 1;</span></span><br><span class="line">        hash = hash ^ (hash &gt;&gt; <span class="number">24</span>);</span><br><span class="line">        hash = (hash + (hash &lt;&lt; <span class="number">3</span>)) + (hash &lt;&lt; <span class="number">8</span>); <span class="comment">// hash * 265</span></span><br><span class="line">        hash = hash ^ (hash &gt;&gt; <span class="number">14</span>);</span><br><span class="line">        hash = (hash + (hash &lt;&lt; <span class="number">2</span>)) + (hash &lt;&lt; <span class="number">4</span>); <span class="comment">// hash * 21</span></span><br><span class="line">        hash = hash ^ (hash &gt;&gt; <span class="number">28</span>);</span><br><span class="line">        hash = hash + (hash &lt;&lt; <span class="number">31</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="static-unsigned-long-rev-unsigned-long-v"><a href="#static-unsigned-long-rev-unsigned-long-v" class="headerlink" title="static unsigned long rev(unsigned long v);"></a><code>static unsigned long rev(unsigned long v);</code></h3><h4 id="功能-27"><a href="#功能-27" class="headerlink" title="功能"></a>功能</h4><p>反转操作位数据</p>
<h4 id="源码-27"><a href="#源码-27" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Function to reverse bits. Algorithm from:</span></span><br><span class="line"><span class="comment"> * http://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">rev</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> s = <span class="number">8</span> * <span class="keyword">sizeof</span>(v); <span class="comment">// bit size; must be power of 2</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> mask = ~<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((s &gt;&gt;= <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mask ^= (mask &lt;&lt; s);</span><br><span class="line">        v = ((v &gt;&gt; s) &amp; mask) | ((v &lt;&lt; s) &amp; ~mask);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unsigned-long-dictScan-dict-d-unsigned-long-v-dictScanFunction-fn-void-privdata"><a href="#unsigned-long-dictScan-dict-d-unsigned-long-v-dictScanFunction-fn-void-privdata" class="headerlink" title="unsigned long dictScan(dict *d, unsigned long v, dictScanFunction *fn, void *privdata);"></a><code>unsigned long dictScan(dict *d, unsigned long v, dictScanFunction *fn, void *privdata);</code></h3><h4 id="功能-28"><a href="#功能-28" class="headerlink" title="功能"></a>功能</h4><p>dict的scan迭代操作<br>防止命令阻塞<br>无状态,无额外内存占用的遍历<br>(没太明白,后面有时间仔细看看)</p>
<h4 id="源码-28"><a href="#源码-28" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* dictScan() is used to iterate over the elements of a dictionary.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Iterating works the following way:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1) Initially you call the function using a cursor (v) value of 0.</span></span><br><span class="line"><span class="comment"> * 2) The function performs one step of the iteration, and returns the</span></span><br><span class="line"><span class="comment"> *    new cursor value you must use in the next call.</span></span><br><span class="line"><span class="comment"> * 3) When the returned cursor is 0, the iteration is complete.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function guarantees all elements present in the</span></span><br><span class="line"><span class="comment"> * dictionary get returned between the start and end of the iteration.</span></span><br><span class="line"><span class="comment"> * However it is possible some elements get returned multiple times.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For every element returned, the callback argument &#x27;fn&#x27; is</span></span><br><span class="line"><span class="comment"> * called with &#x27;privdata&#x27; as first argument and the dictionary entry</span></span><br><span class="line"><span class="comment"> * &#x27;de&#x27; as second argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * HOW IT WORKS.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The iteration algorithm was designed by Pieter Noordhuis.</span></span><br><span class="line"><span class="comment"> * The main idea is to increment a cursor starting from the higher order</span></span><br><span class="line"><span class="comment"> * bits. That is, instead of incrementing the cursor normally, the bits</span></span><br><span class="line"><span class="comment"> * of the cursor are reversed, then the cursor is incremented, and finally</span></span><br><span class="line"><span class="comment"> * the bits are reversed again.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This strategy is needed because the hash table may be resized between</span></span><br><span class="line"><span class="comment"> * iteration calls.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * dict.c hash tables are always power of two in size, and they</span></span><br><span class="line"><span class="comment"> * use chaining, so the position of an element in a given table is given</span></span><br><span class="line"><span class="comment"> * by computing the bitwise AND between Hash(key) and SIZE-1</span></span><br><span class="line"><span class="comment"> * (where SIZE-1 is always the mask that is equivalent to taking the rest</span></span><br><span class="line"><span class="comment"> *  of the division between the Hash of the key and SIZE).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For example if the current hash table size is 16, the mask is</span></span><br><span class="line"><span class="comment"> * (in binary) 1111. The position of a key in the hash table will always be</span></span><br><span class="line"><span class="comment"> * the last four bits of the hash output, and so forth.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * WHAT HAPPENS IF THE TABLE CHANGES IN SIZE?</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the hash table grows, elements can go anywhere in one multiple of</span></span><br><span class="line"><span class="comment"> * the old bucket: for example let&#x27;s say we already iterated with</span></span><br><span class="line"><span class="comment"> * a 4 bit cursor 1100 (the mask is 1111 because hash table size = 16).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the hash table will be resized to 64 elements, then the new mask will</span></span><br><span class="line"><span class="comment"> * be 111111. The new buckets you obtain by substituting in ??1100</span></span><br><span class="line"><span class="comment"> * with either 0 or 1 can be targeted only by keys we already visited</span></span><br><span class="line"><span class="comment"> * when scanning the bucket 1100 in the smaller hash table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * By iterating the higher bits first, because of the inverted counter, the</span></span><br><span class="line"><span class="comment"> * cursor does not need to restart if the table size gets bigger. It will</span></span><br><span class="line"><span class="comment"> * continue iterating using cursors without &#x27;1100&#x27; at the end, and also</span></span><br><span class="line"><span class="comment"> * without any other combination of the final 4 bits already explored.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Similarly when the table size shrinks over time, for example going from</span></span><br><span class="line"><span class="comment"> * 16 to 8, if a combination of the lower three bits (the mask for size 8</span></span><br><span class="line"><span class="comment"> * is 111) were already completely explored, it would not be visited again</span></span><br><span class="line"><span class="comment"> * because we are sure we tried, for example, both 0111 and 1111 (all the</span></span><br><span class="line"><span class="comment"> * variations of the higher bit) so we don&#x27;t need to test it again.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * WAIT... YOU HAVE *TWO* TABLES DURING REHASHING!</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Yes, this is true, but we always iterate the smaller table first, then</span></span><br><span class="line"><span class="comment"> * we test all the expansions of the current cursor into the larger</span></span><br><span class="line"><span class="comment"> * table. For example if the current cursor is 101 and we also have a</span></span><br><span class="line"><span class="comment"> * larger table of size 16, we also test (0)101 and (1)101 inside the larger</span></span><br><span class="line"><span class="comment"> * table. This reduces the problem back to having only one table, where</span></span><br><span class="line"><span class="comment"> * the larger one, if it exists, is just an expansion of the smaller one.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * LIMITATIONS</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This iterator is completely stateless, and this is a huge advantage,</span></span><br><span class="line"><span class="comment"> * including no additional memory used.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The disadvantages resulting from this design are:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1) It is possible we return elements more than once. However this is usually</span></span><br><span class="line"><span class="comment"> *    easy to deal with in the application level.</span></span><br><span class="line"><span class="comment"> * 2) The iterator must return multiple elements per call, as it needs to always</span></span><br><span class="line"><span class="comment"> *    return all the keys chained in a given bucket, and all the expansions, so</span></span><br><span class="line"><span class="comment"> *    we are sure we don&#x27;t miss keys moving during rehashing.</span></span><br><span class="line"><span class="comment"> * 3) The reverse cursor is somewhat hard to understand at first, but this</span></span><br><span class="line"><span class="comment"> *    comment is supposed to help.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">dictScan</span><span class="params">(dict *d,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">unsigned</span> <span class="keyword">long</span> v,</span></span></span><br><span class="line"><span class="function"><span class="params">                       dictScanFunction *fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> *privdata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictht *t0, *t1;</span><br><span class="line">    <span class="keyword">const</span> dictEntry *de;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> m0, m1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) &#123;</span><br><span class="line">        t0 = &amp;(d-&gt;ht[<span class="number">0</span>]);</span><br><span class="line">        m0 = t0-&gt;sizemask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">        de = t0-&gt;table[v &amp; m0];</span><br><span class="line">        <span class="keyword">while</span> (de) &#123;</span><br><span class="line">            fn(privdata, de);</span><br><span class="line">            de = de-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t0 = &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">        t1 = &amp;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Make sure t0 is the smaller and t1 is the bigger table */</span></span><br><span class="line">        <span class="keyword">if</span> (t0-&gt;size &gt; t1-&gt;size) &#123;</span><br><span class="line">            t0 = &amp;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">            t1 = &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m0 = t0-&gt;sizemask;</span><br><span class="line">        m1 = t1-&gt;sizemask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">        de = t0-&gt;table[v &amp; m0];</span><br><span class="line">        <span class="keyword">while</span> (de) &#123;</span><br><span class="line">            fn(privdata, de);</span><br><span class="line">            de = de-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Iterate over indices in larger table that are the expansion</span></span><br><span class="line"><span class="comment">         * of the index pointed to by the cursor in the smaller table */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">            de = t1-&gt;table[v &amp; m1];</span><br><span class="line">            <span class="keyword">while</span> (de) &#123;</span><br><span class="line">                fn(privdata, de);</span><br><span class="line">                de = de-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Increment bits not covered by the smaller mask */</span></span><br><span class="line">            v = (((v | m0) + <span class="number">1</span>) &amp; ~m0) | (v &amp; m0);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Continue while bits covered by mask difference is non-zero */</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (v &amp; (m0 ^ m1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set unmasked bits so incrementing the reversed cursor</span></span><br><span class="line"><span class="comment">     * operates on the masked bits of the smaller table */</span></span><br><span class="line">    v |= ~m0;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Increment the reverse cursor */</span></span><br><span class="line">    v = rev(v);</span><br><span class="line">    v++;</span><br><span class="line">    v = rev(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>redis</category>
        <category>source</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 源码分析-ziplist</title>
    <url>/2018/05/08/redis-source-ziplist/</url>
    <content><![CDATA[<p>ziplist本质上就是字符串数组<br>当存储元素数量&lt;UINT16_MAX时,可以直接读取长度<br>当存储元素数量&gt;=UINT16_MAX时,需要遍历整个ziplist才能获取长度<br>采用了不同的编码来对数字,字符串存储进行了压缩</p>
<ul>
<li>结构<br>  &lt;总字节数(4字节)&gt;&lt;最后一个元素的偏移量(从头开始算)(4字节)&gt;&lt;总元素个数(2字节)&gt;&lt;数据(不定字节)&gt;…&lt;0xFF结尾标记(1字节)&gt;</li>
<li>数据的结构<ul>
<li>头<ul>
<li>前一个数据的编码类型和长度<ul>
<li>当长度小于0xFE时,是一个字节</li>
<li>当长度大于等于0xFE时,是5个字节(第一个字节+4个字节的长度信息)</li>
</ul>
</li>
<li>当前数据的编码类型和长度<br>  第一个字节的前两位<ul>
<li>字符串<ul>
<li>00??????<br>  数据头总共占用一个字节<br>  后六位表示字符串长度</li>
<li>01??????|????????<br>  数据头总共占用两个字节<br>  后14位表示字符串长度</li>
<li>10______|????????|????????|????????|????????<br>  数据头总共占用5个字节<br>  后4个字节表示字符串长度</li>
</ul>
</li>
<li>数字<ul>
<li>11000000<br>  表示int16_t<br>  后面两个字节为具体数据</li>
<li>11010000<br>  表示int32_t<br>  后面4个字节为具体数据</li>
<li>11100000<br>  表示int64_t<br>  后面8个字节为具体数据</li>
<li>11110000<br>  表示int24_t<br>  后面3个字节为具体数据</li>
<li>11111110<br>  表示int8_t<br>  后面1个字节为具体数据</li>
<li>11110001-11111101<br>  直接表示0-12的值<br>  后面没有数据<br>  值直接就在当前字节中<br>  其中<br>  11110001    0<br>  11110010    1<br>  …<br>  11111101    12<br>  就是字节后4位的值直接转化为整数<br>  然后-1所得的值<br>  结尾不是1110是因为1110为int8_t<br>  结尾不是1111是因为1111为ziplist结尾标记</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>数据<br>  根据数据长度定义的连续字符串</li>
</ul>
</li>
</ul>
<h2 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h2><ul>
<li>ziplist.h</li>
<li>ziplist.c<a id="more"></a>

</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zlentry</span> &#123;</span> <span class="comment">// ziplist的单个entry元素结构体</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevrawlensize, prevrawlen; <span class="comment">// 前一个元素的长度的编码长度,前一个元素的长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lensize, len; <span class="comment">// 当前元素的长度编码的长度,当前元素的长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> headersize; <span class="comment">// prevrawlensize+lensize的值(就是从元素开始到该元素数据记录开始的字节数)(长度值是编码的数据)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding; <span class="comment">// 当前元素所使用的编码类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p; <span class="comment">// 数据(是头指针,不是数据指针,就是从前一个元素的长度那里开始的指针)</span></span><br><span class="line">&#125; zlentry;</span><br></pre></td></tr></table></figure>

<h2 id="主要宏"><a href="#主要宏" class="headerlink" title="主要宏"></a>主要宏</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_END 255</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_BIGLEN 254</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Different encoding/length possibilities */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_STR_MASK 0xc0 <span class="comment">// 就是11000000</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_MASK 0x30 <span class="comment">// 就是00110000</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_STR_06B (0 &lt;&lt; 6) <span class="comment">// 判断类型用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_STR_14B (1 &lt;&lt; 6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_STR_32B (2 &lt;&lt; 6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_16B (0xc0 | 0&lt;&lt;4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_32B (0xc0 | 1&lt;&lt;4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_64B (0xc0 | 2&lt;&lt;4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_24B (0xc0 | 3&lt;&lt;4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_8B 0xfe</span></span><br><span class="line"><span class="comment">/* 4 bit integer immediate encoding */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_IMM_MASK 0x0f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_IMM_MIN 0xf1    <span class="comment">/* 11110001 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_IMM_MAX 0xfd    <span class="comment">/* 11111101 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_INT_IMM_VAL(v) (v &amp; ZIP_INT_IMM_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT24_MAX 0x7fffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT24_MIN (-INT24_MAX - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Macro to determine type */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_IS_STR(enc) (((enc) &amp; ZIP_STR_MASK) &lt; ZIP_STR_MASK) <span class="comment">// 判断编码是否是字符串</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Utility macros */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl))) <span class="comment">// 获取ziplist的字节数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t)))) <span class="comment">// 获取ziplist的最后一个元素的偏移值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2))) <span class="comment">// 获取ziplist的元素个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t)) <span class="comment">// ziplist的头的字节数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_END_SIZE        (sizeof(uint8_t)) <span class="comment">// ziplist的结尾的字节数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_ENTRY_HEAD(zl)  ((zl)+ZIPLIST_HEADER_SIZE) <span class="comment">// 获取ziplist的第一个元素</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_ENTRY_TAIL(zl)  ((zl)+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))) <span class="comment">// 获取ziplist的最后一个元素</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_ENTRY_END(zl)   ((zl)+intrev32ifbe(ZIPLIST_BYTES(zl))-1) <span class="comment">// 获取ziplist的结尾的指针</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* We know a positive increment can only be 1 because entries can only be</span></span><br><span class="line"><span class="comment"> * pushed one at a time. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_INCR_LENGTH(zl,incr) &#123; \ <span class="comment">// 增加ziplist的元素个数</span></span></span><br><span class="line">    <span class="keyword">if</span> (ZIPLIST_LENGTH(zl) &lt; UINT16_MAX) \</span><br><span class="line">        ZIPLIST_LENGTH(zl) = intrev16ifbe(intrev16ifbe(ZIPLIST_LENGTH(zl))+incr); \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_ENTRY_ZERO(zle) &#123; \ <span class="comment">// 将元素置空</span></span></span><br><span class="line">    (zle)-&gt;prevrawlensize = (zle)-&gt;prevrawlen = <span class="number">0</span>; \</span><br><span class="line">    (zle)-&gt;lensize = (zle)-&gt;len = (zle)-&gt;headersize = <span class="number">0</span>; \</span><br><span class="line">    (zle)-&gt;encoding = <span class="number">0</span>; \</span><br><span class="line">    (zle)-&gt;p = <span class="literal">NULL</span>; \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Extract the encoding from the byte pointed by &#x27;ptr&#x27; and set it into</span></span><br><span class="line"><span class="comment"> * &#x27;encoding&#x27;. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_ENTRY_ENCODING(ptr, encoding) do &#123;  \ <span class="comment">// 获取元素编码</span></span></span><br><span class="line">    (encoding) = (ptr[<span class="number">0</span>]); \</span><br><span class="line">    <span class="keyword">if</span> ((encoding) &lt; ZIP_STR_MASK) (encoding) &amp;= ZIP_STR_MASK; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Decode the length encoded in &#x27;ptr&#x27;. The &#x27;encoding&#x27; variable will hold the</span></span><br><span class="line"><span class="comment"> * entries encoding, the &#x27;lensize&#x27; variable will hold the number of bytes</span></span><br><span class="line"><span class="comment"> * required to encode the entries length, and the &#x27;len&#x27; variable will hold the</span></span><br><span class="line"><span class="comment"> * entries length. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_DECODE_LENGTH(ptr, encoding, lensize, len) do &#123;                    \ <span class="comment">// 根据编码获取到元素长度占用字节和元素长度</span></span></span><br><span class="line">    ZIP_ENTRY_ENCODING((ptr), (encoding));                                     \</span><br><span class="line">    <span class="keyword">if</span> ((encoding) &lt; ZIP_STR_MASK) &#123;                                           \</span><br><span class="line">        <span class="keyword">if</span> ((encoding) == ZIP_STR_06B) &#123;                                       \</span><br><span class="line">            (lensize) = <span class="number">1</span>;                                                     \</span><br><span class="line">            (len) = (ptr)[<span class="number">0</span>] &amp; <span class="number">0x3f</span>;                                           \</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((encoding) == ZIP_STR_14B) &#123;                                \</span><br><span class="line">            (lensize) = <span class="number">2</span>;                                                     \</span><br><span class="line">            (len) = (((ptr)[<span class="number">0</span>] &amp; <span class="number">0x3f</span>) &lt;&lt; <span class="number">8</span>) | (ptr)[<span class="number">1</span>];                       \</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_STR_32B) &#123;                                  \</span><br><span class="line">            (lensize) = <span class="number">5</span>;                                                     \</span><br><span class="line">            (len) = ((ptr)[<span class="number">1</span>] &lt;&lt; <span class="number">24</span>) |                                         \</span><br><span class="line">                    ((ptr)[<span class="number">2</span>] &lt;&lt; <span class="number">16</span>) |                                         \</span><br><span class="line">                    ((ptr)[<span class="number">3</span>] &lt;&lt;  <span class="number">8</span>) |                                         \</span><br><span class="line">                    ((ptr)[<span class="number">4</span>]);                                                \</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                                                               \</span><br><span class="line">            assert(<span class="literal">NULL</span>);                                                      \</span><br><span class="line">        &#125;                                                                      \</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                                                   \</span><br><span class="line">        (lensize) = <span class="number">1</span>;                                                         \</span><br><span class="line">        (len) = zipIntSize(encoding);                                          \</span><br><span class="line">    &#125;                                                                          \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Decode the number of bytes required to store the length of the previous</span></span><br><span class="line"><span class="comment"> * element, from the perspective of the entry pointed to by &#x27;ptr&#x27;. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_DECODE_PREVLENSIZE(ptr, prevlensize) do &#123;                          \ <span class="comment">// 获取前一个元素的长度记录的字节数</span></span></span><br><span class="line">    <span class="keyword">if</span> ((ptr)[<span class="number">0</span>] &lt; ZIP_BIGLEN) &#123;                                               \</span><br><span class="line">        (prevlensize) = <span class="number">1</span>;                                                     \</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                                                   \</span><br><span class="line">        (prevlensize) = <span class="number">5</span>;                                                     \</span><br><span class="line">    &#125;                                                                          \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Decode the length of the previous element, from the perspective of the entry</span></span><br><span class="line"><span class="comment"> * pointed to by &#x27;ptr&#x27;. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIP_DECODE_PREVLEN(ptr, prevlensize, prevlen) do &#123;                     \ <span class="comment">// 获取前一个元素的长度记录的字节数和前一个元素的数据长度</span></span></span><br><span class="line">    ZIP_DECODE_PREVLENSIZE(ptr, prevlensize);                                  \</span><br><span class="line">    <span class="keyword">if</span> ((prevlensize) == <span class="number">1</span>) &#123;                                                  \</span><br><span class="line">        (prevlen) = (ptr)[<span class="number">0</span>];                                                  \</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((prevlensize) == <span class="number">5</span>) &#123;                                           \</span><br><span class="line">        assert(<span class="keyword">sizeof</span>((prevlensize)) == <span class="number">4</span>);                                    \</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;(prevlen), ((<span class="keyword">char</span>*)(ptr)) + <span class="number">1</span>, <span class="number">4</span>);                             \</span><br><span class="line">        memrev32ifbe(&amp;prevlen);                                                \</span><br><span class="line">    &#125;                                                                          \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h2 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h2><h3 id="unsigned-int-zipIntSize-unsigned-char-encoding"><a href="#unsigned-int-zipIntSize-unsigned-char-encoding" class="headerlink" title="unsigned int zipIntSize(unsigned char encoding);"></a><code>unsigned int zipIntSize(unsigned char encoding);</code></h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>根据编码获取编码占用字节数</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Return bytes needed to store integer encoded by &#x27;encoding&#x27; */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipIntSize</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> encoding)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(encoding) &#123;</span><br><span class="line">    <span class="keyword">case</span> ZIP_INT_8B:  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> ZIP_INT_16B: <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">case</span> ZIP_INT_24B: <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">case</span> ZIP_INT_32B: <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">case</span> ZIP_INT_64B: <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* 4 bit immediate */</span></span><br><span class="line">    &#125;</span><br><span class="line">    assert(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unsigned-int-zipEncodeLength-unsigned-char-p-unsigned-char-encoding-unsigned-int-rawlen"><a href="#unsigned-int-zipEncodeLength-unsigned-char-p-unsigned-char-encoding-unsigned-int-rawlen" class="headerlink" title="unsigned int zipEncodeLength(unsigned char *p, unsigned char encoding, unsigned int rawlen);"></a><code>unsigned int zipEncodeLength(unsigned char *p, unsigned char encoding, unsigned int rawlen);</code></h3><h4 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h4><p>设置编码,长度到ziplist中</p>
<h4 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Encode the length &#x27;rawlen&#x27; writing it in &#x27;p&#x27;. If p is NULL it just returns</span></span><br><span class="line"><span class="comment"> * the amount of bytes required to encode such a length. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipEncodeLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding, <span class="keyword">unsigned</span> <span class="keyword">int</span> rawlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> len = <span class="number">1</span>, buf[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class="line">        <span class="comment">/* Although encoding is given it may not be set for strings,</span></span><br><span class="line"><span class="comment">         * so we determine it here using the raw length. */</span></span><br><span class="line">        <span class="keyword">if</span> (rawlen &lt;= <span class="number">0x3f</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!p) <span class="keyword">return</span> len;</span><br><span class="line">            buf[<span class="number">0</span>] = ZIP_STR_06B | rawlen;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rawlen &lt;= <span class="number">0x3fff</span>) &#123;</span><br><span class="line">            len += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!p) <span class="keyword">return</span> len;</span><br><span class="line">            buf[<span class="number">0</span>] = ZIP_STR_14B | ((rawlen &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x3f</span>);</span><br><span class="line">            buf[<span class="number">1</span>] = rawlen &amp; <span class="number">0xff</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len += <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">if</span> (!p) <span class="keyword">return</span> len;</span><br><span class="line">            buf[<span class="number">0</span>] = ZIP_STR_32B;</span><br><span class="line">            buf[<span class="number">1</span>] = (rawlen &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            buf[<span class="number">2</span>] = (rawlen &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            buf[<span class="number">3</span>] = (rawlen &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            buf[<span class="number">4</span>] = rawlen &amp; <span class="number">0xff</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Implies integer encoding, so length is always 1. */</span></span><br><span class="line">        <span class="keyword">if</span> (!p) <span class="keyword">return</span> len;</span><br><span class="line">        buf[<span class="number">0</span>] = encoding;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Store this length at p */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(p,buf,len);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unsigned-int-zipPrevEncodeLength-unsigned-char-p-unsigned-int-len"><a href="#unsigned-int-zipPrevEncodeLength-unsigned-char-p-unsigned-int-len" class="headerlink" title="unsigned int zipPrevEncodeLength(unsigned char *p, unsigned int len);"></a><code>unsigned int zipPrevEncodeLength(unsigned char *p, unsigned int len);</code></h3><h4 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h4><p>设置前一个元素的长度到数据中<br>当p为NULL时直接返回需要存储该长度需要的字节数</p>
<h4 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Encode the length of the previous entry and write it to &quot;p&quot;. Return the</span></span><br><span class="line"><span class="comment"> * number of bytes needed to encode this length if &quot;p&quot; is NULL. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipPrevEncodeLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (len &lt; ZIP_BIGLEN) ? <span class="number">1</span> : <span class="keyword">sizeof</span>(len)+<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; ZIP_BIGLEN) &#123;</span><br><span class="line">            p[<span class="number">0</span>] = len;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p[<span class="number">0</span>] = ZIP_BIGLEN;</span><br><span class="line">            <span class="built_in">memcpy</span>(p+<span class="number">1</span>,&amp;len,<span class="keyword">sizeof</span>(len));</span><br><span class="line">            memrev32ifbe(p+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+<span class="keyword">sizeof</span>(len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void-zipPrevEncodeLengthForceLarge-unsigned-char-p-unsigned-int-len"><a href="#void-zipPrevEncodeLengthForceLarge-unsigned-char-p-unsigned-int-len" class="headerlink" title="void zipPrevEncodeLengthForceLarge(unsigned char *p, unsigned int len);"></a><code>void zipPrevEncodeLengthForceLarge(unsigned char *p, unsigned int len);</code></h3><h4 id="功能-3"><a href="#功能-3" class="headerlink" title="功能"></a>功能</h4><p>强制使用5个字节的长度标记记录前一个字节的长度信息</p>
<h4 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Encode the length of the previous entry and write it to &quot;p&quot;. This only</span></span><br><span class="line"><span class="comment"> * uses the larger encoding (required in __ziplistCascadeUpdate). */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zipPrevEncodeLengthForceLarge</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    p[<span class="number">0</span>] = ZIP_BIGLEN;</span><br><span class="line">    <span class="built_in">memcpy</span>(p+<span class="number">1</span>,&amp;len,<span class="keyword">sizeof</span>(len));</span><br><span class="line">    memrev32ifbe(p+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int-zipPrevLenByteDiff-unsigned-char-p-unsigned-int-len"><a href="#int-zipPrevLenByteDiff-unsigned-char-p-unsigned-int-len" class="headerlink" title="int zipPrevLenByteDiff(unsigned char *p, unsigned int len);"></a><code>int zipPrevLenByteDiff(unsigned char *p, unsigned int len);</code></h3><h4 id="功能-4"><a href="#功能-4" class="headerlink" title="功能"></a>功能</h4><p>获取到要存储len长度的数据需要的字节数和前一个元素当前存储长度所用的字节数的差值</p>
<h4 id="源码-4"><a href="#源码-4" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Return the difference in number of bytes needed to store the length of the</span></span><br><span class="line"><span class="comment"> * previous element &#x27;len&#x27;, in the entry pointed to by &#x27;p&#x27;. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zipPrevLenByteDiff</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevlensize;</span><br><span class="line">    ZIP_DECODE_PREVLENSIZE(p, prevlensize);</span><br><span class="line">    <span class="keyword">return</span> zipPrevEncodeLength(<span class="literal">NULL</span>, len) - prevlensize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unsigned-int-zipRawEntryLength-unsigned-char-p"><a href="#unsigned-int-zipRawEntryLength-unsigned-char-p" class="headerlink" title="unsigned int zipRawEntryLength(unsigned char *p);"></a><code>unsigned int zipRawEntryLength(unsigned char *p);</code></h3><h4 id="功能-5"><a href="#功能-5" class="headerlink" title="功能"></a>功能</h4><p>获取到元素的整体长度<br>前一个元素的长度+当前元素的长度+当前元素的数据长度</p>
<h4 id="源码-5"><a href="#源码-5" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Return the total number of bytes used by the entry pointed to by &#x27;p&#x27;. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">zipRawEntryLength</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevlensize, encoding, lensize, len;</span><br><span class="line">    ZIP_DECODE_PREVLENSIZE(p, prevlensize);</span><br><span class="line">    ZIP_DECODE_LENGTH(p + prevlensize, encoding, lensize, len);</span><br><span class="line">    <span class="keyword">return</span> prevlensize + lensize + len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int-zipTryEncoding-unsigned-char-entry-unsigned-int-entrylen-long-long-v-unsigned-char-encoding"><a href="#int-zipTryEncoding-unsigned-char-entry-unsigned-int-entrylen-long-long-v-unsigned-char-encoding" class="headerlink" title="int zipTryEncoding(unsigned char *entry, unsigned int entrylen, long long *v, unsigned char *encoding);"></a><code>int zipTryEncoding(unsigned char *entry, unsigned int entrylen, long long *v, unsigned char *encoding);</code></h3><h4 id="功能-6"><a href="#功能-6" class="headerlink" title="功能"></a>功能</h4><p>将字符串转化为数字,并将可以存储该数字的编码格式返回</p>
<h4 id="源码-6"><a href="#源码-6" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Check if string pointed to by &#x27;entry&#x27; can be encoded as an integer.</span></span><br><span class="line"><span class="comment"> * Stores the integer value in &#x27;v&#x27; and its encoding in &#x27;encoding&#x27;. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zipTryEncoding</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *entry, <span class="keyword">unsigned</span> <span class="keyword">int</span> entrylen, <span class="keyword">long</span> <span class="keyword">long</span> *v, <span class="keyword">unsigned</span> <span class="keyword">char</span> *encoding)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (entrylen &gt;= <span class="number">32</span> || entrylen == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (string2ll((<span class="keyword">char</span>*)entry,entrylen,&amp;value)) &#123;</span><br><span class="line">        <span class="comment">/* Great, the string can be encoded. Check what&#x27;s the smallest</span></span><br><span class="line"><span class="comment">         * of our encoding types that can hold this value. */</span></span><br><span class="line">        <span class="keyword">if</span> (value &gt;= <span class="number">0</span> &amp;&amp; value &lt;= <span class="number">12</span>) &#123;</span><br><span class="line">            *encoding = ZIP_INT_IMM_MIN+value;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= INT8_MIN &amp;&amp; value &lt;= INT8_MAX) &#123;</span><br><span class="line">            *encoding = ZIP_INT_8B;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= INT16_MIN &amp;&amp; value &lt;= INT16_MAX) &#123;</span><br><span class="line">            *encoding = ZIP_INT_16B;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= INT24_MIN &amp;&amp; value &lt;= INT24_MAX) &#123;</span><br><span class="line">            *encoding = ZIP_INT_24B;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= INT32_MIN &amp;&amp; value &lt;= INT32_MAX) &#123;</span><br><span class="line">            *encoding = ZIP_INT_32B;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *encoding = ZIP_INT_64B;</span><br><span class="line">        &#125;</span><br><span class="line">        *v = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void-zipSaveInteger-unsigned-char-p-int64-t-value-unsigned-char-encoding"><a href="#void-zipSaveInteger-unsigned-char-p-int64-t-value-unsigned-char-encoding" class="headerlink" title="void zipSaveInteger(unsigned char *p, int64_t value, unsigned char encoding);"></a><code>void zipSaveInteger(unsigned char *p, int64_t value, unsigned char encoding);</code></h3><h4 id="功能-7"><a href="#功能-7" class="headerlink" title="功能"></a>功能</h4><p>根据编码格式将值存储在字符数组中</p>
<h4 id="源码-7"><a href="#源码-7" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Store integer &#x27;value&#x27; at &#x27;p&#x27;, encoded as &#x27;encoding&#x27; */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zipSaveInteger</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">int64_t</span> value, <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int16_t</span> i16;</span><br><span class="line">    <span class="keyword">int32_t</span> i32;</span><br><span class="line">    <span class="keyword">int64_t</span> i64;</span><br><span class="line">    <span class="keyword">if</span> (encoding == ZIP_INT_8B) &#123;</span><br><span class="line">        ((<span class="keyword">int8_t</span>*)p)[<span class="number">0</span>] = (<span class="keyword">int8_t</span>)value;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_INT_16B) &#123;</span><br><span class="line">        i16 = value;</span><br><span class="line">        <span class="built_in">memcpy</span>(p,&amp;i16,<span class="keyword">sizeof</span>(i16));</span><br><span class="line">        memrev16ifbe(p);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_INT_24B) &#123;</span><br><span class="line">        i32 = value&lt;&lt;<span class="number">8</span>;</span><br><span class="line">        memrev32ifbe(&amp;i32);</span><br><span class="line">        <span class="built_in">memcpy</span>(p,((<span class="keyword">uint8_t</span>*)&amp;i32)+<span class="number">1</span>,<span class="keyword">sizeof</span>(i32)-<span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_INT_32B) &#123;</span><br><span class="line">        i32 = value;</span><br><span class="line">        <span class="built_in">memcpy</span>(p,&amp;i32,<span class="keyword">sizeof</span>(i32));</span><br><span class="line">        memrev32ifbe(p);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_INT_64B) &#123;</span><br><span class="line">        i64 = value;</span><br><span class="line">        <span class="built_in">memcpy</span>(p,&amp;i64,<span class="keyword">sizeof</span>(i64));</span><br><span class="line">        memrev64ifbe(p);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding &gt;= ZIP_INT_IMM_MIN &amp;&amp; encoding &lt;= ZIP_INT_IMM_MAX) &#123;</span><br><span class="line">        <span class="comment">/* Nothing to do, the value is stored in the encoding itself. */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int64-t-zipLoadInteger-unsigned-char-p-unsigned-char-encoding"><a href="#int64-t-zipLoadInteger-unsigned-char-p-unsigned-char-encoding" class="headerlink" title="int64_t zipLoadInteger(unsigned char *p, unsigned char encoding);"></a><code>int64_t zipLoadInteger(unsigned char *p, unsigned char encoding);</code></h3><h4 id="功能-8"><a href="#功能-8" class="headerlink" title="功能"></a>功能</h4><p>根据编码读取数字数据</p>
<h4 id="源码-8"><a href="#源码-8" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Read integer encoded as &#x27;encoding&#x27; from &#x27;p&#x27; */</span></span><br><span class="line"><span class="function"><span class="keyword">int64_t</span> <span class="title">zipLoadInteger</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int16_t</span> i16;</span><br><span class="line">    <span class="keyword">int32_t</span> i32;</span><br><span class="line">    <span class="keyword">int64_t</span> i64, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (encoding == ZIP_INT_8B) &#123;</span><br><span class="line">        ret = ((<span class="keyword">int8_t</span>*)p)[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_INT_16B) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;i16,p,<span class="keyword">sizeof</span>(i16));</span><br><span class="line">        memrev16ifbe(&amp;i16);</span><br><span class="line">        ret = i16;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_INT_32B) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;i32,p,<span class="keyword">sizeof</span>(i32));</span><br><span class="line">        memrev32ifbe(&amp;i32);</span><br><span class="line">        ret = i32;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_INT_24B) &#123;</span><br><span class="line">        i32 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(((<span class="keyword">uint8_t</span>*)&amp;i32)+<span class="number">1</span>,p,<span class="keyword">sizeof</span>(i32)-<span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br><span class="line">        memrev32ifbe(&amp;i32);</span><br><span class="line">        ret = i32&gt;&gt;<span class="number">8</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == ZIP_INT_64B) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;i64,p,<span class="keyword">sizeof</span>(i64));</span><br><span class="line">        memrev64ifbe(&amp;i64);</span><br><span class="line">        ret = i64;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding &gt;= ZIP_INT_IMM_MIN &amp;&amp; encoding &lt;= ZIP_INT_IMM_MAX) &#123;</span><br><span class="line">        ret = (encoding &amp; ZIP_INT_IMM_MASK)<span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="void-zipEntry-unsigned-char-p-zlentry-e"><a href="#void-zipEntry-unsigned-char-p-zlentry-e" class="headerlink" title="void zipEntry(unsigned char *p, zlentry *e);"></a><code>void zipEntry(unsigned char *p, zlentry *e);</code></h3><h4 id="功能-9"><a href="#功能-9" class="headerlink" title="功能"></a>功能</h4><p>读取一个完整的zlentry</p>
<h4 id="源码-9"><a href="#源码-9" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Return a struct with all information about an entry. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zipEntry</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, zlentry *e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ZIP_DECODE_PREVLEN(p, e-&gt;prevrawlensize, e-&gt;prevrawlen);</span><br><span class="line">    ZIP_DECODE_LENGTH(p + e-&gt;prevrawlensize, e-&gt;encoding, e-&gt;lensize, e-&gt;len);</span><br><span class="line">    e-&gt;headersize = e-&gt;prevrawlensize + e-&gt;lensize;</span><br><span class="line">    e-&gt;p = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unsigned-char-ziplistNew-void"><a href="#unsigned-char-ziplistNew-void" class="headerlink" title="unsigned char *ziplistNew(void);"></a><code>unsigned char *ziplistNew(void);</code></h3><h4 id="功能-10"><a href="#功能-10" class="headerlink" title="功能"></a>功能</h4><p>创建一个新的ziplist</p>
<h4 id="源码-10"><a href="#源码-10" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create a new empty ziplist. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bytes = ZIPLIST_HEADER_SIZE+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = zmalloc(bytes);</span><br><span class="line">    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);</span><br><span class="line">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);</span><br><span class="line">    ZIPLIST_LENGTH(zl) = <span class="number">0</span>;</span><br><span class="line">    zl[bytes<span class="number">-1</span>] = ZIP_END;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unsigned-char-ziplistResize-unsigned-char-zl-unsigned-int-len"><a href="#unsigned-char-ziplistResize-unsigned-char-zl-unsigned-int-len" class="headerlink" title="unsigned char *ziplistResize(unsigned char *zl, unsigned int len);"></a><code>unsigned char *ziplistResize(unsigned char *zl, unsigned int len);</code></h3><h4 id="功能-11"><a href="#功能-11" class="headerlink" title="功能"></a>功能</h4><p>ziplist重新分配内存大小</p>
<h4 id="源码-11"><a href="#源码-11" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Resize the ziplist. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistResize</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    zl = zrealloc(zl,len);</span><br><span class="line">    ZIPLIST_BYTES(zl) = intrev32ifbe(len);</span><br><span class="line">    zl[len<span class="number">-1</span>] = ZIP_END;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unsigned-char-ziplistCascadeUpdate-unsigned-char-zl-unsigned-char-p"><a href="#unsigned-char-ziplistCascadeUpdate-unsigned-char-zl-unsigned-char-p" class="headerlink" title="unsigned char *__ziplistCascadeUpdate(unsigned char *zl, unsigned char *p);"></a><code>unsigned char *__ziplistCascadeUpdate(unsigned char *zl, unsigned char *p);</code></h3><h4 id="功能-12"><a href="#功能-12" class="headerlink" title="功能"></a>功能</h4><p>插入新元素后,维护后续元素的前一个元素的尺寸接口</p>
<h4 id="源码-12"><a href="#源码-12" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* When an entry is inserted, we need to set the prevlen field of the next</span></span><br><span class="line"><span class="comment"> * entry to equal the length of the inserted entry. It can occur that this</span></span><br><span class="line"><span class="comment"> * length cannot be encoded in 1 byte and the next entry needs to be grow</span></span><br><span class="line"><span class="comment"> * a bit larger to hold the 5-byte encoded prevlen. This can be done for free,</span></span><br><span class="line"><span class="comment"> * because this only happens when an entry is already being inserted (which</span></span><br><span class="line"><span class="comment"> * causes a realloc and memmove). However, encoding the prevlen may require</span></span><br><span class="line"><span class="comment"> * that this entry is grown as well. This effect may cascade throughout</span></span><br><span class="line"><span class="comment"> * the ziplist when there are consecutive entries with a size close to</span></span><br><span class="line"><span class="comment"> * ZIP_BIGLEN, so we need to check that the prevlen can be encoded in every</span></span><br><span class="line"><span class="comment"> * consecutive entry.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that this effect can also happen in reverse, where the bytes required</span></span><br><span class="line"><span class="comment"> * to encode the prevlen field can shrink. This effect is deliberately ignored,</span></span><br><span class="line"><span class="comment"> * because it can cause a &quot;flapping&quot; effect where a chain prevlen fields is</span></span><br><span class="line"><span class="comment"> * first grown and then shrunk again after consecutive inserts. Rather, the</span></span><br><span class="line"><span class="comment"> * field is allowed to stay larger than necessary, because a large prevlen</span></span><br><span class="line"><span class="comment"> * field implies the ziplist is holding large entries anyway.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The pointer &quot;p&quot; points to the first entry that does NOT need to be</span></span><br><span class="line"><span class="comment"> * updated, i.e. consecutive fields MAY need an update. */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistCascadeUpdate(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), rawlen, rawlensize;</span><br><span class="line">    <span class="keyword">size_t</span> offset, noffset, extra;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *np;</span><br><span class="line">    zlentry cur, next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        zipEntry(p, &amp;cur);</span><br><span class="line">        rawlen = cur.headersize + cur.len;</span><br><span class="line">        rawlensize = zipPrevEncodeLength(<span class="literal">NULL</span>,rawlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Abort if there is no next entry. */</span></span><br><span class="line">        <span class="keyword">if</span> (p[rawlen] == ZIP_END) <span class="keyword">break</span>;</span><br><span class="line">        zipEntry(p+rawlen, &amp;next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Abort when &quot;prevlen&quot; has not changed. */</span></span><br><span class="line">        <span class="keyword">if</span> (next.prevrawlen == rawlen) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next.prevrawlensize &lt; rawlensize) &#123;</span><br><span class="line">            <span class="comment">/* The &quot;prevlen&quot; field of &quot;next&quot; needs more bytes to hold</span></span><br><span class="line"><span class="comment">             * the raw length of &quot;cur&quot;. */</span></span><br><span class="line">            offset = p-zl;</span><br><span class="line">            extra = rawlensize-next.prevrawlensize;</span><br><span class="line">            zl = ziplistResize(zl,curlen+extra);</span><br><span class="line">            p = zl+offset;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Current pointer and offset for next element. */</span></span><br><span class="line">            np = p+rawlen;</span><br><span class="line">            noffset = np-zl;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Update tail offset when next element is not the tail element. */</span></span><br><span class="line">            <span class="keyword">if</span> ((zl+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))) != np) &#123;</span><br><span class="line">                ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                    intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+extra);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Move the tail to the back. */</span></span><br><span class="line">            memmove(np+rawlensize,</span><br><span class="line">                np+next.prevrawlensize,</span><br><span class="line">                curlen-noffset-next.prevrawlensize<span class="number">-1</span>);</span><br><span class="line">            zipPrevEncodeLength(np,rawlen);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Advance the cursor */</span></span><br><span class="line">            p += rawlen;</span><br><span class="line">            curlen += extra;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (next.prevrawlensize &gt; rawlensize) &#123;</span><br><span class="line">                <span class="comment">/* This would result in shrinking, which we want to avoid.</span></span><br><span class="line"><span class="comment">                 * So, set &quot;rawlen&quot; in the available bytes. */</span></span><br><span class="line">                zipPrevEncodeLengthForceLarge(p+rawlen,rawlen);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                zipPrevEncodeLength(p+rawlen,rawlen);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Stop here, as the raw length of &quot;next&quot; has not changed. */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unsigned-char-ziplistDelete-unsigned-char-zl-unsigned-char-p-unsigned-int-num"><a href="#unsigned-char-ziplistDelete-unsigned-char-zl-unsigned-char-p-unsigned-int-num" class="headerlink" title="unsigned char *__ziplistDelete(unsigned char *zl, unsigned char *p, unsigned int num);"></a><code>unsigned char *__ziplistDelete(unsigned char *zl, unsigned char *p, unsigned int num);</code></h3><h4 id="功能-13"><a href="#功能-13" class="headerlink" title="功能"></a>功能</h4><p>从p开始删除num个元素</p>
<h4 id="源码-13"><a href="#源码-13" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Delete &quot;num&quot; entries, starting at &quot;p&quot;. Returns pointer to the ziplist. */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistDelete(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> num) &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i, totlen, deleted = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> offset;</span><br><span class="line">    <span class="keyword">int</span> nextdiff = <span class="number">0</span>;</span><br><span class="line">    zlentry first, tail;</span><br><span class="line"></span><br><span class="line">    zipEntry(p, &amp;first);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; p[<span class="number">0</span>] != ZIP_END &amp;&amp; i &lt; num; i++) &#123;</span><br><span class="line">        p += zipRawEntryLength(p);</span><br><span class="line">        deleted++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    totlen = p-first.p;</span><br><span class="line">    <span class="keyword">if</span> (totlen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">            <span class="comment">/* Storing `prevrawlen` in this entry may increase or decrease the</span></span><br><span class="line"><span class="comment">             * number of bytes required compare to the current `prevrawlen`.</span></span><br><span class="line"><span class="comment">             * There always is room to store this, because it was previously</span></span><br><span class="line"><span class="comment">             * stored by an entry that is now being deleted. */</span></span><br><span class="line">            nextdiff = zipPrevLenByteDiff(p,first.prevrawlen);</span><br><span class="line">            p -= nextdiff;</span><br><span class="line">            zipPrevEncodeLength(p,first.prevrawlen);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Update offset for tail */</span></span><br><span class="line">            ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))-totlen);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* When the tail contains more than one entry, we need to take</span></span><br><span class="line"><span class="comment">             * &quot;nextdiff&quot; in account as well. Otherwise, a change in the</span></span><br><span class="line"><span class="comment">             * size of prevlen doesn&#x27;t have an effect on the *tail* offset. */</span></span><br><span class="line">            zipEntry(p, &amp;tail);</span><br><span class="line">            <span class="keyword">if</span> (p[tail.headersize+tail.len] != ZIP_END) &#123;</span><br><span class="line">                ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                   intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Move tail to the front of the ziplist */</span></span><br><span class="line">            memmove(first.p,p,</span><br><span class="line">                intrev32ifbe(ZIPLIST_BYTES(zl))-(p-zl)<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* The entire tail was deleted. No need to move memory. */</span></span><br><span class="line">            ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                intrev32ifbe((first.p-zl)-first.prevrawlen);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Resize and update length */</span></span><br><span class="line">        offset = first.p-zl;</span><br><span class="line">        zl = ziplistResize(zl, intrev32ifbe(ZIPLIST_BYTES(zl))-totlen+nextdiff);</span><br><span class="line">        ZIPLIST_INCR_LENGTH(zl,-deleted);</span><br><span class="line">        p = zl+offset;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* When nextdiff != 0, the raw length of the next entry has changed, so</span></span><br><span class="line"><span class="comment">         * we need to cascade the update throughout the ziplist */</span></span><br><span class="line">        <span class="keyword">if</span> (nextdiff != <span class="number">0</span>)</span><br><span class="line">            zl = __ziplistCascadeUpdate(zl,p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unsigned-char-ziplistInsert-unsigned-char-zl-unsigned-char-p-unsigned-char-s-unsigned-int-slen"><a href="#unsigned-char-ziplistInsert-unsigned-char-zl-unsigned-char-p-unsigned-char-s-unsigned-int-slen" class="headerlink" title="unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen);"></a><code>unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen);</code></h3><h4 id="功能-14"><a href="#功能-14" class="headerlink" title="功能"></a>功能</h4><p>在p的位置插入元素</p>
<h4 id="源码-14"><a href="#源码-14" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Insert item at &quot;p&quot;. */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistInsert(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevlensize, prevlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> offset;</span><br><span class="line">    <span class="keyword">int</span> nextdiff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value = <span class="number">123456789</span>; <span class="comment">/* initialized to avoid warning. Using a value</span></span><br><span class="line"><span class="comment">                                    that is easy to see if for some reason</span></span><br><span class="line"><span class="comment">                                    we use it uninitialized. */</span></span><br><span class="line">    zlentry tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find out prevlen for the entry that is inserted. */</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptail = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class="line">        <span class="keyword">if</span> (ptail[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">            prevlen = zipRawEntryLength(ptail);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* See if the entry can be encoded */</span></span><br><span class="line">    <span class="keyword">if</span> (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;</span><br><span class="line">        <span class="comment">/* &#x27;encoding&#x27; is set to the appropriate integer encoding */</span></span><br><span class="line">        reqlen = zipIntSize(encoding);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* &#x27;encoding&#x27; is untouched, however zipEncodeLength will use the</span></span><br><span class="line"><span class="comment">         * string length to figure out how to encode it. */</span></span><br><span class="line">        reqlen = slen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We need space for both the length of the previous entry and</span></span><br><span class="line"><span class="comment">     * the length of the payload. */</span></span><br><span class="line">    reqlen += zipPrevEncodeLength(<span class="literal">NULL</span>,prevlen);</span><br><span class="line">    reqlen += zipEncodeLength(<span class="literal">NULL</span>,encoding,slen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When the insert position is not equal to the tail, we need to</span></span><br><span class="line"><span class="comment">     * make sure that the next entry can hold this entry&#x27;s length in</span></span><br><span class="line"><span class="comment">     * its prevlen field. */</span></span><br><span class="line">    <span class="keyword">int</span> forcelarge = <span class="number">0</span>;</span><br><span class="line">    nextdiff = (p[<span class="number">0</span>] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nextdiff == <span class="number">-4</span> &amp;&amp; reqlen &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        nextdiff = <span class="number">0</span>;</span><br><span class="line">        forcelarge = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Store offset because a realloc may change the address of zl. */</span></span><br><span class="line">    offset = p-zl;</span><br><span class="line">    zl = ziplistResize(zl,curlen+reqlen+nextdiff);</span><br><span class="line">    p = zl+offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Apply memory move when necessary and update tail offset. */</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        <span class="comment">/* Subtract one because of the ZIP_END bytes */</span></span><br><span class="line">        memmove(p+reqlen,p-nextdiff,curlen-offset<span class="number">-1</span>+nextdiff);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Encode this entry&#x27;s raw length in the next entry. */</span></span><br><span class="line">        <span class="keyword">if</span> (forcelarge)</span><br><span class="line">            zipPrevEncodeLengthForceLarge(p+reqlen,reqlen);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            zipPrevEncodeLength(p+reqlen,reqlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update offset for tail */</span></span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* When the tail contains more than one entry, we need to take</span></span><br><span class="line"><span class="comment">         * &quot;nextdiff&quot; in account as well. Otherwise, a change in the</span></span><br><span class="line"><span class="comment">         * size of prevlen doesn&#x27;t have an effect on the *tail* offset. */</span></span><br><span class="line">        zipEntry(p+reqlen, &amp;tail);</span><br><span class="line">        <span class="keyword">if</span> (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123;</span><br><span class="line">            ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* This element will be the new tail. */</span></span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When nextdiff != 0, the raw length of the next entry has changed, so</span></span><br><span class="line"><span class="comment">     * we need to cascade the update throughout the ziplist */</span></span><br><span class="line">    <span class="keyword">if</span> (nextdiff != <span class="number">0</span>) &#123;</span><br><span class="line">        offset = p-zl;</span><br><span class="line">        zl = __ziplistCascadeUpdate(zl,p+reqlen);</span><br><span class="line">        p = zl+offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write the entry */</span></span><br><span class="line">    p += zipPrevEncodeLength(p,prevlen);</span><br><span class="line">    p += zipEncodeLength(p,encoding,slen);</span><br><span class="line">    <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(p,s,slen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zipSaveInteger(p,value,encoding);</span><br><span class="line">    &#125;</span><br><span class="line">    ZIPLIST_INCR_LENGTH(zl,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unsigned-char-ziplistMerge-unsigned-char-first-unsigned-char-second"><a href="#unsigned-char-ziplistMerge-unsigned-char-first-unsigned-char-second" class="headerlink" title="unsigned char *ziplistMerge(unsigned char **first, unsigned char **second);"></a><code>unsigned char *ziplistMerge(unsigned char **first, unsigned char **second);</code></h3><h4 id="功能-15"><a href="#功能-15" class="headerlink" title="功能"></a>功能</h4><p>合并两个ziplist,返回新的ziplist</p>
<h4 id="源码-15"><a href="#源码-15" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Merge ziplists &#x27;first&#x27; and &#x27;second&#x27; by appending &#x27;second&#x27; to &#x27;first&#x27;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> The larger ziplist is reallocated to contain the new merged ziplist.</span></span><br><span class="line"><span class="comment"> * Either &#x27;first&#x27; or &#x27;second&#x27; can be used for the result.  The parameter not</span></span><br><span class="line"><span class="comment"> * used will be free&#x27;d and set to NULL.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * After calling this function, the input parameters are no longer valid since</span></span><br><span class="line"><span class="comment"> * they are changed and free&#x27;d in-place.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The result ziplist is the contents of &#x27;first&#x27; followed by &#x27;second&#x27;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On failure: returns NULL if the merge is impossible.</span></span><br><span class="line"><span class="comment"> * On success: returns the merged ziplist (which is expanded version of either</span></span><br><span class="line"><span class="comment"> * &#x27;first&#x27; or &#x27;second&#x27;, also frees the other unused input ziplist, and sets the</span></span><br><span class="line"><span class="comment"> * input ziplist argument equal to newly reallocated ziplist return value. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistMerge</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> **first, <span class="keyword">unsigned</span> <span class="keyword">char</span> **second)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* If any params are null, we can&#x27;t merge, so NULL. */</span></span><br><span class="line">    <span class="keyword">if</span> (first == <span class="literal">NULL</span> || *first == <span class="literal">NULL</span> || second == <span class="literal">NULL</span> || *second == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Can&#x27;t merge same list into itself. */</span></span><br><span class="line">    <span class="keyword">if</span> (*first == *second)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> first_bytes = intrev32ifbe(ZIPLIST_BYTES(*first));</span><br><span class="line">    <span class="keyword">size_t</span> first_len = intrev16ifbe(ZIPLIST_LENGTH(*first));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> second_bytes = intrev32ifbe(ZIPLIST_BYTES(*second));</span><br><span class="line">    <span class="keyword">size_t</span> second_len = intrev16ifbe(ZIPLIST_LENGTH(*second));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> append;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *source, *target;</span><br><span class="line">    <span class="keyword">size_t</span> target_bytes, source_bytes;</span><br><span class="line">    <span class="comment">/* Pick the largest ziplist so we can resize easily in-place.</span></span><br><span class="line"><span class="comment">     * We must also track if we are now appending or prepending to</span></span><br><span class="line"><span class="comment">     * the target ziplist. */</span></span><br><span class="line">    <span class="keyword">if</span> (first_len &gt;= second_len) &#123;</span><br><span class="line">        <span class="comment">/* retain first, append second to first. */</span></span><br><span class="line">        target = *first;</span><br><span class="line">        target_bytes = first_bytes;</span><br><span class="line">        source = *second;</span><br><span class="line">        source_bytes = second_bytes;</span><br><span class="line">        append = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* else, retain second, prepend first to second. */</span></span><br><span class="line">        target = *second;</span><br><span class="line">        target_bytes = second_bytes;</span><br><span class="line">        source = *first;</span><br><span class="line">        source_bytes = first_bytes;</span><br><span class="line">        append = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Calculate final bytes (subtract one pair of metadata) */</span></span><br><span class="line">    <span class="keyword">size_t</span> zlbytes = first_bytes + second_bytes -</span><br><span class="line">                     ZIPLIST_HEADER_SIZE - ZIPLIST_END_SIZE;</span><br><span class="line">    <span class="keyword">size_t</span> zllength = first_len + second_len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Combined zl length should be limited within UINT16_MAX */</span></span><br><span class="line">    zllength = zllength &lt; UINT16_MAX ? zllength : UINT16_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Save offset positions before we start ripping memory apart. */</span></span><br><span class="line">    <span class="keyword">size_t</span> first_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*first));</span><br><span class="line">    <span class="keyword">size_t</span> second_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*second));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Extend target to new zlbytes then append or prepend source. */</span></span><br><span class="line">    target = zrealloc(target, zlbytes);</span><br><span class="line">    <span class="keyword">if</span> (append) &#123;</span><br><span class="line">        <span class="comment">/* append == appending to target */</span></span><br><span class="line">        <span class="comment">/* Copy source after target (copying over original [END]):</span></span><br><span class="line"><span class="comment">         *   [TARGET - END, SOURCE - HEADER] */</span></span><br><span class="line">        <span class="built_in">memcpy</span>(target + target_bytes - ZIPLIST_END_SIZE,</span><br><span class="line">               source + ZIPLIST_HEADER_SIZE,</span><br><span class="line">               source_bytes - ZIPLIST_HEADER_SIZE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* !append == prepending to target */</span></span><br><span class="line">        <span class="comment">/* Move target *contents* exactly size of (source - [END]),</span></span><br><span class="line"><span class="comment">         * then copy source into vacataed space (source - [END]):</span></span><br><span class="line"><span class="comment">         *   [SOURCE - END, TARGET - HEADER] */</span></span><br><span class="line">        memmove(target + source_bytes - ZIPLIST_END_SIZE,</span><br><span class="line">                target + ZIPLIST_HEADER_SIZE,</span><br><span class="line">                target_bytes - ZIPLIST_HEADER_SIZE);</span><br><span class="line">        <span class="built_in">memcpy</span>(target, source, source_bytes - ZIPLIST_END_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update header metadata. */</span></span><br><span class="line">    ZIPLIST_BYTES(target) = intrev32ifbe(zlbytes);</span><br><span class="line">    ZIPLIST_LENGTH(target) = intrev16ifbe(zllength);</span><br><span class="line">    <span class="comment">/* New tail offset is:</span></span><br><span class="line"><span class="comment">     *   + N bytes of first ziplist</span></span><br><span class="line"><span class="comment">     *   - 1 byte for [END] of first ziplist</span></span><br><span class="line"><span class="comment">     *   + M bytes for the offset of the original tail of the second ziplist</span></span><br><span class="line"><span class="comment">     *   - J bytes for HEADER because second_offset keeps no header. */</span></span><br><span class="line">    ZIPLIST_TAIL_OFFSET(target) = intrev32ifbe(</span><br><span class="line">                                   (first_bytes - ZIPLIST_END_SIZE) +</span><br><span class="line">                                   (second_offset - ZIPLIST_HEADER_SIZE));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* __ziplistCascadeUpdate just fixes the prev length values until it finds a</span></span><br><span class="line"><span class="comment">     * correct prev length value (then it assumes the rest of the list is okay).</span></span><br><span class="line"><span class="comment">     * We tell CascadeUpdate to start at the first ziplist&#x27;s tail element to fix</span></span><br><span class="line"><span class="comment">     * the merge seam. */</span></span><br><span class="line">    target = __ziplistCascadeUpdate(target, target+first_offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now free and NULL out what we didn&#x27;t realloc */</span></span><br><span class="line">    <span class="keyword">if</span> (append) &#123;</span><br><span class="line">        zfree(*second);</span><br><span class="line">        *second = <span class="literal">NULL</span>;</span><br><span class="line">        *first = target;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zfree(*first);</span><br><span class="line">        *first = <span class="literal">NULL</span>;</span><br><span class="line">        *second = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unsigned-char-ziplistPush-unsigned-char-zl-unsigned-char-s-unsigned-int-slen-int-where"><a href="#unsigned-char-ziplistPush-unsigned-char-zl-unsigned-char-s-unsigned-int-slen-int-where" class="headerlink" title="unsigned char *ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where);"></a><code>unsigned char *ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where);</code></h3><h4 id="功能-16"><a href="#功能-16" class="headerlink" title="功能"></a>功能</h4><p>向ziplist添加数据<br>where表示在前面或者后面添加数据</p>
<h4 id="源码-16"><a href="#源码-16" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_HEAD 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_TAIL 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistPush</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line">    p = (where == ZIPLIST_HEAD) ? ZIPLIST_ENTRY_HEAD(zl) : ZIPLIST_ENTRY_END(zl);</span><br><span class="line">    <span class="keyword">return</span> __ziplistInsert(zl,p,s,slen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unsigned-char-ziplistIndex-unsigned-char-zl-int-index"><a href="#unsigned-char-ziplistIndex-unsigned-char-zl-int-index" class="headerlink" title="unsigned char *ziplistIndex(unsigned char *zl, int index);"></a><code>unsigned char *ziplistIndex(unsigned char *zl, int index);</code></h3><h4 id="功能-17"><a href="#功能-17" class="headerlink" title="功能"></a>功能</h4><p>根据索引获取元素</p>
<h4 id="源码-17"><a href="#源码-17" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Returns an offset to use for iterating with ziplistNext. When the given</span></span><br><span class="line"><span class="comment"> * index is negative, the list is traversed back to front. When the list</span></span><br><span class="line"><span class="comment"> * doesn&#x27;t contain an element at the provided index, NULL is returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistIndex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevlensize, prevlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        index = (-index)<span class="number">-1</span>;</span><br><span class="line">        p = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class="line">        <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">            ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</span><br><span class="line">            <span class="keyword">while</span> (prevlen &gt; <span class="number">0</span> &amp;&amp; index--) &#123;</span><br><span class="line">                p -= prevlen;</span><br><span class="line">                ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p = ZIPLIST_ENTRY_HEAD(zl);</span><br><span class="line">        <span class="keyword">while</span> (p[<span class="number">0</span>] != ZIP_END &amp;&amp; index--) &#123;</span><br><span class="line">            p += zipRawEntryLength(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (p[<span class="number">0</span>] == ZIP_END || index &gt; <span class="number">0</span>) ? <span class="literal">NULL</span> : p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unsigned-char-ziplistNext-unsigned-char-zl-unsigned-char-p"><a href="#unsigned-char-ziplistNext-unsigned-char-zl-unsigned-char-p" class="headerlink" title="unsigned char *ziplistNext(unsigned char *zl, unsigned char *p);"></a><code>unsigned char *ziplistNext(unsigned char *zl, unsigned char *p);</code></h3><h4 id="功能-18"><a href="#功能-18" class="headerlink" title="功能"></a>功能</h4><p>获取ziplist的下一个元素</p>
<h4 id="源码-18"><a href="#源码-18" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Return pointer to next entry in ziplist.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * zl is the pointer to the ziplist</span></span><br><span class="line"><span class="comment"> * p is the pointer to the current element</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The element after &#x27;p&#x27; is returned, otherwise NULL if we are at the end. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistNext</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    ((<span class="keyword">void</span>) zl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* &quot;p&quot; could be equal to ZIP_END, caused by ziplistDelete,</span></span><br><span class="line"><span class="comment">     * and we should return NULL. Otherwise, we should return NULL</span></span><br><span class="line"><span class="comment">     * when the *next* element is ZIP_END (there is no next entry). */</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] == ZIP_END) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p += zipRawEntryLength(p);</span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] == ZIP_END) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unsigned-char-ziplistPrev-unsigned-char-zl-unsigned-char-p"><a href="#unsigned-char-ziplistPrev-unsigned-char-zl-unsigned-char-p" class="headerlink" title="unsigned char *ziplistPrev(unsigned char *zl, unsigned char *p);"></a><code>unsigned char *ziplistPrev(unsigned char *zl, unsigned char *p);</code></h3><h4 id="功能-19"><a href="#功能-19" class="headerlink" title="功能"></a>功能</h4><p>获取ziplist的前一个元素</p>
<h4 id="源码-19"><a href="#源码-19" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Return pointer to previous entry in ziplist. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistPrev</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevlensize, prevlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Iterating backwards from ZIP_END should return the tail. When &quot;p&quot; is</span></span><br><span class="line"><span class="comment">     * equal to the first element of the list, we&#x27;re already at the head,</span></span><br><span class="line"><span class="comment">     * and should return NULL. */</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] == ZIP_END) &#123;</span><br><span class="line">        p = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class="line">        <span class="keyword">return</span> (p[<span class="number">0</span>] == ZIP_END) ? <span class="literal">NULL</span> : p;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p == ZIPLIST_ENTRY_HEAD(zl)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</span><br><span class="line">        assert(prevlen &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> p-prevlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unsigned-int-ziplistGet-unsigned-char-p-unsigned-char-sstr-unsigned-int-slen-long-long-sval"><a href="#unsigned-int-ziplistGet-unsigned-char-p-unsigned-char-sstr-unsigned-int-slen-long-long-sval" class="headerlink" title="unsigned int ziplistGet(unsigned char *p, unsigned char **sstr, unsigned int *slen, long long *sval);"></a><code>unsigned int ziplistGet(unsigned char *p, unsigned char **sstr, unsigned int *slen, long long *sval);</code></h3><h4 id="功能-20"><a href="#功能-20" class="headerlink" title="功能"></a>功能</h4><p>p为ziplist的一个entry的起始位置<br>获取这个p指向的entry的字符串或这值</p>
<h4 id="源码-20"><a href="#源码-20" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Get entry pointed to by &#x27;p&#x27; and store in either &#x27;*sstr&#x27; or &#x27;sval&#x27; depending</span></span><br><span class="line"><span class="comment"> * on the encoding of the entry. &#x27;*sstr&#x27; is always set to NULL to be able</span></span><br><span class="line"><span class="comment"> * to find out whether the string pointer or the integer value was set.</span></span><br><span class="line"><span class="comment"> * Return 0 if &#x27;p&#x27; points to the end of the ziplist, 1 otherwise. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">ziplistGet</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> **sstr, <span class="keyword">unsigned</span> <span class="keyword">int</span> *slen, <span class="keyword">long</span> <span class="keyword">long</span> *sval)</span> </span>&#123;</span><br><span class="line">    zlentry entry;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || p[<span class="number">0</span>] == ZIP_END) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sstr) *sstr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    zipEntry(p, &amp;entry);</span><br><span class="line">    <span class="keyword">if</span> (ZIP_IS_STR(entry.encoding)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sstr) &#123;</span><br><span class="line">            *slen = entry.len;</span><br><span class="line">            *sstr = p+entry.headersize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sval) &#123;</span><br><span class="line">            *sval = zipLoadInteger(p+entry.headersize,entry.encoding);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unsigned-char-ziplistInsert-unsigned-char-zl-unsigned-char-p-unsigned-char-s-unsigned-int-slen-1"><a href="#unsigned-char-ziplistInsert-unsigned-char-zl-unsigned-char-p-unsigned-char-s-unsigned-int-slen-1" class="headerlink" title="unsigned char *ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen);"></a><code>unsigned char *ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen);</code></h3><h4 id="功能-21"><a href="#功能-21" class="headerlink" title="功能"></a>功能</h4><p>在ziplist的p位置插入新的元素</p>
<h4 id="源码-21"><a href="#源码-21" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Insert an entry at &quot;p&quot;. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistInsert</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __ziplistInsert(zl,p,s,slen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unsigned-char-ziplistDelete-unsigned-char-zl-unsigned-char-p"><a href="#unsigned-char-ziplistDelete-unsigned-char-zl-unsigned-char-p" class="headerlink" title="unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p)"></a><code>unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p)</code></h3><h4 id="功能-22"><a href="#功能-22" class="headerlink" title="功能"></a>功能</h4><p>删除ziplist元素,返回新的ziplist</p>
<h4 id="源码-22"><a href="#源码-22" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Delete a single entry from the ziplist, pointed to by *p.</span></span><br><span class="line"><span class="comment"> * Also update *p in place, to be able to iterate over the</span></span><br><span class="line"><span class="comment"> * ziplist, while deleting entries. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistDelete</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> **p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> offset = *p-zl;</span><br><span class="line">    zl = __ziplistDelete(zl,*p,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Store pointer to current element in p, because ziplistDelete will</span></span><br><span class="line"><span class="comment">     * do a realloc which might result in a different &quot;zl&quot;-pointer.</span></span><br><span class="line"><span class="comment">     * When the delete direction is back to front, we might delete the last</span></span><br><span class="line"><span class="comment">     * entry and end up with &quot;p&quot; pointing to ZIP_END, so check this. */</span></span><br><span class="line">    *p = zl+offset;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unsigned-char-ziplistDeleteRange-unsigned-char-zl-int-index-unsigned-int-num"><a href="#unsigned-char-ziplistDeleteRange-unsigned-char-zl-int-index-unsigned-int-num" class="headerlink" title="unsigned char *ziplistDeleteRange(unsigned char *zl, int index, unsigned int num);"></a><code>unsigned char *ziplistDeleteRange(unsigned char *zl, int index, unsigned int num);</code></h3><h4 id="功能-23"><a href="#功能-23" class="headerlink" title="功能"></a>功能</h4><p>从index开始连续删除num个元素</p>
<h4 id="源码-23"><a href="#源码-23" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Delete a range of entries from the ziplist. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistDeleteRange</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">int</span> index, <span class="keyword">unsigned</span> <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = ziplistIndex(zl,index);</span><br><span class="line">    <span class="keyword">return</span> (p == <span class="literal">NULL</span>) ? zl : __ziplistDelete(zl,p,num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unsigned-int-ziplistCompare-unsigned-char-p-unsigned-char-sstr-unsigned-int-slen"><a href="#unsigned-int-ziplistCompare-unsigned-char-p-unsigned-char-sstr-unsigned-int-slen" class="headerlink" title="unsigned int ziplistCompare(unsigned char *p, unsigned char *sstr, unsigned int slen);"></a><code>unsigned int ziplistCompare(unsigned char *p, unsigned char *sstr, unsigned int slen);</code></h3><h4 id="功能-24"><a href="#功能-24" class="headerlink" title="功能"></a>功能</h4><p>判断传入的数据是否与p对应的元素的值相同</p>
<h4 id="源码-24"><a href="#源码-24" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Compare entry pointer to by &#x27;p&#x27; with &#x27;sstr&#x27; of length &#x27;slen&#x27;. */</span></span><br><span class="line"><span class="comment">/* Return 1 if equal. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">ziplistCompare</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *sstr, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen)</span> </span>&#123;</span><br><span class="line">    zlentry entry;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sencoding;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> zval, sval;</span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] == ZIP_END) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    zipEntry(p, &amp;entry);</span><br><span class="line">    <span class="keyword">if</span> (ZIP_IS_STR(entry.encoding)) &#123;</span><br><span class="line">        <span class="comment">/* Raw compare */</span></span><br><span class="line">        <span class="keyword">if</span> (entry.len == slen) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">memcmp</span>(p+entry.headersize,sstr,slen) == <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Try to compare encoded values. Don&#x27;t compare encoding because</span></span><br><span class="line"><span class="comment">         * different implementations may encoded integers differently. */</span></span><br><span class="line">        <span class="keyword">if</span> (zipTryEncoding(sstr,slen,&amp;sval,&amp;sencoding)) &#123;</span><br><span class="line">          zval = zipLoadInteger(p+entry.headersize,entry.encoding);</span><br><span class="line">          <span class="keyword">return</span> zval == sval;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unsigned-char-ziplistFind-unsigned-char-p-unsigned-char-vstr-unsigned-int-vlen-unsigned-int-skip"><a href="#unsigned-char-ziplistFind-unsigned-char-p-unsigned-char-vstr-unsigned-int-vlen-unsigned-int-skip" class="headerlink" title="unsigned char *ziplistFind(unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip);"></a><code>unsigned char *ziplistFind(unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip);</code></h3><h4 id="功能-25"><a href="#功能-25" class="headerlink" title="功能"></a>功能</h4><p>查找指定元素<br>skip:需要跳过的元素的个数</p>
<h4 id="源码-25"><a href="#源码-25" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Find pointer to the entry equal to the specified entry. Skip &#x27;skip&#x27; entries</span></span><br><span class="line"><span class="comment"> * between every comparison. Returns NULL when the field could not be found. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistFind</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr, <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen, <span class="keyword">unsigned</span> <span class="keyword">int</span> skip)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> skipcnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> vencoding = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> vll = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> prevlensize, encoding, lensize, len;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *q;</span><br><span class="line"></span><br><span class="line">        ZIP_DECODE_PREVLENSIZE(p, prevlensize);</span><br><span class="line">        ZIP_DECODE_LENGTH(p + prevlensize, encoding, lensize, len);</span><br><span class="line">        q = p + prevlensize + lensize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (skipcnt == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* Compare current entry with specified entry */</span></span><br><span class="line">            <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (len == vlen &amp;&amp; <span class="built_in">memcmp</span>(q, vstr, vlen) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Find out if the searched field can be encoded. Note that</span></span><br><span class="line"><span class="comment">                 * we do it only the first time, once done vencoding is set</span></span><br><span class="line"><span class="comment">                 * to non-zero and vll is set to the integer value. */</span></span><br><span class="line">                <span class="keyword">if</span> (vencoding == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!zipTryEncoding(vstr, vlen, &amp;vll, &amp;vencoding)) &#123;</span><br><span class="line">                        <span class="comment">/* If the entry can&#x27;t be encoded we set it to</span></span><br><span class="line"><span class="comment">                         * UCHAR_MAX so that we don&#x27;t retry again the next</span></span><br><span class="line"><span class="comment">                         * time. */</span></span><br><span class="line">                        vencoding = UCHAR_MAX;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/* Must be non-zero by now */</span></span><br><span class="line">                    assert(vencoding);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Compare current entry with specified entry, do it only</span></span><br><span class="line"><span class="comment">                 * if vencoding != UCHAR_MAX because if there is no encoding</span></span><br><span class="line"><span class="comment">                 * possible for the field it can&#x27;t be a valid integer. */</span></span><br><span class="line">                <span class="keyword">if</span> (vencoding != UCHAR_MAX) &#123;</span><br><span class="line">                    <span class="keyword">long</span> <span class="keyword">long</span> ll = zipLoadInteger(q, encoding);</span><br><span class="line">                    <span class="keyword">if</span> (ll == vll) &#123;</span><br><span class="line">                        <span class="keyword">return</span> p;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Reset skip count */</span></span><br><span class="line">            skipcnt = skip;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Skip entry */</span></span><br><span class="line">            skipcnt--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Move to next entry */</span></span><br><span class="line">        p = q + len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unsigned-int-ziplistLen-unsigned-char-zl"><a href="#unsigned-int-ziplistLen-unsigned-char-zl" class="headerlink" title="unsigned int ziplistLen(unsigned char *zl);"></a><code>unsigned int ziplistLen(unsigned char *zl);</code></h3><h4 id="功能-26"><a href="#功能-26" class="headerlink" title="功能"></a>功能</h4><p>获取ziplist的长度</p>
<h4 id="源码-26"><a href="#源码-26" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Return length of ziplist. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">ziplistLen</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (intrev16ifbe(ZIPLIST_LENGTH(zl)) &lt; UINT16_MAX) &#123;</span><br><span class="line">        len = intrev16ifbe(ZIPLIST_LENGTH(zl));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = zl+ZIPLIST_HEADER_SIZE;</span><br><span class="line">        <span class="keyword">while</span> (*p != ZIP_END) &#123;</span><br><span class="line">            p += zipRawEntryLength(p);</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Re-store length if small enough */</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; UINT16_MAX) ZIPLIST_LENGTH(zl) = intrev16ifbe(len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="size-t-ziplistBlobLen-unsigned-char-zl"><a href="#size-t-ziplistBlobLen-unsigned-char-zl" class="headerlink" title="size_t ziplistBlobLen(unsigned char *zl);"></a><code>size_t ziplistBlobLen(unsigned char *zl);</code></h3><h4 id="功能-27"><a href="#功能-27" class="headerlink" title="功能"></a>功能</h4><p>获取ziplist的总占用字节数</p>
<h4 id="源码-27"><a href="#源码-27" class="headerlink" title="源码"></a>源码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Return ziplist blob size in bytes. */</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">ziplistBlobLen</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> intrev32ifbe(ZIPLIST_BYTES(zl));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>redis</category>
        <category>source</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>redis</tag>
      </tags>
  </entry>
</search>
